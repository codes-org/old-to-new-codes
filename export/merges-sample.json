{
    "merge_requests": [
        {
            "id": 21,
            "target_branch": "master",
            "source_branch": "master",
            "source_project_id": null,
            "author_id": 219,
            "assignee_id": null,
            "title": "Bug fix in dfly routing",
            "created_at": "2016-07-19T15:46:46.314Z",
            "updated_at": "2016-07-19T15:52:53.474Z",
            "state": "merged",
            "merge_status": "can_be_merged",
            "target_project_id": 68,
            "iid": 7,
            "description": "Change-Id: I53f278953f2e287bf122cf20694a7db3bd1fd336",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": null
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": "03cc9c23dab17012dfe74ff0364b03db0351d904",
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": "09bf4ffab64510b45fff2cc594ee18a68e041041",
            "source_branch_sha": null,
            "target_branch_sha": "fb41c9c0b553f6a042834de25dec05fc8c5f70ba",
            "metrics": {
                "id": 520,
                "merge_request_id": 21,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2016-07-19T15:46:46.314Z",
                "updated_at": "2016-07-19T15:52:53.474Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": null,
                "latest_closed_at": null
            },
            "notes": [
                {
                    "id": 2039,
                    "note": "mentioned in commit 03cc9c23dab17012dfe74ff0364b03db0351d904",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2016-07-19T15:52:53.436Z",
                    "updated_at": "2016-07-19T15:52:53.436Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 21,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "6a5379f8dee5d97c454464fe549dfda9e9790971",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                },
                {
                    "id": 2040,
                    "note": "Status changed to merged",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2016-07-19T15:52:53.467Z",
                    "updated_at": "2016-07-19T15:52:53.467Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 21,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "cf0a4b4c650b8ff6829356e57e383459e913058c",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                }
            ],
            "merge_request_diff": {
                "id": 21,
                "state": "collected",
                "merge_request_id": 21,
                "created_at": "2016-07-19T15:46:46.338Z",
                "updated_at": "2016-07-19T15:46:46.428Z",
                "base_commit_sha": "06a7bce8107bebf18f3d6970206b2f3f7f7089db",
                "real_size": "1",
                "head_commit_sha": "09bf4ffab64510b45fff2cc594ee18a68e041041",
                "start_commit_sha": null,
                "commits_count": 1,
                "merge_request_diff_commits": [
                    {
                        "authored_date": "2016-07-19T15:45:03.000Z",
                        "committed_date": "2016-07-19T15:45:03.000Z",
                        "merge_request_diff_id": 21,
                        "relative_order": 0,
                        "sha": "09bf4ffab64510b45fff2cc594ee18a68e041041",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Bug fix in dfly routing\n\nChange-Id: I53f278953f2e287bf122cf20694a7db3bd1fd336\n"
                    }
                ],
                "merge_request_diff_files": [
                    {
                        "merge_request_diff_id": 21,
                        "relative_order": 0,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/dragonfly.c",
                        "old_path": "src/networks/model-net/dragonfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/dragonfly.c\n+++ b/src/networks/model-net/dragonfly.c\n@@ -3022,7 +3022,7 @@ void router_buf_update_rc(router_state * s,\n         prepend_to_terminal_message_list(s->queued_msgs[indx],\n             s->queued_msgs_tail[indx], output_chan, head);\n         s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n-        s->queued_count[indx] -= s->params->chunk_size;\n+        s->queued_count[indx] += s->params->chunk_size;\n       }\n       if(bf->c2) {\n         codes_local_latency_reverse(lp);\n@@ -3054,7 +3054,7 @@ void router_buf_update(router_state * s, tw_bf * bf, terminal_message * msg, tw_\n     append_to_terminal_message_list(s->pending_msgs[indx],\n       s->pending_msgs_tail[indx], output_chan, head);\n     s->vc_occupancy[indx][output_chan] += s->params->chunk_size;\n-    s->queued_count[indx] += s->params->chunk_size;\n+    s->queued_count[indx] -= s->params->chunk_size;\n   }\n   if(s->in_send_loop[indx] == 0 && s->pending_msgs[indx][output_chan] != NULL) {\n     bf->c2 = 1;\n"
                    }
                ]
            },
            "events": [],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        },
        {
            "id": 943,
            "target_branch": "qos-dev",
            "source_branch": "rng-fix",
            "source_project_id": 68,
            "author_id": 75,
            "assignee_id": null,
            "title": "Rng fix",
            "created_at": "2018-08-24T21:33:15.462Z",
            "updated_at": "2018-08-24T22:19:02.614Z",
            "state": "closed",
            "merge_status": "cannot_be_merged",
            "target_project_id": 68,
            "iid": 58,
            "description": "",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": "0"
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": null,
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": "69292f036511248c900f42995570416c0002733c",
            "source_branch_sha": "69292f036511248c900f42995570416c0002733c",
            "target_branch_sha": "23f4703873d314c9245d0385f7b423405a502110",
            "metrics": {
                "id": 943,
                "merge_request_id": 943,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2018-08-24T21:33:15.738Z",
                "updated_at": "2018-08-24T22:19:02.652Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": 75,
                "latest_closed_at": "2018-08-24T22:19:02.639Z"
            },
            "notes": [
                {
                    "id": 10781,
                    "note": "closed",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2018-08-24T22:19:02.658Z",
                    "updated_at": "2018-08-24T22:19:02.658Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 943,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "9ee502f7b0e89b781f3156bbe636ef1227c043f2",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                }
            ],
            "merge_request_diff": {
                "id": 1613,
                "state": "collected",
                "merge_request_id": 943,
                "created_at": "2018-08-24T21:33:15.531Z",
                "updated_at": "2018-08-24T21:33:15.531Z",
                "base_commit_sha": "66290294250b49d483af23f8ee3791d83447d88b",
                "real_size": "58",
                "head_commit_sha": "69292f036511248c900f42995570416c0002733c",
                "start_commit_sha": "d2e5b31d664d2fd2727cb2c96a0d7c561fc82aff",
                "commits_count": 25,
                "merge_request_diff_commits": [
                    {
                        "authored_date": "2018-08-20T16:23:00.000Z",
                        "committed_date": "2018-08-20T16:23:00.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 0,
                        "sha": "69292f036511248c900f42995570416c0002733c",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fix RNG reverse bug in model-net.c\n"
                    },
                    {
                        "authored_date": "2018-08-17T17:17:49.000Z",
                        "committed_date": "2018-08-17T17:17:49.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 1,
                        "sha": "a3f129b4b8a6217fc0f6ac9e823a01cde6282bb2",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fixing more mpi replay RNG reverse errors\n"
                    },
                    {
                        "authored_date": "2018-08-16T20:21:14.000Z",
                        "committed_date": "2018-08-16T20:21:14.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 2,
                        "sha": "b8cece6db4af459c3e78e9c5b82fbfce24f63f5b",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fixing RNG reverse errors in mpi replay\n"
                    },
                    {
                        "authored_date": "2018-08-16T19:16:42.000Z",
                        "committed_date": "2018-08-16T19:16:42.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 3,
                        "sha": "293ab0475e9ab1620903b6cc2461cf72c6982dca",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fixing fat-tree RNG reverse errors\n"
                    },
                    {
                        "authored_date": "2018-07-26T18:16:44.000Z",
                        "committed_date": "2018-07-26T18:16:44.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 4,
                        "sha": "bd0052a7a0d66105a89d105f1dd70cb032624816",
                        "author_name": "Misbah Mubarak",
                        "author_email": "mmubarak@anl.gov",
                        "committer_name": "Misbah Mubarak",
                        "committer_email": "mmubarak@anl.gov",
                        "message": "Merge branch 'model-net-inst' into 'master'\n\nadding NULLs to model_net_method structs\n\nSee merge request codes/codes!55"
                    },
                    {
                        "authored_date": "2018-07-26T18:12:26.000Z",
                        "committed_date": "2018-07-26T18:12:26.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 5,
                        "sha": "783359deb3e072f58bdfb92fc6e3537506cec945",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "adding in NULLs for the ROSS instrumentation related elements in model_net_method structs if it has not been implemented in the given network\n"
                    },
                    {
                        "authored_date": "2018-07-25T13:51:58.000Z",
                        "committed_date": "2018-07-25T13:51:58.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 6,
                        "sha": "9fbdc45aba39f3a072dc1ac91bde86039a1cac56",
                        "author_name": "Misbah Mubarak",
                        "author_email": "mmubarak@anl.gov",
                        "committer_name": "Misbah Mubarak",
                        "committer_email": "mmubarak@anl.gov",
                        "message": "Merge branch 'damaris' into 'master'\n\nROSS-Damaris integration support\n\nSee merge request codes/codes!54"
                    },
                    {
                        "authored_date": "2018-07-25T13:50:51.000Z",
                        "committed_date": "2018-07-25T13:50:51.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 7,
                        "sha": "621ba97be062c8e309603ec7fee418438f483976",
                        "author_name": "Misbah Mubarak",
                        "author_email": "mmubarak@anl.gov",
                        "committer_name": "Misbah Mubarak",
                        "committer_email": "mmubarak@anl.gov",
                        "message": "Merge branch 'nikhil/ftree-mapfix' into 'master'\n\nClean up fat-tree a bit\n\nSee merge request codes/codes!44"
                    },
                    {
                        "authored_date": "2018-07-24T21:24:14.000Z",
                        "committed_date": "2018-07-24T21:24:14.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 8,
                        "sha": "d271ea9469462da1c471c842d04a3da8f6e0b666",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fixing DFP synthetic workload RC bug\n"
                    },
                    {
                        "authored_date": "2018-07-24T20:46:51.000Z",
                        "committed_date": "2018-07-24T20:46:51.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 9,
                        "sha": "ea65139b3c1e8ca10897a81cea0e8a4c43ed3a17",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "adding in all the necessary callback and registration functions for using ROSS instrumentation with DFP\n"
                    },
                    {
                        "authored_date": "2018-07-16T21:36:51.000Z",
                        "committed_date": "2018-07-16T21:36:51.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 10,
                        "sha": "d1e36f845af9a809691a9d4be727a61cc284a5aa",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "updating dfly-plus for use with damaris\n"
                    },
                    {
                        "authored_date": "2018-07-16T20:55:36.000Z",
                        "committed_date": "2018-07-16T20:55:36.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 11,
                        "sha": "3e4bff242284dcd12b17ce81f375950ba4d42530",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "Merge branch 'master' into damaris\n"
                    },
                    {
                        "authored_date": "2018-07-13T16:49:28.000Z",
                        "committed_date": "2018-07-13T16:49:28.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 12,
                        "sha": "4796657a97add0df38ce76cd95ce0ca5a468fe98",
                        "author_name": "mubarak",
                        "author_email": "mubarak@mcs.anl.gov",
                        "committer_name": "mubarak",
                        "committer_email": "mubarak@mcs.anl.gov",
                        "message": "preparing for release: Adding release notes and makefile fixes for release 1.0.0\n"
                    },
                    {
                        "authored_date": "2018-07-13T15:33:52.000Z",
                        "committed_date": "2018-07-13T15:33:52.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 13,
                        "sha": "bfa8f635955949a0cdfa9f599ab54f582596cf98",
                        "author_name": "mubarak",
                        "author_email": "mubarak@mcs.anl.gov",
                        "committer_name": "mubarak",
                        "committer_email": "mubarak@mcs.anl.gov",
                        "message": "updating ROSS message sizes to build tests\n"
                    },
                    {
                        "authored_date": "2018-07-13T14:35:23.000Z",
                        "committed_date": "2018-07-13T14:35:23.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 14,
                        "sha": "dd66ea45cd439ed5c9ff02266f4de2aa86a51db6",
                        "author_name": "Misbah Mubarak",
                        "author_email": "mmubarak@anl.gov",
                        "committer_name": "Misbah Mubarak",
                        "committer_email": "mmubarak@anl.gov",
                        "message": "Merge branch 'dfp-big-to-release' into 'master'\n\nDragonfly Plus and Related Work\n\nSee merge request codes/codes!53"
                    },
                    {
                        "authored_date": "2018-07-10T18:57:18.000Z",
                        "committed_date": "2018-07-12T19:52:38.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 15,
                        "sha": "5b1538bdae1cc5a098f9a47fb1016dcf0faaac14",
                        "author_name": "Neil McGlohon",
                        "author_email": "nmcglohon@gmail.com",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "Replace dragonfly-custom with mainline version\n"
                    },
                    {
                        "authored_date": "2018-07-10T18:25:06.000Z",
                        "committed_date": "2018-07-12T19:52:38.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 16,
                        "sha": "7ec09c3cbfa62e3406a3ca25dbfd4d17e3a2631a",
                        "author_name": "Neil McGlohon",
                        "author_email": "nmcglohon@gmail.com",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "Delete Unnecessary Files pertaining to DFP\n"
                    },
                    {
                        "authored_date": "2018-07-12T18:38:25.000Z",
                        "committed_date": "2018-07-12T18:38:25.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 17,
                        "sha": "ad426794b535c99f27f6fedb626eaecb861861c7",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "fixing minor mistake in build process when using Damaris\n"
                    },
                    {
                        "authored_date": "2018-07-11T22:56:47.000Z",
                        "committed_date": "2018-07-11T22:56:47.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 18,
                        "sha": "25f66fdb7fcd7febecc8b06e47f754f50443f150",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "changing MPI_COMM_WORLD to MPI_COMM_CODES and other support for using ROSS-Damaris\n"
                    },
                    {
                        "authored_date": "2018-07-11T19:55:33.000Z",
                        "committed_date": "2018-07-11T19:55:33.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 19,
                        "sha": "9d87ca60718491dd8e7951425ed16b8749858e9a",
                        "author_name": "Caitlin Ross",
                        "author_email": "rossc3@rpi.edu",
                        "committer_name": "Caitlin Ross",
                        "committer_email": "rossc3@rpi.edu",
                        "message": "adding support for using Damaris\n"
                    },
                    {
                        "authored_date": "2018-07-06T18:15:34.000Z",
                        "committed_date": "2018-07-06T18:15:34.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 20,
                        "sha": "f287df62fd5bd139b9f162aa2a179ab607fab411",
                        "author_name": "Neil McGlohon",
                        "author_email": "nmcglohon@gmail.com",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "Dragonfly Custom: wrong size calloc fix\n"
                    },
                    {
                        "authored_date": "2018-07-06T18:14:05.000Z",
                        "committed_date": "2018-07-06T18:14:05.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 21,
                        "sha": "658bb5fb3ee8ab3e12776b8481a8ea4965c2b6fc",
                        "author_name": "Neil McGlohon",
                        "author_email": "nmcglohon@gmail.com",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "DFP: busy_time and last_buf_full behavior adjustment\n"
                    },
                    {
                        "authored_date": "2018-07-05T22:55:49.000Z",
                        "committed_date": "2018-07-05T22:55:49.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 22,
                        "sha": "d8dc7ca348abdbdff8e3e1d4e83f0a080ddb414a",
                        "author_name": "Neil McGlohon",
                        "author_email": "nmcglohon@gmail.com",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "dragonfly plus link stats (untested)\n"
                    },
                    {
                        "authored_date": "2018-07-03T20:59:29.000Z",
                        "committed_date": "2018-07-03T21:13:14.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 23,
                        "sha": "2da80e0e68b9e8417b4c833288480bbf5e56c741",
                        "author_name": "mubarak",
                        "author_email": "mmubarak@anl.gov",
                        "committer_name": "Neil McGlohon",
                        "committer_email": "nmcglohon@gmail.com",
                        "message": "setting vcs to avoid packet deadlock bug\n"
                    },
                    {
                        "authored_date": "2018-02-27T19:06:01.000Z",
                        "committed_date": "2018-02-27T19:09:09.000Z",
                        "merge_request_diff_id": 1613,
                        "relative_order": 24,
                        "sha": "4937ed81d6cfdc34ae3977882c89fc2de1582c60",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Clean up fat-tree a bit\n\nMake type 0 default and usable for typical multi-plane cases. Update the\ndocumentation accordingly.\n\nChange-Id: Ica63f5c24b9af95a4735e2c9277b147c9cf095da\n"
                    }
                ],
                "merge_request_diff_files": [
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 0,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "Makefile.am",
                        "old_path": "Makefile.am",
                        "binary": false,
                        "utf8_diff": "--- a/Makefile.am\n+++ b/Makefile.am\n@@ -88,3 +88,7 @@ endif\n LDADD += ${DUMPI_LIBS}\n endif\n \n+if USE_RDAMARIS\n+AM_CPPFLAGS += ${ROSS_Damaris_CFLAGS} -DUSE_RDAMARIS=1\n+LDADD += ${ROSS_Damaris_LIBS}\n+endif\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 1,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "codes/codes.h",
                        "old_path": "codes/codes.h",
                        "binary": false,
                        "utf8_diff": "--- a/codes/codes.h\n+++ b/codes/codes.h\n@@ -97,6 +97,8 @@ static inline void codes_local_latency_reverse(tw_lp *lp)\n     return;\n }\n \n+void codes_comm_update();\n+\n #ifdef __cplusplus\n }\n #endif\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 2,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "codes/net/dragonfly-plus.h",
                        "old_path": "codes/net/dragonfly-plus.h",
                        "binary": false,
                        "utf8_diff": "--- a/codes/net/dragonfly-plus.h\n+++ b/codes/net/dragonfly-plus.h\n@@ -92,6 +92,8 @@ struct terminal_plus_message\n    tw_stime saved_total_time;\n    tw_stime saved_sample_time;\n    tw_stime msg_start_time;\n+   tw_stime saved_busy_time_ross;\n+   tw_stime saved_fin_chunks_ross;\n };\n \n #ifdef __cplusplus\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 3,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100755",
                        "b_mode": "100755",
                        "new_path": "configure.ac",
                        "old_path": "configure.ac",
                        "binary": false,
                        "utf8_diff": "--- a/configure.ac\n+++ b/configure.ac\n@@ -2,7 +2,7 @@\n # Process this file with autoconf to produce a configure script.\n \n AC_PREREQ([2.67])\n-AC_INIT([codes], [0.6.0], [http://trac.mcs.anl.gov/projects/codes/newticket],[],[http://www.mcs.anl.gov/projects/codes/])\n+AC_INIT([codes], [1.0.0], [http://trac.mcs.anl.gov/projects/codes/newticket],[],[http://www.mcs.anl.gov/projects/codes/])\n LT_INIT\n \n \n@@ -89,6 +89,16 @@ AC_TRY_COMPILE([#include <mpi.h>], [int ret = MPI_Init(0, (void*)0)],\n PKG_CHECK_MODULES_STATIC([ROSS], [ross], [],\n                   [AC_MSG_ERROR([Could not find working ross installation via pkg-config])])\n \n+#check for Damaris\n+AC_ARG_WITH([damaris],[AS_HELP_STRING([--with-damaris],\n+                        [build with ROSS-Damaris in situ analysis support])],\n+                        [use_rdamaris=yes],[use_rdamaris=no])\n+if test \"x${use_rdamaris}\" = xyes ; then\n+    PKG_CHECK_MODULES_STATIC([ROSS_Damaris], [ross-damaris], [],\n+                             [AC_MSG_ERROR([Could not find working ROSS-Damaris installation via pkg-config])])\n+fi\n+AM_CONDITIONAL(USE_RDAMARIS, [test \"x${use_rdamaris}\" = xyes])\n+\n # check for enable-g\n AC_ARG_ENABLE([g],[AS_HELP_STRING([--enable-g],\n \t\t\t[Build with GDB symbols])],\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 4,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "doc/GETTING_STARTED",
                        "old_path": "doc/GETTING_STARTED",
                        "binary": false,
                        "utf8_diff": "--- a/doc/GETTING_STARTED\n+++ b/doc/GETTING_STARTED\n@@ -187,6 +187,10 @@ TODO...\n \n === Network\n \n+There has been an addition of online workload generator that replays calls\n+similar to MPI on the network models. The SWM workloads are closed-source right\n+now but integration with conceptual communication library is in progress.\n+\n Our primary network workload generator is via the DUMPI tool\n (http://sst.sandia.gov/about_dumpi.html). DUMPI collects and reads events from\n MPI applications. See the DUMPI documentation for how to generate traces. There\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 5,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "doc/RELEASE_NOTES",
                        "old_path": "doc/RELEASE_NOTES",
                        "binary": false,
                        "utf8_diff": "--- a/doc/RELEASE_NOTES\n+++ b/doc/RELEASE_NOTES\n@@ -1,3 +1,46 @@\n+1.0.0 (July 12, 2018)\n+\n+general:\n+=======\n+Adding support for dragonfly-plus network model. Multiple forms of routing\n+(progressive adaptive, minimal, non-minimal-spine and leaf) have been\n+implemented.\n+\n+https://xgitlab.cels.anl.gov/codes/codes/wikis/dragonfly-plus\n+\n+Adding support for express mesh network model, which can be configured as\n+hyperX.\n+\n+Adding support for Multi-plane/rail in fat-tree via multiple single port NICs\n+per compute node or one multi-port NIC per node.\n+\n+Adding a generic template for building new network models. For simplest case,\n+only 2 functions and premable changes should suffice to add a new network.\n+Updated Express Mesh network model to serve as an example. For details, see \n+\n+Darshan workload generator has been updated to use Darshan version 3.x.\n+\n+Network models updated to capture simulation statistics over virtual time using\n+ROSS/CODES instrumentation. For details, see:\n+\n+https://xgitlab.cels.anl.gov/codes/codes/wikis/Using-ROSS-Instrumentation-with-CODES\n+\n+Compatible with ROSS version that enables statistics collection of simulation\n+performance. For details see:\n+\n+http://carothersc.github.io/ROSS/instrumentation/instrumentation.html\n+\n+Online workload replay functionality has been added that allows SWM workloads\n+to be simulated insitu on the network models. WIP to integrate Conceptual\n+domain specific language for network communication.  \n+\n+Multiple traffic patterns were added in the background traffic generation\n+including stencil, all-to-all and random permutation.\n+\n+Performance tuning enabled for optimistic mode. For details, see:\n+\n+https://xgitlab.cels.anl.gov/codes/codes/wikis/Optimistic-Performance-Tuning-Tips\n+\n 0.6.0 (July 03, 2017)\n \n general:\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 6,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": true,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/dragonfly-custom/example/output",
                        "old_path": "scripts/dragonfly-custom/example/output",
                        "binary": false,
                        "utf8_diff": ""
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 7,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/dragonfly-plus/example/output",
                        "old_path": "scripts/dragonfly-plus/example/output",
                        "binary": false,
                        "utf8_diff": "--- a/scripts/dragonfly-plus/example/output\n+++ /dev/null\n@@ -1,400 +0,0 @@\n-4,20,1,0\r\n-5,21,1,0\r\n-6,22,1,0\r\n-7,23,1,0\r\n-8,20,1,0\r\n-9,21,1,0\r\n-10,22,1,0\r\n-11,23,1,0\r\n-12,20,1,0\r\n-13,21,1,0\r\n-14,22,1,0\r\n-15,23,1,0\r\n-16,20,1,0\r\n-17,21,1,0\r\n-18,22,1,0\r\n-19,23,1,0\r\n-20,24,0,0\r\n-20,25,0,0\r\n-20,26,0,0\r\n-20,27,0,0\r\n-20,4,0,1\r\n-20,8,0,1\r\n-20,12,0,1\r\n-20,16,0,1\r\n-21,24,0,0\r\n-21,25,0,0\r\n-21,26,0,0\r\n-21,27,0,0\r\n-21,5,0,1\r\n-21,9,0,1\r\n-21,13,0,1\r\n-21,17,0,1\r\n-22,24,0,0\r\n-22,25,0,0\r\n-22,26,0,0\r\n-22,27,0,0\r\n-22,6,0,1\r\n-22,10,0,1\r\n-22,14,0,1\r\n-22,18,0,1\r\n-23,24,0,0\r\n-23,25,0,0\r\n-23,26,0,0\r\n-23,27,0,0\r\n-23,7,0,1\r\n-23,11,0,1\r\n-23,15,0,1\r\n-23,19,0,1\r\n-24,55,0,0\r\n-24,83,0,0\r\n-24,111,0,0\r\n-24,139,0,0\r\n-24,20,0,0\r\n-24,21,0,0\r\n-24,22,0,0\r\n-24,23,0,0\r\n-25,54,0,0\r\n-25,82,0,0\r\n-25,110,0,0\r\n-25,138,0,0\r\n-25,20,0,0\r\n-25,21,0,0\r\n-25,22,0,0\r\n-25,23,0,0\r\n-26,53,0,0\r\n-26,81,0,0\r\n-26,109,0,0\r\n-26,137,0,0\r\n-26,20,0,0\r\n-26,21,0,0\r\n-26,22,0,0\r\n-26,23,0,0\r\n-27,52,0,0\r\n-27,80,0,0\r\n-27,108,0,0\r\n-27,136,0,0\r\n-27,20,0,0\r\n-27,21,0,0\r\n-27,22,0,0\r\n-27,23,0,0\r\n-32,48,1,0\r\n-33,49,1,0\r\n-34,50,1,0\r\n-35,51,1,0\r\n-36,48,1,0\r\n-37,49,1,0\r\n-38,50,1,0\r\n-39,51,1,0\r\n-40,48,1,0\r\n-41,49,1,0\r\n-42,50,1,0\r\n-43,51,1,0\r\n-44,48,1,0\r\n-45,49,1,0\r\n-46,50,1,0\r\n-47,51,1,0\r\n-48,52,0,0\r\n-48,53,0,0\r\n-48,54,0,0\r\n-48,55,0,0\r\n-48,32,0,1\r\n-48,36,0,1\r\n-48,40,0,1\r\n-48,44,0,1\r\n-49,52,0,0\r\n-49,53,0,0\r\n-49,54,0,0\r\n-49,55,0,0\r\n-49,33,0,1\r\n-49,37,0,1\r\n-49,41,0,1\r\n-49,45,0,1\r\n-50,52,0,0\r\n-50,53,0,0\r\n-50,54,0,0\r\n-50,55,0,0\r\n-50,34,0,1\r\n-50,38,0,1\r\n-50,42,0,1\r\n-50,46,0,1\r\n-51,52,0,0\r\n-51,53,0,0\r\n-51,54,0,0\r\n-51,55,0,0\r\n-51,35,0,1\r\n-51,39,0,1\r\n-51,43,0,1\r\n-51,47,0,1\r\n-52,83,0,0\r\n-52,111,0,0\r\n-52,139,0,0\r\n-52,27,0,0\r\n-52,48,0,0\r\n-52,49,0,0\r\n-52,50,0,0\r\n-52,51,0,0\r\n-53,82,0,0\r\n-53,110,0,0\r\n-53,138,0,0\r\n-53,26,0,0\r\n-53,48,0,0\r\n-53,49,0,0\r\n-53,50,0,0\r\n-53,51,0,0\r\n-54,81,0,0\r\n-54,109,0,0\r\n-54,137,0,0\r\n-54,25,0,0\r\n-54,48,0,0\r\n-54,49,0,0\r\n-54,50,0,0\r\n-54,51,0,0\r\n-55,80,0,0\r\n-55,108,0,0\r\n-55,136,0,0\r\n-55,24,0,0\r\n-55,48,0,0\r\n-55,49,0,0\r\n-55,50,0,0\r\n-55,51,0,0\r\n-60,76,1,0\r\n-61,77,1,0\r\n-62,78,1,0\r\n-63,79,1,0\r\n-64,76,1,0\r\n-65,77,1,0\r\n-66,78,1,0\r\n-67,79,1,0\r\n-68,76,1,0\r\n-69,77,1,0\r\n-70,78,1,0\r\n-71,79,1,0\r\n-72,76,1,0\r\n-73,77,1,0\r\n-74,78,1,0\r\n-75,79,1,0\r\n-76,80,0,0\r\n-76,81,0,0\r\n-76,82,0,0\r\n-76,83,0,0\r\n-76,60,0,1\r\n-76,64,0,1\r\n-76,68,0,1\r\n-76,72,0,1\r\n-77,80,0,0\r\n-77,81,0,0\r\n-77,82,0,0\r\n-77,83,0,0\r\n-77,61,0,1\r\n-77,65,0,1\r\n-77,69,0,1\r\n-77,73,0,1\r\n-78,80,0,0\r\n-78,81,0,0\r\n-78,82,0,0\r\n-78,83,0,0\r\n-78,62,0,1\r\n-78,66,0,1\r\n-78,70,0,1\r\n-78,74,0,1\r\n-79,80,0,0\r\n-79,81,0,0\r\n-79,82,0,0\r\n-79,83,0,0\r\n-79,63,0,1\r\n-79,67,0,1\r\n-79,71,0,1\r\n-79,75,0,1\r\n-80,111,0,0\r\n-80,139,0,0\r\n-80,27,0,0\r\n-80,55,0,0\r\n-80,76,0,0\r\n-80,77,0,0\r\n-80,78,0,0\r\n-80,79,0,0\r\n-81,110,0,0\r\n-81,138,0,0\r\n-81,26,0,0\r\n-81,54,0,0\r\n-81,76,0,0\r\n-81,77,0,0\r\n-81,78,0,0\r\n-81,79,0,0\r\n-82,109,0,0\r\n-82,137,0,0\r\n-82,25,0,0\r\n-82,53,0,0\r\n-82,76,0,0\r\n-82,77,0,0\r\n-82,78,0,0\r\n-82,79,0,0\r\n-83,108,0,0\r\n-83,136,0,0\r\n-83,24,0,0\r\n-83,52,0,0\r\n-83,76,0,0\r\n-83,77,0,0\r\n-83,78,0,0\r\n-83,79,0,0\r\n-88,104,1,0\r\n-89,105,1,0\r\n-90,106,1,0\r\n-91,107,1,0\r\n-92,104,1,0\r\n-93,105,1,0\r\n-94,106,1,0\r\n-95,107,1,0\r\n-96,104,1,0\r\n-97,105,1,0\r\n-98,106,1,0\r\n-99,107,1,0\r\n-100,104,1,0\r\n-101,105,1,0\r\n-102,106,1,0\r\n-103,107,1,0\r\n-104,108,0,0\r\n-104,109,0,0\r\n-104,110,0,0\r\n-104,111,0,0\r\n-104,88,0,1\r\n-104,92,0,1\r\n-104,96,0,1\r\n-104,100,0,1\r\n-105,108,0,0\r\n-105,109,0,0\r\n-105,110,0,0\r\n-105,111,0,0\r\n-105,89,0,1\r\n-105,93,0,1\r\n-105,97,0,1\r\n-105,101,0,1\r\n-106,108,0,0\r\n-106,109,0,0\r\n-106,110,0,0\r\n-106,111,0,0\r\n-106,90,0,1\r\n-106,94,0,1\r\n-106,98,0,1\r\n-106,102,0,1\r\n-107,108,0,0\r\n-107,109,0,0\r\n-107,110,0,0\r\n-107,111,0,0\r\n-107,91,0,1\r\n-107,95,0,1\r\n-107,99,0,1\r\n-107,103,0,1\r\n-108,139,0,0\r\n-108,27,0,0\r\n-108,55,0,0\r\n-108,83,0,0\r\n-108,104,0,0\r\n-108,105,0,0\r\n-108,106,0,0\r\n-108,107,0,0\r\n-109,138,0,0\r\n-109,26,0,0\r\n-109,54,0,0\r\n-109,82,0,0\r\n-109,104,0,0\r\n-109,105,0,0\r\n-109,106,0,0\r\n-109,107,0,0\r\n-110,137,0,0\r\n-110,25,0,0\r\n-110,53,0,0\r\n-110,81,0,0\r\n-110,104,0,0\r\n-110,105,0,0\r\n-110,106,0,0\r\n-110,107,0,0\r\n-111,136,0,0\r\n-111,24,0,0\r\n-111,52,0,0\r\n-111,80,0,0\r\n-111,104,0,0\r\n-111,105,0,0\r\n-111,106,0,0\r\n-111,107,0,0\r\n-116,132,1,0\r\n-117,133,1,0\r\n-118,134,1,0\r\n-119,135,1,0\r\n-120,132,1,0\r\n-121,133,1,0\r\n-122,134,1,0\r\n-123,135,1,0\r\n-124,132,1,0\r\n-125,133,1,0\r\n-126,134,1,0\r\n-127,135,1,0\r\n-128,132,1,0\r\n-129,133,1,0\r\n-130,134,1,0\r\n-131,135,1,0\r\n-132,136,0,0\r\n-132,137,0,0\r\n-132,138,0,0\r\n-132,139,0,0\r\n-132,116,0,1\r\n-132,120,0,1\r\n-132,124,0,1\r\n-132,128,0,1\r\n-133,136,0,0\r\n-133,137,0,0\r\n-133,138,0,0\r\n-133,139,0,0\r\n-133,117,0,1\r\n-133,121,0,1\r\n-133,125,0,1\r\n-133,129,0,1\r\n-134,136,0,0\r\n-134,137,0,0\r\n-134,138,0,0\r\n-134,139,0,0\r\n-134,118,0,1\r\n-134,122,0,1\r\n-134,126,0,1\r\n-134,130,0,1\r\n-135,136,0,0\r\n-135,137,0,0\r\n-135,138,0,0\r\n-135,139,0,0\r\n-135,119,0,1\r\n-135,123,0,1\r\n-135,127,0,1\r\n-135,131,0,1\r\n-136,27,0,0\r\n-136,55,0,0\r\n-136,83,0,0\r\n-136,111,0,0\r\n-136,132,0,0\r\n-136,133,0,0\r\n-136,134,0,0\r\n-136,135,0,0\r\n-137,26,0,0\r\n-137,54,0,0\r\n-137,82,0,0\r\n-137,110,0,0\r\n-137,132,0,0\r\n-137,133,0,0\r\n-137,134,0,0\r\n-137,135,0,0\r\n-138,25,0,0\r\n-138,53,0,0\r\n-138,81,0,0\r\n-138,109,0,0\r\n-138,132,0,0\r\n-138,133,0,0\r\n-138,134,0,0\r\n-138,135,0,0\r\n-139,24,0,0\r\n-139,52,0,0\r\n-139,80,0,0\r\n-139,108,0,0\r\n-139,132,0,0\r\n-139,133,0,0\r\n-139,134,0,0\r\n-139,135,0,0\r\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 8,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/neil-inter",
                        "old_path": "scripts/neil-inter",
                        "binary": false,
                        "utf8_diff": "Binary files a/scripts/neil-inter and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 9,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/neil-inter-large",
                        "old_path": "scripts/neil-inter-large",
                        "binary": false,
                        "utf8_diff": "Binary files a/scripts/neil-inter-large and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 10,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/neil-intra",
                        "old_path": "scripts/neil-intra",
                        "binary": false,
                        "utf8_diff": "Binary files a/scripts/neil-intra and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 11,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "scripts/neil-intra-large",
                        "old_path": "scripts/neil-intra-large",
                        "binary": false,
                        "utf8_diff": "Binary files a/scripts/neil-intra-large and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 12,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/Makefile.subdir",
                        "old_path": "src/Makefile.subdir",
                        "binary": false,
                        "utf8_diff": "--- a/src/Makefile.subdir\n+++ b/src/Makefile.subdir\n@@ -18,7 +18,7 @@ EXTRA_DIST += src/iokernellang/codesparser.y.in \\\n \t\t\t  src/workload/README.codes-workload \\\n \t\t\t  src/network-workloads/README_synthetic.txt \\\n \t\t\t  src/network-workloads/README_traces.txt \\\n-\t\t\t  src/network-workloads/workloads.conf \\\n+\t\t\t  src/network-workloads/conf/workloads.conf \\\n \t\t\t  src/network-workloads/README_synthetic_slimfly.txt \\\n \t\t\t  src/network-workloads/conf/modelnet-mpi-test.conf \\\n \t\t\t  src/network-workloads/conf/modelnet-mpi-test-cry-router.conf \\\n@@ -91,8 +91,10 @@ nobase_include_HEADERS = \\\n \tcodes/model-net-lp.h \\\n \tcodes/model-net-sched.h \\\n \tcodes/model-net-inspect.h \\\n+\tcodes/connection-manager.h\t\\\n \tcodes/net/common-net.h \\\n \tcodes/net/dragonfly.h \\\n+\tcodes/net/dragonfly-plus.h\t\\\n \tcodes/net/dragonfly-custom.h \\\n \tcodes/net/slimfly.h \\\n \tcodes/net/fattree.h \\\n@@ -101,7 +103,7 @@ nobase_include_HEADERS = \\\n \tcodes/net/simplep2p.h \\\n \tcodes/net/express-mesh.h \\\n \tcodes/net/torus.h \\\n-  codes/codes-mpi-replay.h \\\n+    codes/codes-mpi-replay.h \\\n \tcodes/configfile.h\n \n \n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 13,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k.conf",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-custom/dfdally_8k.conf\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-LPGROUPS\n-{\n-   MODELNET_GRP\n-   {\n-      repetitions=\"1040\";\n-# name of this lp changes according to the model\n-      nw-lp=\"8\";\n-# these lp names will be the same for dragonfly-custom model\n-      modelnet_dragonfly_custom=\"8\";\n-      modelnet_dragonfly_custom_router=\"1\";\n-   }\n-}\n-PARAMS\n-{\n-   adaptive_threshold=\"8192\";\n-#  minimal-bias=\"1\";\n-   df-dally-vc = \"1\";\n-# packet size in the network\n-   packet_size=\"4096\";\n-   modelnet_order=( \"dragonfly_custom\",\"dragonfly_custom_router\" );\n-   # scheduler options\n-   modelnet_scheduler=\"fcfs\";\n-# chunk size in the network (when chunk size = packet size, packets will not be\n-# divided into chunks)\n-   chunk_size=\"4096\";\n-   # modelnet_scheduler=\"round-robin\";\n-\n-   num_router_rows=\"1\";\n-   # intra-group columns for routers\n-   num_router_cols=\"16\";\n-   # number of groups in the network\n-   num_groups=\"65\";\n-# buffer size in bytes for local virtual channels\n-   local_vc_size=\"32768\";\n-#buffer size in bytes for global virtual channels\n-   global_vc_size=\"32768\";\n-#buffer size in bytes for compute node virtual channels\n-   cn_vc_size=\"32768\";\n-#bandwidth in GiB/s for local channels\n-   local_bandwidth=\"25.0\";\n-# bandwidth in GiB/s for global channels\n-   global_bandwidth=\"25.0\";\n-# bandwidth in GiB/s for compute node-router channels\n-   cn_bandwidth=\"25.0\";\n-# Number of row channels\n-   num_row_chans=\"1\";\n-# Number of column channels\n-   num_col_chans=\"1\";\n-# ROSS message size\n-   message_size=\"640\";\n-# number of compute nodes connected to router, dictated by dragonfly config\n-# file\n-   num_cns_per_router=\"8\";\n-# number of global channels per router\n-   num_global_channels=\"8\";\n-# network config file for intra-group connections\n-   intra-group-connections=\"/home/mubarak/codes-online/codes/src/network-workloads/conf/dragonfly-custom/dfdally_8k_intra\";\n-# network config file for inter-group connections\n-   inter-group-connections=\"/home/mubarak/codes-online/codes/src/network-workloads/conf/dragonfly-custom/dfdally_8k_inter\";\n-# routing protocol to be used\n-   routing=\"prog-adaptive\";\n-}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 14,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k_inter",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k_inter",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-custom/dfdally_8k_inter and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 15,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k_intra",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfdally_8k_intra",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-custom/dfdally_8k_intra and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 16,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k.conf",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-custom/dfp_8k.conf\n+++ /dev/null\n@@ -1,61 +0,0 @@\n-LPGROUPS\n-{\n-   MODELNET_GRP\n-   {\n-      repetitions=\"1056\";\n-# name of this lp changes according to the model\n-      nw-lp=\"8\";\n-# these lp names will be the same for dragonfly-custom model\n-      modelnet_dragonfly_plus=\"8\";\n-      modelnet_dragonfly_plus_router=\"1\";\n-   }\n-}\n-PARAMS\n-{\n-# packet size in the network\n-   packet_size=\"4096\";\n-   modelnet_order=( \"dragonfly_plus\",\"dragonfly_plus_router\" );\n-   # scheduler options\n-   modelnet_scheduler=\"fcfs\";\n-# chunk size in the network (when chunk size = packet size, packets will not be\n-# divided into chunks)\n-   chunk_size=\"4096\";\n-   # modelnet_scheduler=\"round-robin\";\n-   # number of routers within each group\n-   # each router row corresponds to a chassis in Cray systems\n-   num_router_spine=\"16\";\n-   # each router column corresponds to a slot in a chassis\n-   num_router_leaf=\"16\";\n-   # number of links connecting between group levels per router\n-   num_level_chans=\"1\";\n-   # number of groups in the network\n-   num_groups=\"33\";\n-# buffer size in bytes for local virtual channels\n-   local_vc_size=\"32768\";\n-#buffer size in bytes for global virtual channels\n-   global_vc_size=\"32768\";\n-#buffer size in bytes for compute node virtual channels\n-   cn_vc_size=\"32768\";\n-#bandwidth in GiB/s for local channels\n-   local_bandwidth=\"25.0\";\n-# bandwidth in GiB/s for global channels\n-   global_bandwidth=\"25.0\";\n-# bandwidth in GiB/s for compute node-router channels\n-   cn_bandwidth=\"25.0\";\n-# ROSS message size\n-   message_size=\"624\";\n-# number of compute nodes connected to router, dictated by dragonfly config\n-# file\n-   num_cns_per_router=\"16\";\n-# number of global channels per router\n-   num_global_connections=\"16\";\n-# network config file for intra-group connections\n-   intra-group-connections=\"/home/mmubarak/codes-online/codes/src/network-workloads/conf/dragonfly-custom/dfp_8k_intra\";\n-# network config file for inter-group connections\n-   inter-group-connections=\"/home/mmubarak/codes-online/codes/src/network-workloads/conf/dragonfly-custom/dfp_8k_inter\";\n-# routing protocol to be used\n-   routing=\"prog-adaptive\";\n-# route scoring protocol to be used - options are 'alpha' or 'beta'\n-   route_scoring_metric=\"alpha\";\n-\n-}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 17,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k_inter",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k_inter",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-custom/dfp_8k_inter and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 18,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k_intra",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/dfp_8k_intra",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-custom/dfp_8k_intra and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 19,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/conf/dragonfly-custom/modelnet-test-dragonfly-1728-nodes.conf.in",
                        "old_path": "src/network-workloads/conf/dragonfly-custom/modelnet-test-dragonfly-1728-nodes.conf.in",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-custom/modelnet-test-dragonfly-1728-nodes.conf.in\n+++ b/src/network-workloads/conf/dragonfly-custom/modelnet-test-dragonfly-1728-nodes.conf.in\n@@ -41,7 +41,7 @@ PARAMS\n # bandwidth in GiB/s for compute node-router channels \n    cn_bandwidth=\"16.0\";\n # ROSS message size \n-   message_size=\"608\";\n+   message_size=\"640\";\n # number of compute nodes connected to router, dictated by dragonfly config\n # file\n    num_cns_per_router=\"2\";\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 20,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/34kminimal.txt",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/34kminimal.txt",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-plus/34kminimal.txt\n+++ /dev/null\n@@ -1,74 +0,0 @@\n-\t: Running Time = 22.1632 seconds\n-\n-TW Library Statistics:\n-\tTotal Events Processed                                27882763\n-\tEvents Aborted (part of RBs)                                 0\n-\tEvents Rolled Back                                     1623745\n-\tEvent Ties Detected in PE Queues                             0\n-\tEfficiency                                               93.82 %\n-\tTotal Remote (shared mem) Events Processed                   0\n-\tPercent Remote Events                                     0.00 %\n-\tTotal Remote (network) Events Processed                2239846\n-\tPercent Remote Events                                     8.53 %\n-\n-\tTotal Roll Backs                                        213747\n-\tPrimary Roll Backs                                      206428\n-\tSecondary Roll Backs                                      7319\n-\tFossil Collect Attempts                                 108948\n-\tTotal GVT Computations                                   27237\n-\n-\tNet Events Processed                                  26259018\n-\tEvent Rate (events/sec)                              1184800.8\n-\tTotal Events Scheduled Past End Time                         0\n-\n-TW Memory Statistics:\n-\tEvents Allocated                                       4510545\n-\tMemory Allocated                                       3342712\n-\tMemory Wasted                                              222\n-\n-TW Network Statistics:\n-\tRemote sends                                           2517896\n-\tRemote recvs                                           2517896\n-\n-TW Data Structure sizes in bytes (sizeof):\n-\tPE struct                                                  624\n-\tKP struct                                                  144\n-\tLP struct                                                  128\n-\tLP Model struct                                             32\n-\tLP RNGs                                                     80\n-\tTotal LP                                                   240\n-\tEvent struct                                               144\n-\tEvent struct with Model                                    752\n-\n-TW Clock Cycle Statistics (MAX values in secs at 1.0000 GHz):\n-\tPriority Queue (enq/deq)                                1.2060\n-\tAVL Tree (insert/delete)                                6.1629\n-\tLZ4 (de)compression                                     0.0000\n-\tBuddy system                                            0.0000\n-\tRIO Loading                                             0.0000\n-\tRIO LP Init                                             0.1464\n-\tEvent Processing                                       64.3321\n-\tEvent Cancel                                            0.0668\n-\tEvent Abort                                             0.0000\n-\n-\tGVT                                                     8.9914\n-\tFossil Collect                                          4.3308\n-\tPrimary Rollbacks                                       1.8111\n-\tNetwork Read                                           10.4349\n-\tStatistics Computation                                  0.0000\n-\tStatistics Write                                        0.0000\n-\tTotal Time (Note: Using Running Time above for Speedup)     88.8275\n-\n-TW GVT Statistics: MPI AllReduce\n-\tGVT Interval                                                16\n-\tGVT Real Time Interval (cycles)                    0\n-\tGVT Real Time Interval (sec)                        0.00000000\n-\tBatch Size                                                  16\n-\n-\tForced GVT                                                   0\n-\tTotal GVT Computations                                   27237\n-\tTotal All Reduce Calls                                   80374\n-\tAverage Reduction / GVT                                   2.95\n- Average number of router hops traversed: 3.967510; average chunk latency: 3.983703 us; maximum chunk latency: 23.508762 us; avg message size: 2048.000000 bytes; finished messages: 675818; finished chunks: 1351636 \n-\n- Total packets generated: 1351636; finished: 1351636 \n\\ No newline at end of file\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 21,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/34kotfa.txt",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/34kotfa.txt",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-plus/34kotfa.txt\n+++ /dev/null\n@@ -1,78 +0,0 @@\n-\t: Running Time = 32.7864 seconds\n-\n-TW Library Statistics:\n-\tTotal Events Processed                                33923697\n-\tEvents Aborted (part of RBs)                                 0\n-\tEvents Rolled Back                                     2115066\n-\tEvent Ties Detected in PE Queues                             0\n-\tEfficiency                                               93.35 %\n-\tTotal Remote (shared mem) Events Processed                   0\n-\tPercent Remote Events                                     0.00 %\n-\tTotal Remote (network) Events Processed                3197222\n-\tPercent Remote Events                                    10.05 %\n-\n-\tTotal Roll Backs                                        298872\n-\tPrimary Roll Backs                                      293249\n-\tSecondary Roll Backs                                      5623\n-\tFossil Collect Attempts                                 132536\n-\tTotal GVT Computations                                   33134\n-\n-\tNet Events Processed                                  31808631\n-\tEvent Rate (events/sec)                               970177.4\n-\tTotal Events Scheduled Past End Time                         0\n-\n-TW Memory Statistics:\n-\tEvents Allocated                                       4510545\n-\tMemory Allocated                                       3342712\n-\tMemory Wasted                                              222\n-\n-TW Network Statistics:\n-\tRemote sends                                           3630262\n-\tRemote recvs                                           3630262\n-\n-TW Data Structure sizes in bytes (sizeof):\n-\tPE struct                                                  624\n-\tKP struct                                                  144\n-\tLP struct                                                  128\n-\tLP Model struct                                             32\n-\tLP RNGs                                                     80\n-\tTotal LP                                                   240\n-\tEvent struct                                               144\n-\tEvent struct with Model                                    752\n-\n-TW Clock Cycle Statistics (MAX values in secs at 1.0000 GHz):\n-\tPriority Queue (enq/deq)                                1.6238\n-\tAVL Tree (insert/delete)                                9.6388\n-\tLZ4 (de)compression                                     0.0000\n-\tBuddy system                                            0.0000\n-\tRIO Loading                                             0.0000\n-\tRIO LP Init                                             0.1587\n-\tEvent Processing                                       96.7147\n-\tEvent Cancel                                            0.0741\n-\tEvent Abort                                             0.0000\n-\n-\tGVT                                                    12.5980\n-\tFossil Collect                                          5.9422\n-\tPrimary Rollbacks                                       2.6389\n-\tNetwork Read                                           15.3961\n-\tStatistics Computation                                  0.0000\n-\tStatistics Write                                        0.0000\n-\tTotal Time (Note: Using Running Time above for Speedup)    131.4039\n-\n-TW GVT Statistics: MPI AllReduce\n-\tGVT Interval                                                16\n-\tGVT Real Time Interval (cycles)                    0\n-\tGVT Real Time Interval (sec)                        0.00000000\n-\tBatch Size                                                  16\n-\n-\tForced GVT                                                   0\n-\tTotal GVT Computations                                   33134\n-\tTotal All Reduce Calls                                   98239\n-\tAverage Reduction / GVT                                   2.96\n- Average number of router hops traversed: 5.336127; average chunk latency: 8.764690 us; maximum chunk latency: 28.623821 us; avg message size: 2048.000000 bytes; finished messages: 675818; finished chunks: 1351636 \n-\n- Total packets generated: 1351636; finished: 1351636 \n-\n-\n-\n-\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 22,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-med-34k.conf",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-med-34k.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-med-34k.conf\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-LPGROUPS\n-{\n-   MODELNET_GRP\n-   {\n-      repetitions=\"33\";\n-# name of this lp changes according to the model\n-      nw-lp=\"1024\";\n-# these lp names will be the same for dragonfly-custom model\n-      modelnet_dragonfly_plus=\"1024\";\n-      modelnet_dragonfly_plus_router=\"64\";\n-   }\n-}\n-PARAMS\n-{\n-# packet size in the network\n-   packet_size=\"1024\";\n-   modelnet_order=( \"dragonfly_plus\",\"dragonfly_plus_router\" );\n-   # scheduler options\n-   modelnet_scheduler=\"fcfs\";\n-# chunk size in the network (when chunk size = packet size, packets will not be\n-# divided into chunks)\n-   chunk_size=\"1024\";\n-   # modelnet_scheduler=\"round-robin\";\n-   # number of routers within each group\n-   # each router row corresponds to a chassis in Cray systems\n-   num_router_spine=\"32\";\n-   # each router column corresponds to a slot in a chassis\n-   num_router_leaf=\"32\";\n-   # number of links connecting between group levels per router\n-   num_level_chans=\"1\";\n-   # number of groups in the network\n-   num_groups=\"33\";\n-\n-# predefined threshold (T) deciding when to reassign packet to a lower priority queue\n-   queue_threshold=\"50\";\n-\n-# buffer size in bytes for local virtual channels\n-   local_vc_size=\"8192\";\n-#buffer size in bytes for global virtual channels\n-   global_vc_size=\"16384\";\n-#buffer size in bytes for compute node virtual channels\n-   cn_vc_size=\"8192\";\n-#bandwidth in GiB/s for local channels\n-   local_bandwidth=\"5.25\";\n-# bandwidth in GiB/s for global channels\n-   global_bandwidth=\"1.5\";\n-# bandwidth in GiB/s for compute node-router channels\n-   cn_bandwidth=\"8.0\";\n-# ROSS message size\n-   message_size=\"608\";\n-# number of compute nodes connected to router, dictated by dragonfly config\n-# file\n-   num_cns_per_router=\"32\";\n-# number of global ports per router\n-   num_global_connections=\"32\";\n-# network config file for intra-group connections\n-   intra-group-connections=\"../src/network-workloads/conf/dragonfly-plus/neil-34k-intra\";\n-# network config file for inter-group connections\n-   inter-group-connections=\"../src/network-workloads/conf/dragonfly-plus/neil-34k-inter\";\n-# routing protocol to be used\n-   routing=\"on-the-fly-adaptive\";\n-}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 23,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-testing-large.conf",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-testing-large.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/dragonfly-plus/modelnet-test-dragonfly-plus-testing-large.conf\n+++ /dev/null\n@@ -1,62 +0,0 @@\n-LPGROUPS\n-{\n-   MODELNET_GRP\n-   {\n-      repetitions=\"5\";\n-# name of this lp changes according to the model\n-      nw-lp=\"4\";\n-# these lp names will be the same for dragonfly-custom model\n-      modelnet_dragonfly_plus=\"4\";\n-      modelnet_dragonfly_plus_router=\"4\";\n-   }\n-}\n-PARAMS\n-{\n-# packet size in the network\n-   packet_size=\"1024\";\n-   modelnet_order=( \"dragonfly_plus\",\"dragonfly_plus_router\" );\n-   # scheduler options\n-   modelnet_scheduler=\"fcfs\";\n-# chunk size in the network (when chunk size = packet size, packets will not be\n-# divided into chunks)\n-   chunk_size=\"1024\";\n-   # modelnet_scheduler=\"round-robin\";\n-   # number of routers within each group\n-   # each router row corresponds to a chassis in Cray systems\n-   num_router_spine=\"2\";\n-   # each router column corresponds to a slot in a chassis\n-   num_router_leaf=\"2\";\n-   # number of links connecting between group levels per router\n-   num_level_chans=\"1\";\n-   # number of groups in the network\n-   num_groups=\"5\";\n-\n-# predefined threshold (T) deciding when to reassign packet to a lower priority queue\n-   queue_threshold=\"50\";\n-\n-# buffer size in bytes for local virtual channels\n-   local_vc_size=\"8192\";\n-#buffer size in bytes for global virtual channels\n-   global_vc_size=\"16384\";\n-#buffer size in bytes for compute node virtual channels\n-   cn_vc_size=\"8192\";\n-#bandwidth in GiB/s for local channels\n-   local_bandwidth=\"5.25\";\n-# bandwidth in GiB/s for global channels\n-   global_bandwidth=\"1.5\";\n-# bandwidth in GiB/s for compute node-router channels\n-   cn_bandwidth=\"8.0\";\n-# ROSS message size\n-   message_size=\"608\";\n-# number of compute nodes connected to router, dictated by dragonfly config\n-# file\n-   num_cns_per_router=\"2\";\n-# number of global ports per router\n-   num_global_connections=\"2\";\n-# network config file for intra-group connections\n-   intra-group-connections=\"../src/network-workloads/conf/dragonfly-plus/neil-intra-large\";\n-# network config file for inter-group connections\n-   inter-group-connections=\"../src/network-workloads/conf/dragonfly-plus/neil-inter-large\";\n-# routing protocol to be used\n-   routing=\"non-minimal-leaf\";\n-}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 24,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-34k-inter",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-34k-inter",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-34k-inter and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 25,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-34k-intra",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-34k-intra",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-34k-intra and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 26,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-inter",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-inter",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-inter and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 27,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-inter-large",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-inter-large",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-inter-large and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 28,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-intra",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-intra",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-intra and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 29,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/dragonfly-plus/neil-intra-large",
                        "old_path": "src/network-workloads/conf/dragonfly-plus/neil-intra-large",
                        "binary": false,
                        "utf8_diff": "Binary files a/src/network-workloads/conf/dragonfly-plus/neil-intra-large and /dev/null differ\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 30,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100755",
                        "new_path": "src/network-workloads/conf/dual-plane-fattree-tapered.conf",
                        "old_path": "src/network-workloads/conf/dual-plane-fattree-tapered.conf",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/src/network-workloads/conf/dual-plane-fattree-tapered.conf\n@@ -0,0 +1,45 @@\n+LPGROUPS\n+{\n+   MODELNET_GRP\n+   {\n+      repetitions=\"198\";\n+      server=\"384\";\n+      modelnet_fattree=\"24\";\n+      fattree_switch=\"6\";\n+   }\n+}\n+PARAMS\n+{\n+   ft_type=\"0\";\n+   packet_size=\"8192\";\n+   chunk_size=\"8192\";\n+   message_size=\"512\";\n+   modelnet_scheduler=\"fcfs\";\n+   modelnet_order=( \"fattree\" );\n+   num_levels=\"3\";\n+   tapering=\"2\";\n+   num_rails=\"2\";\n+   switch_count=\"198\";\n+   switch_radix=\"36\";\n+   router_delay=\"90\";\n+   soft_delay=\"200\";\n+   nic_delay=\"400\";\n+   nic_seq_delay=\"100\";\n+   num_injection_queues=\"2\";\n+   link_bandwidth=\"11.9\";\n+   cn_bandwidth=\"24\";\n+   vc_size=\"65536\";\n+   cn_vc_size=\"65536\";\n+   node_copy_queues=\"4\";\n+   intra_bandwidth=\"30\";\n+   rdma_delay=\"1000\";\n+   eager_limit=\"64000\";\n+   copy_per_byte=\"0.01\";\n+   node_eager_limit=\"64000\";\n+   rail_select=\"adaptive\";\n+   rail_select_limit=\"8192\";\n+   routing=\"adaptive\";\n+   routing_folder=\"taper_routes\";\n+   dot_file=\"ftree\";\n+   dump_topo=\"0\";\n+}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 31,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100755",
                        "new_path": "src/network-workloads/conf/dual-plane-fattree.conf",
                        "old_path": "src/network-workloads/conf/dual-plane-fattree.conf",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/src/network-workloads/conf/dual-plane-fattree.conf\n@@ -0,0 +1,45 @@\n+LPGROUPS\n+{\n+   MODELNET_GRP\n+   {\n+      repetitions=\"252\";\n+      server=\"288\";\n+      modelnet_fattree=\"18\";\n+      fattree_switch=\"6\";\n+   }\n+}\n+PARAMS\n+{\n+   ft_type=\"0\";\n+   packet_size=\"8192\";\n+   chunk_size=\"8192\";\n+   message_size=\"512\";\n+   modelnet_scheduler=\"fcfs\";\n+   modelnet_order=( \"fattree\" );\n+   num_levels=\"3\";\n+   tapering=\"1\";\n+   num_rails=\"2\";\n+   switch_count=\"252\";\n+   switch_radix=\"36\";\n+   router_delay=\"90\";\n+   soft_delay=\"200\";\n+   nic_delay=\"400\";\n+   nic_seq_delay=\"100\";\n+   num_injection_queues=\"2\";\n+   link_bandwidth=\"11.9\";\n+   cn_bandwidth=\"24\";\n+   vc_size=\"65536\";\n+   cn_vc_size=\"65536\";\n+   node_copy_queues=\"4\";\n+   intra_bandwidth=\"30\";\n+   rdma_delay=\"1000\";\n+   eager_limit=\"64000\";\n+   copy_per_byte=\"0.01\";\n+   node_eager_limit=\"64000\";\n+   rail_select=\"adaptive\";\n+   rail_select_limit=\"8192\";\n+   routing=\"adaptive\";\n+   routing_folder=\"full_routes\";\n+   dot_file=\"ftree\";\n+   dump_topo=\"0\";\n+}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 32,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/conf/modelnet-mpi-test-dfly-amg-1728.conf",
                        "old_path": "src/network-workloads/conf/modelnet-mpi-test-dfly-amg-1728.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/modelnet-mpi-test-dfly-amg-1728.conf\n+++ b/src/network-workloads/conf/modelnet-mpi-test-dfly-amg-1728.conf\n@@ -23,6 +23,6 @@ PARAMS\n    local_bandwidth=\"5.25\";\n    global_bandwidth=\"4.7\";\n    cn_bandwidth=\"5.25\";\n-   message_size=\"592\";\n+   message_size=\"608\";\n    routing=\"adaptive\";\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 33,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/conf/modelnet-mpi-test-dfly-amg-216.conf",
                        "old_path": "src/network-workloads/conf/modelnet-mpi-test-dfly-amg-216.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/modelnet-mpi-test-dfly-amg-216.conf\n+++ b/src/network-workloads/conf/modelnet-mpi-test-dfly-amg-216.conf\n@@ -23,6 +23,6 @@ PARAMS\n    local_bandwidth=\"5.25\";\n    global_bandwidth=\"4.7\";\n    cn_bandwidth=\"5.25\";\n-   message_size=\"624\";\n+   message_size=\"640\";\n    routing=\"adaptive\";\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 34,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/conf/modelnet-mpi-test-slimfly-min.conf",
                        "old_path": "src/network-workloads/conf/modelnet-mpi-test-slimfly-min.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/modelnet-mpi-test-slimfly-min.conf\n+++ b/src/network-workloads/conf/modelnet-mpi-test-slimfly-min.conf\n@@ -31,6 +31,6 @@ PARAMS\n    cn_bandwidth=\"9.0\";\n    router_delay=\"0\";\n    link_delay=\"0\";\n-   message_size=\"608\";\n+   message_size=\"640\";\n    routing=\"minimal\";\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 35,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/conf/modelnet-mpi-test-torus.conf",
                        "old_path": "src/network-workloads/conf/modelnet-mpi-test-torus.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/modelnet-mpi-test-torus.conf\n+++ b/src/network-workloads/conf/modelnet-mpi-test-torus.conf\n@@ -10,7 +10,7 @@ LPGROUPS\n PARAMS\n {\n    packet_size=\"512\";\n-   message_size=\"608\";\n+   message_size=\"640\";\n    modelnet_order=( \"torus\" );\n    # scheduler options\n    modelnet_scheduler=\"fcfs\";\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 36,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": true,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "0",
                        "new_path": "src/network-workloads/conf/tracer-fattree-type2.conf",
                        "old_path": "src/network-workloads/conf/tracer-fattree-type2.conf",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/conf/tracer-fattree-type2.conf\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-LPGROUPS\n-{\n-   MODELNET_GRP\n-   {\n-      repetitions=\"16\";\n-      server=\"4\";\n-      modelnet_fattree=\"4\";\n-      fattree_switch=\"3\";\n-   }\n-}\n-PARAMS\n-{\n-   ft_type=\"1\";\n-   packet_size=\"512\";\n-   message_size=\"512\";\n-   chunk_size=\"32\";\n-   modelnet_scheduler=\"fcfs\";\n-   #modelnet_scheduler=\"round-robin\";\n-   modelnet_order=( \"fattree\" );\n-   num_levels=\"3\";\n-   switch_count=\"16\";\n-   switch_radix=\"8\";\n-   router_delay=\"60\";\n-   soft_delay=\"1000\";\n-   vc_size=\"65536\";\n-   cn_vc_size=\"65536\";\n-   link_bandwidth=\"4.7\";\n-   cn_bandwidth=\"5.25\";\n-}\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 37,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-dumpi-traces-dump.c",
                        "old_path": "src/network-workloads/model-net-dumpi-traces-dump.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-dumpi-traces-dump.c\n+++ b/src/network-workloads/model-net-dumpi-traces-dump.c\n@@ -414,6 +414,11 @@ int main( int argc, char** argv )\n   workload_type[0]='\\0';\n   tw_opt_add(app_opt);\n   tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+  codes_comm_update();\n \n   if(strlen(workload_file) == 0)\n     {\n@@ -423,10 +428,10 @@ int main( int argc, char** argv )\n \treturn -1;\n     }\n \n-    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n-    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n+    MPI_Comm_rank(MPI_COMM_CODES, &rank);\n+    MPI_Comm_size(MPI_COMM_CODES, &nprocs);\n \n-   configuration_load(argv[2], MPI_COMM_WORLD, &config);\n+   configuration_load(argv[2], MPI_COMM_CODES, &config);\n \n    nw_add_lp_type();\n \n@@ -446,20 +451,20 @@ int main( int argc, char** argv )\n     double total_avg_comp_time;\n     long overall_sends, overall_recvs, overall_waits, overall_cols;\n \t\n-    MPI_Reduce(&num_bytes_sent, &total_bytes_sent, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce(&num_bytes_recvd, &total_bytes_recvd, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&avg_time, &avg_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-\n-   MPI_Reduce(&avg_recv_time, &total_avg_recv_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&avg_comm_time, &avg_comm_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&avg_col_time, &avg_col_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-  MPI_Reduce(&avg_wait_time, &total_avg_wait_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&avg_send_time, &total_avg_send_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&avg_compute_time, &total_avg_comp_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&total_sends, &overall_sends, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&total_recvs, &overall_recvs, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&total_waits, &overall_waits, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-   MPI_Reduce(&total_collectives, &overall_cols, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n+    MPI_Reduce(&num_bytes_sent, &total_bytes_sent, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce(&num_bytes_recvd, &total_bytes_recvd, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&avg_time, &avg_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+\n+   MPI_Reduce(&avg_recv_time, &total_avg_recv_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&avg_comm_time, &avg_comm_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&avg_col_time, &avg_col_run_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+  MPI_Reduce(&avg_wait_time, &total_avg_wait_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&avg_send_time, &total_avg_send_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&avg_compute_time, &total_avg_comp_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&total_sends, &overall_sends, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&total_recvs, &overall_recvs, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&total_waits, &overall_waits, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+   MPI_Reduce(&total_collectives, &overall_cols, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n \n    if(!g_tw_mynode)\n \tprintf(\"\\n Total bytes sent %lld recvd %lld \\n avg runtime %lf \\n avg comm time %lf avg compute time %lf \\n avg send time %lf \\n avg recv time %lf \\n avg wait time %lf \\n total sends %ld total recvs %ld total waits %ld total collectives %ld \", total_bytes_sent, total_bytes_recvd, \n@@ -470,6 +475,9 @@ int main( int argc, char** argv )\n \t\t\ttotal_avg_recv_time/num_net_lps,\n \t\t\ttotal_avg_wait_time/num_net_lps,\n \t\t\toverall_sends, overall_recvs, overall_waits, overall_cols);\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n    tw_end();\n   \n   return 0;\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 38,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-mpi-replay.c",
                        "old_path": "src/network-workloads/model-net-mpi-replay.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-mpi-replay.c\n+++ b/src/network-workloads/model-net-mpi-replay.c\n@@ -352,7 +352,7 @@ static void codes_exec_mpi_recv_rc(\n         nw_state* s, tw_bf * bf, nw_message* m, tw_lp* lp);\n /* execute the computational delay */\n static void codes_exec_comp_delay(\n-        nw_state* s, nw_message * m, tw_lp* lp, struct codes_workload_op * mpi_op);\n+        nw_state* s, tw_bf *bf, nw_message * m, tw_lp* lp, struct codes_workload_op * mpi_op);\n /* gets the next MPI operation from the network-workloads API. */\n static void get_next_mpi_operation(\n         nw_state* s, tw_bf * bf, nw_message * m, tw_lp * lp);\n@@ -1296,7 +1296,7 @@ static int rm_matching_send(nw_state * ns,\n         \n         if(qitem->op_type == CODES_WK_IRECV && !is_rend)\n         {\n-            bf->c9 = 1;\n+            bf->c29 = 1;\n             update_completed_queue(ns, bf, m, lp, qitem->req_id);\n         }\n         else\n@@ -1338,8 +1338,9 @@ static void codes_issue_next_event(tw_lp* lp)\n \n /* Simulate delays between MPI operations */\n static void codes_exec_comp_delay(\n-        nw_state* s, nw_message * m, tw_lp* lp, struct codes_workload_op * mpi_op)\n+        nw_state* s, tw_bf *bf, nw_message * m, tw_lp* lp, struct codes_workload_op * mpi_op)\n {\n+    bf->c28 = 0;\n \ttw_event* e;\n \ttw_stime ts;\n \tnw_message* msg;\n@@ -1348,7 +1349,10 @@ static void codes_exec_comp_delay(\n     s->compute_time += mpi_op->u.delay.nsecs;\n     ts = mpi_op->u.delay.nsecs;\n     if(ts <= g_tw_lookahead)\n+    {\n+        bf->c28 = 1;\n         ts = g_tw_lookahead + 0.1 + tw_rand_exponential(lp->rng, noise);\n+    }\n \n \t//ts += g_tw_lookahead + 0.1 + tw_rand_exponential(lp->rng, noise);\n     assert(ts > 0);\n@@ -1372,6 +1376,8 @@ static void codes_exec_mpi_recv_rc(\n     if(bf->c11)\n         codes_issue_next_event_rc(lp);\n \n+    if(bf->c6)\n+        codes_issue_next_event_rc(lp);\n \tif(m->fwd.found_match >= 0)\n \t  {\n \t\tns->recv_time = m->rc.saved_recv_time;\n@@ -1399,12 +1405,10 @@ static void codes_exec_mpi_recv_rc(\n                index++;\n             }\n         }\n-        if(bf->c9)\n+        if(bf->c29)\n         {\n             update_completed_queue_rc(ns, bf, m, lp);\n         }\n-        if(bf->c6)\n-            codes_issue_next_event_rc(lp);\n       }\n \telse if(m->fwd.found_match < 0)\n \t    {\n@@ -1492,7 +1496,12 @@ static void codes_exec_mpi_send_rc(nw_state * s, tw_bf * bf, nw_message * m, tw_\n         if(bf->c15 || bf->c16)\n             s->num_sends--;\n \n-        model_net_event_rc2(lp, &m->event_rc);\n+        if (bf->c15)\n+            model_net_event_rc2(lp, &m->event_rc);\n+        if (bf->c16)\n+            model_net_event_rc2(lp, &m->event_rc);\n+        if (bf->c17)\n+            model_net_event_rc2(lp, &m->event_rc);\n \n         if(bf->c4)\n             codes_issue_next_event_rc(lp);\n@@ -1606,6 +1615,7 @@ static void codes_exec_mpi_send(nw_state* s,\n     }\n     else if(is_rend == 1)\n     {\n+        bf->c17 = 1;\n         /* initiate the actual data transfer, local completion message is sent\n          * for any blocking sends. */\n        local_m.fwd.sim_start_time = mpi_op->sim_start_time;\n@@ -1656,14 +1666,14 @@ static tw_stime ns_to_s(tw_stime ns)\n static void update_completed_queue_rc(nw_state * s, tw_bf * bf, nw_message * m, tw_lp * lp)\n {\n \n-    if(bf->c0)\n+    if(bf->c30)\n     {\n        struct qlist_head * ent = qlist_pop(&s->completed_reqs);\n \n         completed_requests * req = qlist_entry(ent, completed_requests, ql);\n        free(req);\n     }\n-    else if(bf->c1)\n+    else if(bf->c31)\n     {\n        struct pending_waits* wait_elem = (struct pending_waits*)rc_stack_pop(s->processed_wait_op);\n        s->wait_op = wait_elem;\n@@ -1681,8 +1691,8 @@ static void update_completed_queue(nw_state* s,\n         tw_lp * lp,\n         dumpi_req_id req_id)\n {\n-    bf->c0 = 0;\n-    bf->c1 = 0;\n+    bf->c30 = 0;\n+    bf->c31 = 0;\n     m->fwd.num_matched = 0;\n \n     int waiting = 0;\n@@ -1690,7 +1700,7 @@ static void update_completed_queue(nw_state* s,\n \n     if(!waiting)\n     {\n-        bf->c0 = 1;\n+        bf->c30 = 1;\n         completed_requests * req = (completed_requests*)malloc(sizeof(completed_requests));\n         req->req_id = req_id;\n         qlist_add(&req->ql, &s->completed_reqs);\n@@ -1703,7 +1713,7 @@ static void update_completed_queue(nw_state* s,\n     }\n     else\n      {\n-            bf->c1 = 1;\n+            bf->c31 = 1;\n             m->fwd.num_matched = clear_completed_reqs(s, lp, s->wait_op->req_ids, s->wait_op->count);\n     \n             m->rc.saved_wait_time = s->wait_time;\n@@ -1793,8 +1803,8 @@ static void update_arrival_queue_rc(nw_state* s,\n         if(bf->c12)\n \t        s->recv_time = m->rc.saved_recv_time;\n         \n-        if(bf->c10)\n-            send_ack_back_rc(s, bf, m, lp);\n+        //if(bf->c10)\n+        //    send_ack_back_rc(s, bf, m, lp);\n         if(bf->c9)\n             update_completed_queue_rc(s, bf, m, lp);\n         if(bf->c8)\n@@ -2229,14 +2239,15 @@ static void get_next_mpi_operation_rc(nw_state* s, tw_bf * bf, nw_message * m, t\n                 codes_issue_next_event_rc(lp);\n             else\n             {\n-                tw_rand_reverse_unif(lp->rng);\n+                if (bf->c28)\n+                    tw_rand_reverse_unif(lp->rng);\n                 s->compute_time = m->rc.saved_delay;\n             }\n \t\t}\n \t\tbreak;\n \t\tcase CODES_WK_ALLREDUCE:\n         {\n-            if(bf->c1)\n+            if(bf->c27)\n             {\n                 s->num_all_reduce--;\n                 s->col_time = m->rc.saved_send_time; \n@@ -2350,7 +2361,7 @@ static void get_next_mpi_operation(nw_state* s, tw_bf * bf, nw_message * m, tw_l\n                 if(disable_delay)\n                     codes_issue_next_event(lp);\n                 else\n-\t\t\t\t    codes_exec_comp_delay(s, m, lp, mpi_op);\n+\t\t\t\t    codes_exec_comp_delay(s, bf, m, lp, mpi_op);\n \t\t\t  }\n \t\t\tbreak;\n \n@@ -2384,7 +2395,7 @@ static void get_next_mpi_operation(nw_state* s, tw_bf * bf, nw_message * m, tw_l\n \t\t\t\ts->num_cols++;\n                 if(s->col_time > 0)\n                 {\n-                    bf->c1 = 1;\n+                    bf->c27 = 1;\n                     m->rc.saved_delay = s->all_reduce_time;\n                     s->all_reduce_time += (tw_now(lp) - s->col_time);\n                     m->rc.saved_send_time = s->col_time;\n@@ -2725,6 +2736,11 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n   workload_type[0]='\\0';\n   tw_opt_add(app_opt);\n   tw_init(argc, argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+  codes_comm_update();\n \n   if(strcmp(workload_type, \"dumpi\") != 0 && strcmp(workload_type, \"online\") != 0)\n     {\n@@ -2909,7 +2925,7 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n    MPI_Reduce(&max_recv_time, &total_max_recv_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_CODES);\n    MPI_Reduce(&avg_wait_time, &total_avg_wait_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n    MPI_Reduce(&avg_send_time, &total_avg_send_time, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n-   MPI_Reduce(&total_syn_data, &g_total_syn_data, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);  \n+   MPI_Reduce(&total_syn_data, &g_total_syn_data, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);  \n \n    assert(num_net_traces);\n \n@@ -2943,6 +2959,9 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n    if(alloc_spec)\n        codes_jobmap_destroy(jobmap_ctx);\n \n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n    tw_end();\n \n   return 0;\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 39,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic-custom-dfly.c",
                        "old_path": "src/network-workloads/model-net-synthetic-custom-dfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic-custom-dfly.c\n+++ b/src/network-workloads/model-net-synthetic-custom-dfly.c\n@@ -453,6 +453,11 @@ int main(\n \n     tw_opt_add(app_opt);\n     tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+    codes_comm_update();\n \n     if(argc < 2)\n     {\n@@ -516,6 +521,9 @@ int main(\n         assert(ret == 0 || !\"lp_io_flush failure\");\n     }\n     model_net_report_stats(net_id);\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n     tw_end();\n     return 0;\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 40,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic-dfly-plus.c",
                        "old_path": "src/network-workloads/model-net-synthetic-dfly-plus.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic-dfly-plus.c\n+++ b/src/network-workloads/model-net-synthetic-dfly-plus.c\n@@ -280,7 +280,7 @@ static void handle_kickoff_event(\n //   codes_mapping_get_lp_id(group_name, lp_type_name, anno, 1, local_dest / num_servers_per_rep, local_dest % num_servers_per_rep, &global_dest);\n    global_dest = codes_mapping_get_lpid_from_relative(local_dest, group_name, lp_type_name, NULL, 0);\n    ns->msg_sent_count++;\n-   model_net_event(net_id, \"test\", global_dest, PAYLOAD_SZ, 0.0, sizeof(svr_msg), (const void*)m_remote, sizeof(svr_msg), (const void*)m_local, lp);\n+   m->event_rc = model_net_event(net_id, \"test\", global_dest, PAYLOAD_SZ, 0.0, sizeof(svr_msg), (const void*)m_remote, sizeof(svr_msg), (const void*)m_local, lp);\n \n    issue_event(ns, lp);\n    return;\n@@ -416,6 +416,11 @@ int main(\n \n     tw_opt_add(app_opt);\n     tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+    codes_comm_update();\n \n     if(argc < 2)\n     {\n@@ -477,6 +482,9 @@ int main(\n         assert(ret == 0 || !\"lp_io_flush failure\");\n     }\n     model_net_report_stats(net_id);\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n     tw_end();\n     return 0;\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 41,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic-fattree.c",
                        "old_path": "src/network-workloads/model-net-synthetic-fattree.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic-fattree.c\n+++ b/src/network-workloads/model-net-synthetic-fattree.c\n@@ -253,9 +253,12 @@ static void handle_kickoff_rev_event(\n {\n     (void)b;\n     (void)m;\n-\tns->msg_sent_count--;\n-\tmodel_net_event_rc2(lp, &m->event_rc);\n-    tw_rand_reverse_unif(lp->rng);\n+    ns->msg_sent_count--;\n+    model_net_event_rc2(lp, &m->event_rc);\n+    tw_rand_reverse_unif(lp->rng); // reversing RNG in issue_event\n+    \n+    if (traffic == UNIFORM)\n+        tw_rand_reverse_unif(lp->rng);\n }\t\n static void handle_kickoff_event(\n \t    svr_state * ns,\n@@ -436,6 +439,11 @@ int main(\n     tw_opt_add(app_opt);\n \n     tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+    codes_comm_update();\n \n     offset = 1;\n \n@@ -446,10 +454,10 @@ int main(\n             return 0;\n     }\n \n-    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n-    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n+    MPI_Comm_rank(MPI_COMM_CODES, &rank);\n+    MPI_Comm_size(MPI_COMM_CODES, &nprocs);\n \n-    configuration_load(argv[2], MPI_COMM_WORLD, &config);\n+    configuration_load(argv[2], MPI_COMM_CODES, &config);\n \n     model_net_register();\n \n@@ -484,7 +492,7 @@ int main(\n \n     printf(\"num_nodes:%d \\n\",num_nodes);\n \n-    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_WORLD) < 0)\n+    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_CODES) < 0)\n     {\n         return(-1);\n     }\n@@ -516,11 +524,13 @@ int main(\n     }\n #endif\n \n-    if(lp_io_flush(handle, MPI_COMM_WORLD) < 0)\n+    if(lp_io_flush(handle, MPI_COMM_CODES) < 0)\n     {\n         return(-1);\n     }\n-\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n     tw_end();\n \n #if PARAMS_LOG\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 42,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic-slimfly.c",
                        "old_path": "src/network-workloads/model-net-synthetic-slimfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic-slimfly.c\n+++ b/src/network-workloads/model-net-synthetic-slimfly.c\n@@ -494,6 +494,11 @@ int main(\n  \n     tw_opt_add(app_opt);\n     tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+    codes_comm_update();\n \n     if(argc < 2)\n     {\n@@ -502,10 +507,10 @@ int main(\n             return 0;\n     }\n \n-    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n-    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n+    MPI_Comm_rank(MPI_COMM_CODES, &rank);\n+    MPI_Comm_size(MPI_COMM_CODES, &nprocs);\n \n-    configuration_load(argv[2], MPI_COMM_WORLD, &config);\n+    configuration_load(argv[2], MPI_COMM_CODES, &config);\n     model_net_register();\n     svr_add_lp_type();\n     \n@@ -526,7 +531,7 @@ int main(\n     num_nodes_per_grp = num_routers_per_grp * num_servers_per_rep;\n     total_routers = num_routers_per_grp * num_routers_per_grp * 2;\n \n-/*    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_WORLD) < 0)\n+/*    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_CODES) < 0)\n     {\n         return(-1);\n     }\n@@ -536,7 +541,7 @@ int main(\n     {\n         do_lp_io = 1;\n         int flags = lp_io_use_suffix ? LP_IO_UNIQ_SUFFIX : 0;\n-        int ret = lp_io_prepare(lp_io_dir, flags, &io_handle, MPI_COMM_WORLD);\n+        int ret = lp_io_prepare(lp_io_dir, flags, &io_handle, MPI_COMM_CODES);\n         assert(ret == 0 || !\"lp_io_prepare failure\");\n     }\n \n@@ -558,7 +563,7 @@ int main(\n \n  \n    if (do_lp_io){\n-       int ret = lp_io_flush(io_handle, MPI_COMM_WORLD);\n+       int ret = lp_io_flush(io_handle, MPI_COMM_CODES);\n        assert(ret == 0 || !\"lp_io_flush failure\");\n    }\n \n@@ -578,12 +583,15 @@ int main(\n #endif\n     }\n \n-/*    if(lp_io_flush(handle, MPI_COMM_WORLD) < 0)\n+/*    if(lp_io_flush(handle, MPI_COMM_CODES) < 0)\n     {\n         assert(ret == 0 || !\"lp_io_flush failure\");\n         return(-1);\n     }\n */\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n     tw_end();\n \n     if(rank == 0)\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 43,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic.c",
                        "old_path": "src/network-workloads/model-net-synthetic.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic.c\n+++ b/src/network-workloads/model-net-synthetic.c\n@@ -407,6 +407,11 @@ int main(\n \n     tw_opt_add(app_opt);\n     tw_init(&argc, &argv);\n+#ifdef USE_RDAMARIS\n+    if(g_st_ross_rank)\n+    { // keep damaris ranks from running code between here up until tw_end()\n+#endif\n+    codes_comm_update();\n \n     if(argc < 2)\n     {\n@@ -415,10 +420,10 @@ int main(\n             return 0;\n     }\n \n-    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n-    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n+    MPI_Comm_rank(MPI_COMM_CODES, &rank);\n+    MPI_Comm_size(MPI_COMM_CODES, &nprocs);\n \n-    configuration_load(argv[2], MPI_COMM_WORLD, &config);\n+    configuration_load(argv[2], MPI_COMM_CODES, &config);\n \n     model_net_register();\n     svr_add_lp_type();\n@@ -457,15 +462,18 @@ int main(\n     {\n         do_lp_io = 1;\n         int flags = lp_io_use_suffix ? LP_IO_UNIQ_SUFFIX : 0;\n-        int ret = lp_io_prepare(lp_io_dir, flags, &io_handle, MPI_COMM_WORLD);\n+        int ret = lp_io_prepare(lp_io_dir, flags, &io_handle, MPI_COMM_CODES);\n         assert(ret == 0 || !\"lp_io_prepare failure\");\n     }\n     tw_run();\n     if (do_lp_io){\n-        int ret = lp_io_flush(io_handle, MPI_COMM_WORLD);\n+        int ret = lp_io_flush(io_handle, MPI_COMM_CODES);\n         assert(ret == 0 || !\"lp_io_flush failure\");\n     }\n     model_net_report_stats(net_id);\n+#ifdef USE_RDAMARIS\n+    } // end if(g_st_ross_rank)\n+#endif\n     tw_end();\n     return 0;\n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 44,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/doc/README.fattree.txt",
                        "old_path": "src/networks/model-net/doc/README.fattree.txt",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/doc/README.fattree.txt\n+++ b/src/networks/model-net/doc/README.fattree.txt\n@@ -1,8 +1,9 @@\n *** README file for fattree network model ***\n \n-1- Configuring CODES dragonfly network model\n-CODES dragonfly network model can be configured using the fattee config file (currently\n-located in codes/src/network-workloads/conf). Below is an example config file:\n+1- Configuring CODES fat-tree network model\n+CODES fat-tree network model can be configured using example config files\n+(located in codes/src/network-workloads/conf/*fattree*). Below is the \n+bare-minimum example config file:\n \n MODELNET_GRP\n {\n@@ -21,38 +22,46 @@ PARAMS\n \t....\n }\n \n-The first section, MODELNET_GRP specifies the LP types, number of LPs per type and their\n-configuration. In the above case, there are 12 repetitions of 4 server LPs, 4 fat tree\n-network node/terminal LPs and 3 fat tree switch LPs. Each repetition represents a leaf\n-level switch, nodes connected to it, and higher level switches that may be needed to \n-construct the fat-tree. The 'fattree_switch' parameter indicates there are 3 levels \n-to this fat tree and each repitition will have one switch from each level. This \n-configuration will create a total of (fattree_switch)*repetitions=12*3=36 switch LPs,\n-with 'fattree_switch' many switch LPs per level.\n+The first section, MODELNET_GRP specifies the LP types, number of LPs per type\n+and their configuration. In the above case, there are 12 repetitions each with 4\n+server LPs, 4 fat tree network node/terminal LPs and 3 fat tree switch LPs. Each\n+repetition represents a leaf level switch, nodes connected to it, and higher\n+level switches that may be needed to construct the fat-tree. The\n+'fattree_switch' parameter indicates there are 3 levels to this fat tree and\n+each repetition will have one switch at each level. This configuration will\n+create a total of (fattree_switch)*repetitions=12*3=36 switch LPs, with\n+'fattree_switch' many levels.\n+\n+Typically, for a balanced, single plane fat-tree:\n \n modelnet_fattree = radix of switch/2\n fattree_switch = number of levels in the fattree (2 or 3)\n \n ft_type:\n-0: Custom- (\"Pruned\" Fat Tree)\n-1: Standard Full Fat Tree\n-\n-The Custom- ft_type is simply a pruned standard full fat tree. This layout type starts\n-with the standard full fat tree and then removes pods and adjusts L1-L2 switch connections\n-as needed to drop the total node/terminal count in the system. This approach still maintains\n-full bisection bandwidth. Knowing a full standard fat tree uses k pods of k/2 switches per\n-pod (k/2 L1 switches and k/2 L0 switches) and each switch in L0 connects to k/2 terminals,\n-then each pod connects to (k/2)*(k/2) terminals. Therefore, the number of pods needed to get\n-N-many terminals using the Custom- ft_type is Np = ceil(N/[(k/2)*(k/2)]). So the config file\n-should have \"repetitions\" = \"switch_count\" = Np*(k/2).\n+0: General, possible pruned/multi-railed/tapered, fat-tree\n+1: Standard Full Fat Tree (deprecated - use type 0 for this case too)\n+2: Multi-nic fat-tree where each NIC is connected to an independent plane\n+\n+The general- ft_type is simply a pruned standard full fat tree. This layout\n+represent a partially filled fat-tree, which is created by removing pods and\n+adjusting L1-L2 switch connections as needed to reduce the total node/terminal\n+count in the system. This approach still maintains full bisection bandwidth.\n+Knowing a full standard fat tree uses k pods of k/2 switches per pod (k/2 L1\n+switches and k/2 L0 switches) and each switch in L0 connects to k/2 terminals,\n+then each pod connects to (k/2)*(k/2) terminals. Therefore, the number of pods\n+needed to get N-many terminals using the Custom- ft_type is Np =\n+ceil(N/[(k/2)*(k/2)]). So the config file should have \"repetitions\" =\n+\"switch_count\" = Np*(k/2).\n \n Supported PARAMS:\n \n packet_size, chunk_size (ideally kept same)\n modelnet_scheduler - NIC message scheduler\n-modelnet_order=( \"fattree\" ); \n-num_levels : number of levels in the fattree (same as fattree_switch)\n+modelnet_order=\"fattree\"; \n+message_size=\"512\" ;\n+num_levels : number of levels in the fattree (2 or 3)\n tapering : controls division of ports to nodes at leaf level\n+num_rails : number of rails/planes in the system (fattree_switch = num_levels * num_rails)\n switch_count : number of leaf level switches (same as repetitions)\n switch_radix : radix of the switches\n router_delay : delay caused by switched in ns\n@@ -60,12 +69,22 @@ vc_size : size of switch VCs in bytes\n cn_vc_size : size of VC between NIC and switch in bytes\n link_bandwidth, cn_bandwidth : in GB/s\n routing : {adaptive, static}\n+num_injection_queues : number of injection queues in NIC (=num_rails)\n+rail_select : {adaptive, static} rail selection scheme for the packets\n+rail_select_limit : message size in bytes above which adaptive rail selection algorithm is enabled if chosen\n \n For radix k switches with tapering t, t*k/(t+1) ports are used for connecting\n to nodes, and remaining are connected to next level switches. fmod(k, t+1) has\n to be 0. Default tapering is 1, i.e. full bandwidth. Note that, even when\n tapering is >1, the number of leaf level switches in a Pod are k/2.\n \n+If simulation of system with multiple NICs per node is desired (each NIC has \n+its own rail/plane), ft_type = 2 should be selected. In this case, num_rails\n+should be set to the number of NICs/rails desired. Also, for this case,\n+fattree_switch = num_levels * num_rails\n+modelnet_fattree = usual_per_switch_nic * num_rails\n+num_injection_queues = 1\n+\n 2- Static Routing\n If static routing is chosen, two more PARAMS must be provided:\n routing_folder :  folder that contain lft files generated using method described below.\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 45,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/dragonfly-custom.C",
                        "old_path": "src/networks/model-net/dragonfly-custom.C",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/dragonfly-custom.C\n+++ b/src/networks/model-net/dragonfly-custom.C\n@@ -26,14 +26,13 @@\n #endif\n \n #define DUMP_CONNECTIONS 0\n-#define PRINT_CONFIG 1\n #define CREDIT_SIZE 8\n #define DFLY_HASH_TABLE_SIZE 4999\n // debugging parameters\n #define DEBUG_LP 892\n-#define T_ID -1\n+#define T_ID 10\n #define TRACK -1\n-#define TRACK_PKT -1\n+#define TRACK_PKT 0\n #define TRACK_MSG -1\n #define DEBUG 0\n #define MAX_STATS 65536\n@@ -44,11 +43,6 @@\n #define LP_CONFIG_NM_ROUT (model_net_lp_config_names[DRAGONFLY_CUSTOM_ROUTER])\n #define LP_METHOD_NM_ROUT (model_net_method_names[DRAGONFLY_CUSTOM_ROUTER])\n \n-static int max_lvc_src_g = 1;\n-static int max_lvc_intm_g = 3;\n-static int min_gvc_src_g = 0;\n-static int min_gvc_intm_g = 1;\n-\n static int BIAS_MIN = 1;\n static int DF_DALLY = 0;\n static int adaptive_threshold = 1024;\n@@ -183,13 +177,8 @@ struct dragonfly_param\n     double global_delay;\n     double credit_delay;\n     double router_delay;\n-\n-    int max_hops_notify; //maximum number of hops allowed before notifying via printout\n };\n \n-static const dragonfly_param* stored_params;\n-\n-\n struct dfly_hash_key\n {\n     uint64_t message_id;\n@@ -270,14 +259,13 @@ struct terminal_state\n    long finished_chunks;\n    long finished_packets;\n \n-   tw_stime last_buf_full;\n+   tw_stime * last_buf_full;\n    tw_stime busy_time;\n    \n    tw_stime max_latency;\n    tw_stime min_latency;\n \n    char output_buf[4096];\n-   char output_buf2[4096];\n    /* For LP suspend functionality */\n    int error_ct;\n \n@@ -354,7 +342,7 @@ struct router_state\n    \n    tw_stime* next_output_available_time;\n    tw_stime* cur_hist_start_time;\n-   tw_stime* last_buf_full;\n+   tw_stime** last_buf_full;\n \n    tw_stime* busy_time;\n    tw_stime* busy_time_sample;\n@@ -379,6 +367,7 @@ struct router_state\n    int* cur_hist_num;\n    \n    char output_buf[4096];\n+   char output_buf2[4096];\n \n    struct dfly_router_sample * rsamples;\n    \n@@ -391,7 +380,7 @@ struct router_state\n    struct dfly_router_sample ross_rsample;\n };\n \n-/* had to pull some of the ROSS model stats collection stuff up here */\n+/* ROSS model instrumentation */\n void custom_dragonfly_event_collect(terminal_custom_message *m, tw_lp *lp, char *buffer, int *collect_flag);\n void custom_dragonfly_model_stat_collect(terminal_state *s, tw_lp *lp, char *buffer);\n void custom_dfly_router_model_stat_collect(router_state *s, tw_lp *lp, char *buffer);\n@@ -551,43 +540,6 @@ static terminal_custom_message_list* return_tail(\n     return tail;\n }\n \n-void dragonfly_print_params(const dragonfly_param *p)\n-{\n-    int myRank;\n-    MPI_Comm_rank(MPI_COMM_CODES, &myRank);\n-    if (!myRank) { \n-        printf(\"\\n------------------ Dragonfly Custom Parameters ---------\\n\");\n-        printf(\"\\tnum_routers =            %d\\n\",p->num_routers);\n-        printf(\"\\tlocal_bandwidth =        %.2f\\n\",p->local_bandwidth);\n-        printf(\"\\tglobal_bandwidth =       %.2f\\n\",p->global_bandwidth);\n-        printf(\"\\tcn_bandwidth =           %.2f\\n\",p->cn_bandwidth);\n-        printf(\"\\tnum_vcs =                %d\\n\",p->num_vcs);\n-        printf(\"\\tlocal_vc_size =          %d\\n\",p->local_vc_size);\n-        printf(\"\\tglobal_vc_size =         %d\\n\",p->global_vc_size);\n-        printf(\"\\tcn_vc_size =             %d\\n\",p->cn_vc_size);\n-        printf(\"\\tchunk_size =             %d\\n\",p->chunk_size);\n-        printf(\"\\tnum_cn =                 %d\\n\",p->num_cn);\n-        printf(\"\\tintra_grp_radix =        %d\\n\",p->intra_grp_radix);\n-        printf(\"\\tnum_col_chans =          %d\\n\",p->num_col_chans);\n-        printf(\"\\tnum_row_chans =          %d\\n\",p->num_row_chans);\n-        printf(\"\\tnum_router_rows =        %d\\n\",p->num_router_rows);\n-        printf(\"\\tnum_router_cols =        %d\\n\",p->num_router_cols);\n-        printf(\"\\tnum_groups =             %d\\n\",p->num_groups);\n-        printf(\"\\tradix =                  %d\\n\",p->radix);\n-        printf(\"\\ttotal_routers =          %d\\n\",p->total_routers);\n-        printf(\"\\ttotal_terminals =        %d\\n\",p->total_terminals);\n-        printf(\"\\tnum_global_channels =    %d\\n\",p->num_global_channels);\n-        printf(\"\\tcn_delay =               %.2f\\n\",p->cn_delay);\n-        printf(\"\\tlocal_delay =            %.2f\\n\",p->local_delay);\n-        printf(\"\\tglobal_delay =           %.2f\\n\",p->global_delay);\n-        printf(\"\\tcredit_delay =           %.2f\\n\",p->credit_delay);\n-        printf(\"\\trouter_delay =           %.2f\\n\",p->router_delay);\n-        printf(\"\\trouting =                %d\\n\",routing);\n-        printf(\"\\tmax hops notification =  %d\\n\",p->max_hops_notify);\n-        printf(\"------------------------------------------------------\\n\\n\");\n-    }\n-}\n-\n static void dragonfly_read_config(const char * anno, dragonfly_param *params){\n     /*Adding init for router magic number*/\n     uint32_t h1 = 0, h2 = 0; \n@@ -696,12 +648,6 @@ static void dragonfly_read_config(const char * anno, dragonfly_param *params){\n         routing = -1;\n     }\n \n-    rc = configuration_get_value_int(&config, \"PARAMS\", \"notification_on_hops_greater_than\", anno, &p->max_hops_notify);\n-    if (rc) {\n-        printf(\"Maximum hops for notifying not specified, setting to INT MAX\\n\");\n-        p->max_hops_notify = INT_MAX;\n-    }\n-\n     // rc = configuration_get_value_int(&config, \"PARAMS\", \"num_vcs_override\", anno, &p->num_vcs);\n     // if(rc) {\n     //     if(routing == PROG_ADAPTIVE)\n@@ -715,13 +661,16 @@ static void dragonfly_read_config(const char * anno, dragonfly_param *params){\n    \n if(DF_DALLY == 0) \n {\n-    //if(routing == PROG_ADAPTIVE)\n-    //    p->num_vcs = 10;\n-    //else\n+    if(routing == PROG_ADAPTIVE)\n+        p->num_vcs = 10;\n+    else\n         p->num_vcs = 8;\n }\n else\n {\n+    if(routing == PROG_ADAPTIVE)\n+        p->num_vcs = 5;\n+    else\n         p->num_vcs = 4;\n }\n     rc = configuration_get_value_int(&config, \"PARAMS\", \"num_groups\", anno, &p->num_groups);\n@@ -907,18 +856,13 @@ else\n     p->local_delay = bytes_to_ns(p->chunk_size, p->local_bandwidth);\n     p->global_delay = bytes_to_ns(p->chunk_size, p->global_bandwidth);\n     p->credit_delay = bytes_to_ns(CREDIT_SIZE, p->local_bandwidth); //assume 8 bytes packet\n-\n-    if (PRINT_CONFIG) \n-        dragonfly_print_params(p);\n-\n-    stored_params = p;\n }\n \n void dragonfly_custom_configure(){\n     anno_map = codes_mapping_get_lp_anno_map(LP_CONFIG_NM_TERM);\n     assert(anno_map);\n     num_params = anno_map->num_annos + (anno_map->has_unanno_lp > 0);\n-    all_params = (dragonfly_param *)calloc(num_params, sizeof(*all_params));\n+    all_params = (dragonfly_param *)malloc(num_params * sizeof(*all_params));\n \n     for (int i = 0; i < anno_map->num_annos; i++){\n         const char * anno = anno_map->annotations[i].ptr;\n@@ -964,9 +908,6 @@ void dragonfly_custom_report_stats()\n    /* print statistics */\n    if(!g_tw_mynode)\n    {\t\n-    if (PRINT_CONFIG) \n-        dragonfly_print_params(stored_params);\n-\n       printf(\" Average number of hops traversed %f average chunk latency %lf us maximum chunk latency %lf us avg message size %lf bytes finished messages %lld finished chunks %lld \\n\", \n               (float)avg_hops/total_finished_chunks, avg_time/(total_finished_chunks*1000), max_time/1000, (float)final_msg_sz/total_finished_msgs, total_finished_msgs, total_finished_chunks);\n      if(routing == ADAPTIVE || routing == PROG_ADAPTIVE || SHOW_ADAP_STATS)\n@@ -1027,20 +968,21 @@ terminal_custom_init( terminal_state * s,\n \n    rc_stack_create(&s->st);\n    s->num_vcs = 1;\n-   s->vc_occupancy = (int*)calloc(s->num_vcs, sizeof(int));\n-   s->last_buf_full = 0.0;\n+   s->vc_occupancy = (int*)malloc(s->num_vcs * sizeof(int));\n+   s->last_buf_full = (tw_stime*)malloc(s->num_vcs * sizeof(tw_stime));\n \n    for( i = 0; i < s->num_vcs; i++ )\n     {\n+      s->last_buf_full[i] = 0.0;\n       s->vc_occupancy[i]=0;\n     }\n \n \n    s->rank_tbl = NULL;\n    s->terminal_msgs = \n-       (terminal_custom_message_list**)calloc(s->num_vcs, sizeof(terminal_custom_message_list*));\n+       (terminal_custom_message_list**)malloc(s->num_vcs*sizeof(terminal_custom_message_list*));\n    s->terminal_msgs_tail = \n-       (terminal_custom_message_list**)calloc(s->num_vcs, sizeof(terminal_custom_message_list*));\n+       (terminal_custom_message_list**)malloc(s->num_vcs*sizeof(terminal_custom_message_list*));\n    s->terminal_msgs[0] = NULL;\n    s->terminal_msgs_tail[0] = NULL;\n    s->terminal_length = 0;\n@@ -1090,29 +1032,29 @@ void router_custom_setup(router_state * r, tw_lp * lp)\n    r->ross_rsample.rev_events = 0;\n \n \n-   r->global_channel = (int*)calloc(p->num_global_channels, sizeof(int));\n-   r->next_output_available_time = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n-   r->cur_hist_start_time = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n-   r->link_traffic = (int64_t*)calloc(p->radix, sizeof(int64_t));\n-   r->link_traffic_sample = (int64_t*)calloc(p->radix, sizeof(int64_t));\n-   r->cur_hist_num = (int*)calloc(p->radix, sizeof(int));\n-   r->prev_hist_num = (int*)calloc(p->radix, sizeof(int));\n+   r->global_channel = (int*)malloc(p->num_global_channels * sizeof(int));\n+   r->next_output_available_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+   r->cur_hist_start_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+   r->link_traffic = (int64_t*)malloc(p->radix * sizeof(int64_t));\n+   r->link_traffic_sample = (int64_t*)malloc(p->radix * sizeof(int64_t));\n+   r->cur_hist_num = (int*)malloc(p->radix * sizeof(int));\n+   r->prev_hist_num = (int*)malloc(p->radix * sizeof(int));\n   \n-   r->last_sent_chan = (int*) calloc(p->num_router_rows, sizeof(int));\n-   r->vc_occupancy = (int**)calloc(p->radix, sizeof(int*));\n-   r->in_send_loop = (int*)calloc(p->radix, sizeof(int));\n+   r->last_sent_chan = (int*) malloc(p->num_router_rows * sizeof(int));\n+   r->vc_occupancy = (int**)malloc(p->radix * sizeof(int*));\n+   r->in_send_loop = (int*)malloc(p->radix * sizeof(int));\n    r->pending_msgs = \n-    (terminal_custom_message_list***)calloc(p->radix, sizeof(terminal_custom_message_list**));\n+    (terminal_custom_message_list***)malloc(p->radix * sizeof(terminal_custom_message_list**));\n    r->pending_msgs_tail = \n-    (terminal_custom_message_list***)calloc(p->radix, sizeof(terminal_custom_message_list**));\n+    (terminal_custom_message_list***)malloc(p->radix * sizeof(terminal_custom_message_list**));\n    r->queued_msgs = \n-    (terminal_custom_message_list***)calloc(p->radix, sizeof(terminal_custom_message_list**));\n+    (terminal_custom_message_list***)malloc(p->radix * sizeof(terminal_custom_message_list**));\n    r->queued_msgs_tail = \n-    (terminal_custom_message_list***)calloc(p->radix, sizeof(terminal_custom_message_list**));\n-   r->queued_count = (int*)calloc(p->radix, sizeof(int));\n-   r->last_buf_full = (tw_stime*)calloc(p->radix, sizeof(tw_stime*));\n-   r->busy_time = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n-   r->busy_time_sample = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n+    (terminal_custom_message_list***)malloc(p->radix * sizeof(terminal_custom_message_list**));\n+   r->queued_count = (int*)malloc(p->radix * sizeof(int));\n+   r->last_buf_full = (tw_stime**)malloc(p->radix * sizeof(tw_stime*));\n+   r->busy_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+   r->busy_time_sample = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n \n    /* set up for ROSS stats sampling */\n    r->link_traffic_ross_sample = (int64_t*)calloc(p->radix, sizeof(int64_t));\n@@ -1142,17 +1084,18 @@ void router_custom_setup(router_state * r, tw_lp * lp)\n \tr->prev_hist_num[i] = 0;\n     r->queued_count[i] = 0;    \n     r->in_send_loop[i] = 0;\n-    r->vc_occupancy[i] = (int*)calloc(p->num_vcs, sizeof(int));\n-    r->pending_msgs[i] = (terminal_custom_message_list**)calloc(p->num_vcs, \n+    r->vc_occupancy[i] = (int*)malloc(p->num_vcs * sizeof(int));\n+    r->pending_msgs[i] = (terminal_custom_message_list**)malloc(p->num_vcs * \n         sizeof(terminal_custom_message_list*));\n-    r->last_buf_full[i] = 0.0;\n-    r->pending_msgs_tail[i] = (terminal_custom_message_list**)calloc(p->num_vcs,\n+    r->last_buf_full[i] = (tw_stime*)malloc(p->num_vcs * sizeof(tw_stime));\n+    r->pending_msgs_tail[i] = (terminal_custom_message_list**)malloc(p->num_vcs * \n         sizeof(terminal_custom_message_list*));\n-    r->queued_msgs[i] = (terminal_custom_message_list**)calloc(p->num_vcs,\n+    r->queued_msgs[i] = (terminal_custom_message_list**)malloc(p->num_vcs * \n         sizeof(terminal_custom_message_list*));\n-    r->queued_msgs_tail[i] = (terminal_custom_message_list**)calloc(p->num_vcs,\n+    r->queued_msgs_tail[i] = (terminal_custom_message_list**)malloc(p->num_vcs * \n         sizeof(terminal_custom_message_list*));\n         for(int j = 0; j < p->num_vcs; j++) {\n+            r->last_buf_full[i][j] = 0.0;\n             r->vc_occupancy[i][j] = 0;\n             r->pending_msgs[i][j] = NULL;\n             r->pending_msgs_tail[i][j] = NULL;\n@@ -1307,6 +1250,10 @@ static void packet_generate_rc(terminal_state * s, tw_bf * bf, terminal_custom_m\n     }\n       if(bf->c11) {\n         s->issueIdle = 0;\n+        if(bf->c8)\n+        {\n+            s->last_buf_full[0] = msg->saved_busy_time;\n+        }\n       }\n      struct mn_stats* stat;\n      stat = model_net_find_stats(msg->category, s->dragonfly_stats_array);\n@@ -1362,13 +1309,13 @@ static void packet_generate(terminal_state * s, tw_bf * bf, terminal_custom_mess\n \n   for(int i = 0; i < num_chunks; i++)\n   {\n-    terminal_custom_message_list *cur_chunk = (terminal_custom_message_list*)calloc(1,\n+    terminal_custom_message_list *cur_chunk = (terminal_custom_message_list*)malloc(\n       sizeof(terminal_custom_message_list));\n     msg->origin_router_id = s->router_id;\n     init_terminal_custom_message_list(cur_chunk, msg);\n   \n     if(msg->remote_event_size_bytes + msg->local_event_size_bytes > 0) {\n-      cur_chunk->event_data = (char*)calloc(1,\n+      cur_chunk->event_data = (char*)malloc(\n           msg->remote_event_size_bytes + msg->local_event_size_bytes);\n     }\n     \n@@ -1394,6 +1341,14 @@ static void packet_generate(terminal_state * s, tw_bf * bf, terminal_custom_mess\n   } else {\n     bf->c11 = 1;\n     s->issueIdle = 1;\n+\n+      if(s->last_buf_full[0] == 0.0)\n+      {\n+        bf->c8 = 1;\n+        msg->saved_busy_time = s->last_buf_full[0];\n+        /* TODO: Assumes a single vc from terminal to router */\n+        s->last_buf_full[0] = tw_now(lp);\n+      }\n   }\n   \n   if(s->in_send_loop == 0) {\n@@ -1424,13 +1379,11 @@ static void packet_generate(terminal_state * s, tw_bf * bf, terminal_custom_mess\n static void packet_send_rc(terminal_state * s, tw_bf * bf, terminal_custom_message * msg,\n         tw_lp * lp)\n {\n+      if(bf->c10)\n+         s->last_buf_full[0] = msg->saved_busy_time;\n       \n       if(bf->c1) {\n         s->in_send_loop = 1;\n-        if(bf->c3)\n-        {\n-         s->last_buf_full = msg->saved_busy_time;\n-        }\n         return;\n       }\n       \n@@ -1460,7 +1413,7 @@ static void packet_send_rc(terminal_state * s, tw_bf * bf, terminal_custom_messa\n           if(bf->c6)\n           {\n             s->busy_time = msg->saved_total_time;\n-            s->last_buf_full = msg->saved_busy_time;\n+            s->last_buf_full[0] = msg->saved_busy_time;\n             s->busy_time_sample = msg->saved_sample_time;\n             s->ross_sample.busy_time_sample = msg->saved_sample_time;\n             s->busy_time_ross_sample = msg->saved_busy_time_ross;\n@@ -1478,21 +1431,21 @@ static void packet_send(terminal_state * s, tw_bf * bf, terminal_custom_message \n   tw_lpid router_id;\n \n   terminal_custom_message_list* cur_entry = s->terminal_msgs[0];\n-  bool noEmptyVC = false;\n \n   if(s->vc_occupancy[0] + s->params->chunk_size > s->params->cn_vc_size)\n-      noEmptyVC = true;\n+  {\n+      if(s->last_buf_full[0] == 0.0)\n+      {\n+        bf->c10 = 1;\n+        msg->saved_busy_time = s->last_buf_full[0];\n+        s->last_buf_full[0] = tw_now(lp);\n+      }\n+  }\n \n   if(s->vc_occupancy[0] + s->params->chunk_size > s->params->cn_vc_size \n       || cur_entry == NULL) {\n     bf->c1 = 1;\n     s->in_send_loop = 0;\n-    if(noEmptyVC && !s->last_buf_full)\n-    {\n-        bf->c3 = 1;\n-        msg->saved_busy_time = s->last_buf_full;\n-        s->last_buf_full = tw_now(lp); \n-    }\n     return;\n   }\n \n@@ -1538,7 +1491,7 @@ static void packet_send(terminal_state * s, tw_bf * bf, terminal_custom_message \n \n \n   if(cur_entry->msg.packet_ID == LLU(TRACK_PKT) && lp->gid == T_ID)\n-    printf(\"\\n Packet %llu generated at terminal %d dest %llu size %llu num chunks %llu router-id %d %llu\", \n+    printf(\"\\n Packet %llu generated at terminal %d dest %llu size %llu num chunks %llu router-id %d %d\", \n             cur_entry->msg.packet_ID, s->terminal_id, LLU(cur_entry->msg.dest_terminal_id),\n             LLU(cur_entry->msg.packet_size), LLU(num_chunks), s->router_id, router_id);\n \n@@ -1582,18 +1535,19 @@ static void packet_send(terminal_state * s, tw_bf * bf, terminal_custom_message \n     ts += tw_rand_unif(lp->rng);\n     model_net_method_idle_event(ts, 0, lp);\n    \n-    if(s->last_buf_full > 0.0)\n+    if(s->last_buf_full[0] > 0.0)\n     {\n         bf->c6 = 1;\n         msg->saved_total_time = s->busy_time;\n-        msg->saved_busy_time = s->last_buf_full;\n+        msg->saved_busy_time = s->last_buf_full[0];\n         msg->saved_sample_time = s->busy_time_sample;\n \n-        s->busy_time += (tw_now(lp) - s->last_buf_full);\n-        s->busy_time_sample += (tw_now(lp) - s->last_buf_full);\n-        s->ross_sample.busy_time_sample += (tw_now(lp) - s->last_buf_full);\n-        s->busy_time_ross_sample += (tw_now(lp) - s->last_buf_full);\n-        s->last_buf_full = 0.0;\n+        s->busy_time += (tw_now(lp) - s->last_buf_full[0]);\n+        s->busy_time_sample += (tw_now(lp) - s->last_buf_full[0]);\n+        s->ross_sample.busy_time_sample += (tw_now(lp) - s->last_buf_full[0]);\n+        msg->saved_busy_time_ross = s->busy_time_ross_sample;\n+        s->busy_time_ross_sample += (tw_now(lp) - s->last_buf_full[0]);\n+        s->last_buf_full[0] = 0.0;\n     }\n   }\n   return;\n@@ -1728,11 +1682,6 @@ static void send_remote_event(terminal_state * s, terminal_custom_message * msg,\n static void packet_arrive(terminal_state * s, tw_bf * bf, terminal_custom_message * msg, \n   tw_lp * lp) {\n \n-    if (msg->my_N_hop > s->params->max_hops_notify)\n-    {\n-        printf(\"Terminal received a packet with %d hops! (Notify on > than %d)\\n\",msg->my_N_hop, s->params->max_hops_notify);\n-    }\n-\n     // NIC aggregation - should this be a separate function?\n     // Trigger an event on receiving server\n \n@@ -1771,7 +1720,7 @@ static void packet_arrive(terminal_state * s, tw_bf * bf, terminal_custom_messag\n     assert(lp->gid == msg->dest_terminal_id);\n \n     if(msg->packet_ID == LLU(TRACK_PKT) && msg->src_terminal_id == T_ID)\n-        printf(\"\\n Packet %llu arrived at lp %llu hops %d \", msg->sender_lp, LLU(lp->gid), msg->my_N_hop);\n+        printf(\"\\n Packet %d arrived at lp %llu hops %d \", msg->sender_lp, LLU(lp->gid), msg->my_N_hop);\n   \n   tw_stime ts = g_tw_lookahead + s->params->credit_delay + tw_rand_unif(lp->rng);\n \n@@ -1868,7 +1817,7 @@ static void packet_arrive(terminal_state * s, tw_bf * bf, terminal_custom_messag\n    if(!tmp)\n    {\n         bf->c5 = 1;\n-       struct dfly_qhash_entry * d_entry = (dfly_qhash_entry *)calloc(1, sizeof (struct dfly_qhash_entry));\n+       struct dfly_qhash_entry * d_entry = (dfly_qhash_entry *)malloc(sizeof (struct dfly_qhash_entry));\n        d_entry->num_chunks = 0;\n        d_entry->key = key;\n        d_entry->remote_event_data = NULL;\n@@ -1899,7 +1848,7 @@ static void packet_arrive(terminal_state * s, tw_bf * bf, terminal_custom_messag\n     if(msg->remote_event_size_bytes > 0 && !tmp->remote_event_data)\n     {\n         /* Retreive the remote event entry */\n-         tmp->remote_event_data = (char*)calloc(1, msg->remote_event_size_bytes);\n+         tmp->remote_event_data = (char*)malloc(msg->remote_event_size_bytes);\n          assert(tmp->remote_event_data);\n          tmp->remote_event_size = msg->remote_event_size_bytes; \n          memcpy(tmp->remote_event_data, m_data_src, msg->remote_event_size_bytes);\n@@ -2045,11 +1994,11 @@ void dragonfly_custom_rsample_init(router_state * s,\n    assert(p->radix);\n \n    s->max_arr_size = MAX_STATS;\n-   s->rsamples = (struct dfly_router_sample*)calloc(MAX_STATS, sizeof(struct dfly_router_sample)); \n+   s->rsamples = (struct dfly_router_sample*)malloc(MAX_STATS * sizeof(struct dfly_router_sample)); \n    for(; i < s->max_arr_size; i++)\n    {\n-    s->rsamples[i].busy_time = (tw_stime*)calloc(p->radix, sizeof(tw_stime)); \n-    s->rsamples[i].link_traffic_sample = (int64_t*)calloc(p->radix, sizeof(int64_t));\n+    s->rsamples[i].busy_time = (tw_stime*)malloc(sizeof(tw_stime) * p->radix); \n+    s->rsamples[i].link_traffic_sample = (int64_t*)malloc(sizeof(int64_t) * p->radix);\n    }\n }\n void dragonfly_custom_rsample_rc_fn(router_state * s,\n@@ -2096,7 +2045,7 @@ void dragonfly_custom_rsample_fn(router_state * s,\n \n   if(s->op_arr_size >= s->max_arr_size) \n   {\n-    struct dfly_router_sample * tmp = (dfly_router_sample *)calloc((MAX_STATS + s->max_arr_size), sizeof(struct dfly_router_sample));\n+    struct dfly_router_sample * tmp = (dfly_router_sample *)malloc((MAX_STATS + s->max_arr_size) * sizeof(struct dfly_router_sample));\n     memcpy(tmp, s->rsamples, s->op_arr_size * sizeof(struct dfly_router_sample));\n     free(s->rsamples);\n     s->rsamples = tmp;\n@@ -2188,7 +2137,7 @@ void dragonfly_custom_sample_init(terminal_state * s,\n     s->op_arr_size = 0;\n     s->max_arr_size = MAX_STATS;\n \n-    s->sample_stat = (dfly_cn_sample *)calloc(MAX_STATS, sizeof(struct dfly_cn_sample));\n+    s->sample_stat = (dfly_cn_sample *)malloc(MAX_STATS * sizeof(struct dfly_cn_sample));\n     \n }\n void dragonfly_custom_sample_rc_fn(terminal_state * s,\n@@ -2235,7 +2184,7 @@ void dragonfly_custom_sample_fn(terminal_state * s,\n     {\n         /* In the worst case, copy array to a new memory location, its very\n          * expensive operation though */\n-        struct dfly_cn_sample * tmp = (dfly_cn_sample *)calloc((MAX_STATS + s->max_arr_size), sizeof(struct dfly_cn_sample));\n+        struct dfly_cn_sample * tmp = (dfly_cn_sample *)malloc((MAX_STATS + s->max_arr_size) * sizeof(struct dfly_cn_sample));\n         memcpy(tmp, s->sample_stat, s->op_arr_size * sizeof(struct dfly_cn_sample));\n         free(s->sample_stat);\n         s->sample_stat = tmp;\n@@ -2379,36 +2328,26 @@ dragonfly_custom_terminal_final( terminal_state * s,\n       tw_lp * lp )\n {\n \tmodel_net_print_stats(lp->gid, s->dragonfly_stats_array);\n-    int written = 0;\n   \n     if(s->terminal_id == 0)\n     {\n-        written += sprintf(s->output_buf + written, \"# Format <source_id> <source_type> <dest_id> < dest_type>  <link_type> <link_traffic> <link_saturation>\");\n-//        fprintf(fp, \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Avg hops> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n-    }\n-    written += sprintf(s->output_buf + written, \"\\n%u %s %llu %s %s %llu %lf\",\n-            s->terminal_id, \"T\", s->router_id, \"R\", \"CN\", LLU(s->total_msg_size), s->busy_time); \n-\n-    lp_io_write(lp->gid, (char*)\"dragonfly-link-stats\", written, s->output_buf); \n-    \n-    if(s->terminal_id == 0)\n-    {\n         char meta_filename[64];\n-        sprintf(meta_filename, \"dragonfly-cn-stats.meta\");\n+        sprintf(meta_filename, \"dragonfly-msg-stats.meta\");\n \n         FILE * fp = fopen(meta_filename, \"w+\");\n-        fprintf(fp, \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n+        fprintf(fp, \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Avg hops> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n     }\n-   \n-    written = 0;\n-    written += sprintf(s->output_buf2 + written, \"%llu %llu %lf %lf %lf %lf %llu %lf\\n\", \n-            lp->gid, s->terminal_id, s->total_time/s->finished_chunks, \n-            s->busy_time, s->max_latency, s->min_latency,\n-            s->finished_packets, (double)s->total_hops/s->finished_chunks);\n+    int written = 0;\n+\n+    written += sprintf(s->output_buf + written, \"%llu %u %llu %lf %ld %lf %lf %lf %lf\\n\",\n+            LLU(lp->gid), s->terminal_id, LLU(s->total_msg_size), s->total_time/s->finished_chunks, \n+            s->finished_packets, (double)s->total_hops/s->finished_chunks,\n+            s->busy_time, s->max_latency, s->min_latency);\n \n+    lp_io_write(lp->gid, (char*)\"dragonfly-msg-stats\", written, s->output_buf); \n+    \n     if(s->terminal_msgs[0] != NULL) \n       printf(\"[%llu] leftover terminal messages \\n\", LLU(lp->gid));\n-    lp_io_write(lp->gid, (char*)\"dragonfly-cn-stats\", written, s->output_buf2); \n \n \n     //if(s->packet_gen != s->packet_fin)\n@@ -2444,47 +2383,24 @@ void dragonfly_custom_router_final(router_state * s,\n     \n     const dragonfly_param *p = s->params;\n     int written = 0;\n-    int src_rel_id = s->router_id % p->num_routers;\n-    int local_grp_id = s->router_id / p->num_routers;\n-    for(int d = 0; d < p->intra_grp_radix; d++) \n+    if(!s->router_id)\n     {\n-        if(d != src_rel_id)\n-        {\n-            int dest_ab_id = local_grp_id * p->num_routers + d;\n-            written += sprintf(s->output_buf + written, \"\\n%d %s %d %s %s %llu %lf\", \n-                s->router_id,\n-                \"R\",\n-                dest_ab_id,\n-                \"R\",\n-                \"L\",\n-                s->link_traffic[d],\n-                s->busy_time[d]);\n-        }\n+        written = sprintf(s->output_buf, \"# Format <LP ID> <Group ID> <Router ID> <Busy time per router port(s)>\");\n+        written += sprintf(s->output_buf + written, \"# Router ports in the order: %d green links, %d black links %d global channels \\n\", \n+                p->num_router_cols * p->num_row_chans, p->num_router_rows * p->num_col_chans, p->num_global_channels);\n     }\n-        map< int, vector<bLink> >  &curMap = interGroupLinks[s->router_id];\n-        map< int, vector<bLink> >::iterator it = curMap.begin();\n-        for(; it != curMap.end(); it++)\n-        {\n-            /* TODO: Works only for single global connections right now. Make it functional\n-             * for a 2-D dragonfly. */\n-            for(int l = 0; l < it->second.size(); l++) {\n-                int dest_rtr_id = it->second[l].dest;\n-                int offset = it->second[l].offset;\n-                assert(offset >= 0 && offset < p->num_global_channels);\n-                written += sprintf(s->output_buf + written, \"\\n%d %s %d %s %s %llu %lf\", \n-                    s->router_id,\n-                    \"R\",\n-                    dest_rtr_id,\n-                    \"R\",\n-                    \"G\",\n-                    s->link_traffic[offset],\n-                    s->busy_time[offset]);\n-            }\n-        }\n+    written += sprintf(s->output_buf + written, \"\\n %llu %d %d\", \n+            LLU(lp->gid),\n+            s->router_id / p->num_routers,\n+            s->router_id % p->num_routers);\n+    for(int d = 0; d < p->radix; d++) \n+        written += sprintf(s->output_buf + written, \" %lf\", s->busy_time[d]);\n+\n     sprintf(s->output_buf + written, \"\\n\");\n-    lp_io_write(lp->gid, (char*)\"dragonfly-link-stats\", written, s->output_buf);\n+    lp_io_write(lp->gid, (char*)\"dragonfly-router-stats\", written, s->output_buf);\n \n-    /*if(!s->router_id)\n+    written = 0;\n+    if(!s->router_id)\n     {\n         written = sprintf(s->output_buf, \"# Format <LP ID> <Group ID> <Router ID> <Link Traffic per router port(s)>\");\n         written += sprintf(s->output_buf + written, \"# Router ports in the order: %d green links, %d black links %d global channels \\n\", \n@@ -2499,13 +2415,6 @@ void dragonfly_custom_router_final(router_state * s,\n         written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n \n     lp_io_write(lp->gid, (char*)\"dragonfly-router-traffic\", written, s->output_buf2);\n-    */\n-    if (!g_tw_mynode) {\n-        if (s->router_id == 0) {\n-            if (PRINT_CONFIG) \n-                dragonfly_print_params(s->params);\n-        }\n-    }\n }\n \n static vector<int> get_intra_router(router_state * s, int src_router_id, int dest_router_id, int num_rtrs_per_grp)\n@@ -2524,7 +2433,6 @@ static vector<int> get_intra_router(router_state * s, int src_router_id, int des\n        /* If no direct connection exists then find an intermediate connection */\n        if(curMap.find(dest_rel_id) == curMap.end())\n        {\n-         assert(0);\n          int src_col = src_rel_id % s->params->num_router_cols;\n          int src_row = src_rel_id / s->params->num_router_cols;\n \n@@ -2561,18 +2469,6 @@ static vector<int> get_intra_router(router_state * s, int src_router_id, int des\n        }\n     return intersection;\n }\n-int find_chan(int router_id,\n-        int dest_grp_id,\n-        int num_routers)\n-{\n-    int my_grp_id = router_id / num_routers;\n-    for(int i = 0; i < connectionList[my_grp_id][dest_grp_id].size(); i++)\n-    {\n-        if(connectionList[my_grp_id][dest_grp_id][i] == router_id)\n-            return i;\n-    }\n-    return -1;\n-}\n /* get the next stop for the current packet\n  * determines if it is a router within a group, a router in another group\n  * or the destination terminal */\n@@ -2583,8 +2479,7 @@ get_next_stop(router_state * s,\n \t\t      terminal_custom_message * msg, \n \t\t      int dest_router_id,\n               int adap_chan,\n-              int do_chan_selection, \n-              int get_direct_con)\n+              int do_chan_selection)\n {\n    int dest_lp;\n    tw_lpid router_dest_id;\n@@ -2608,7 +2503,6 @@ get_next_stop(router_state * s,\n        bf->c19 = 1;\n        vector<int> next_stop = get_intra_router(s, local_router_id, dest_router_id, s->params->num_routers);\n        assert(!next_stop.empty());\n-       assert(next_stop.size() == 1);\n        select_chan = tw_rand_integer(lp->rng, 0, next_stop.size() - 1);\n \n        codes_mapping_get_lp_id(lp_group_name, LP_CONFIG_NM_ROUT, s->anno, 0, next_stop[select_chan] / num_routers_per_mgrp,\n@@ -2632,34 +2526,23 @@ get_next_stop(router_state * s,\n             select_chan = adap_chan;\n         else\n         {\n-            /* Only for non-minimal routes, direct connections are preferred\n-             * (global ports) */\n-            if(get_direct_con)\n-            {\n-              if(interGroupLinks[s->router_id][dest_group_id].size() > 1)\n-              select_chan = find_chan(s->router_id, dest_group_id, s->params->num_routers); \n-              assert(select_chan >= 0);\n-            }\n-            else\n-            {\n-                bf->c16 = 1;\n-                select_chan = tw_rand_integer(lp->rng, 0, connectionList[my_grp_id][dest_group_id].size() - 1);\n-            }\n+            bf->c19 = 1;\n+            select_chan = tw_rand_integer(lp->rng, 0, connectionList[my_grp_id][dest_group_id].size() - 1);\n         }\n-           dest_lp = connectionList[my_grp_id][dest_group_id][select_chan];\n+\n+        dest_lp = connectionList[my_grp_id][dest_group_id][select_chan];\n+   \n         //printf(\"\\n my grp %d dest router %d dest_lp %d rid %d chunk id %d\", my_grp_id, dest_router_id, dest_lp, s->router_id, msg->chunk_id);\n         msg->saved_src_dest = dest_lp;\n+        msg->saved_src_chan = select_chan;\n   }\n   /* Get the number of global channels connecting the origin and destination\n    * groups */\n-  //assert(msg->saved_src_chan >= 0 && msg->saved_src_chan < connectionList[my_grp_id][dest_group_id].size());\n+  assert(msg->saved_src_chan >= 0 && msg->saved_src_chan < connectionList[my_grp_id][dest_group_id].size());\n \n   if(s->router_id == msg->saved_src_dest)\n   {\n-        bf->c17 = 1;\n-        select_chan = tw_rand_integer(lp->rng, 0, interGroupLinks[s->router_id][dest_group_id].size() - 1);\n-        bLink bl = interGroupLinks[s->router_id][dest_group_id][select_chan];\n-        dest_lp = bl.dest;\n+      dest_lp = connectionList[dest_group_id][my_grp_id][msg->saved_src_chan];\n   }\n   else\n   {\n@@ -2719,7 +2602,7 @@ get_output_port( router_state * s,\n \n          rand_offset = tw_rand_integer(lp->rng, 0, interGroupLinks[src_router][intm_grp_id].size()-1);\n \n-         assert(rand_offset >= 0 && rand_offset < s->params->num_global_channels);\n+         assert(rand_offset >= 0);\n \n          bLink bl = interGroupLinks[src_router][intm_grp_id][rand_offset];\n          int channel_id = bl.offset;\n@@ -2737,20 +2620,20 @@ get_output_port( router_state * s,\n         int dest_col = intra_rtr_id % p->num_router_cols;\n         int dest_row = intra_rtr_id / p->num_router_cols;\n \n-       if(src_row == dest_row)\n+        if(src_col == dest_col)\n+        {\n+            int offset = tw_rand_integer(lp->rng, 0, p->num_col_chans -1);\n+            output_port = p->num_router_cols * p->num_row_chans + dest_row * p->num_col_chans + offset;\n+            assert(output_port < p->intra_grp_radix);\n+        }\n+        else\n+            if(src_row == dest_row)\n         {\n             int offset = tw_rand_integer(lp->rng, 0, p->num_row_chans -1);\n             output_port = dest_col * p->num_row_chans + offset;   \n             assert(output_port < (s->params->num_router_cols * p->num_row_chans));\n         }\n-        else if(src_col == dest_col)\n-        {\n-            assert(0);\n-            int offset = tw_rand_integer(lp->rng, 0, p->num_col_chans -1);\n-            output_port = (p->num_router_cols * p->num_row_chans) + dest_row * p->num_col_chans + offset;\n-            assert(output_port < p->intra_grp_radix);\n-        }\n-         else\n+            else\n             {\n                 tw_error(TW_LOC, \"\\n Invalid dragonfly connectivity src row %d dest row %d src col %d dest col %d src %d dest %d\",\n                         src_row, dest_row, src_col, dest_col, intragrp_rtr_id, intra_rtr_id);\n@@ -2820,84 +2703,23 @@ static void do_local_adaptive_routing(router_state * s,\n       msg->path_type = NON_MINIMAL;\n   }\n }\n-/* This function gets a randomly selected router from a group with which the\n- * current router has direct connections... */\n-static vector<int> get_indirect_conns(router_state * s, tw_lp * lp, int dest_grp_id)\n-{\n-    map< int, vector<bLink> >  &curMap = interGroupLinks[s->router_id];\n-    map< int, vector<bLink> >::iterator it = curMap.begin();\n-    vector<int> nonmin_ports; \n-    int num_routers = s->params->num_routers;\n-    int dest_idx = tw_rand_integer(lp->rng, 0, num_routers - 1);\n-    \n-    for(; it != curMap.end(); it++) {\n-        if(it->first != dest_grp_id)\n-        {\n-            int grp_id = it->first;\n-            int begin = grp_id * s->params->num_routers;\n-            for(int l = 0; l < it->second.size(); l++)\n-            {\n-                nonmin_ports.push_back(begin + dest_idx);\n-            }\n-        }\n-     }\n-     return nonmin_ports;\n-}\n-static int get_port_score(router_state * s,\n-        int port,\n-        int biase)\n-{\n-    int port_count = 0;\n-\n-    if(port <= 0)\n-       return INT_MAX;\n-    \n-    for(int k = 0; k < s->params->num_vcs; k++)\n-    {\n-        port_count += s->vc_occupancy[port][k];\n-    }\n-    port_count += s->queued_count[port];\n-\n-    if(biase)\n-        port_count = port_count * 2;\n-    return port_count;\n-}\n static int do_global_adaptive_routing( router_state * s,\n                  tw_lp * lp,\n \t\t\t\t terminal_custom_message * msg,\n                  tw_bf * bf,\n \t\t\t\t int dest_router_id,\n-                 int intm_id_a,\n-                 int intm_id_b) {\n+                 int intm_id) {\n   int next_chan = -1;\n   // decide which routing to take\n   // get the queue occupancy of both the minimal and non-minimal output ports \n+ \n+  int dest_grp_id = dest_router_id / s->params->num_routers;\n+  int intm_grp_id = intm_id / s->params->num_routers;\n+  int my_grp_id = s->router_id / s->params->num_routers;\n \n-  bool local_min = false;\n-  int num_routers = s->params->num_routers;\n-  int dest_grp_id = dest_router_id / num_routers;\n-  int intm_grp_id_a = intm_id_a / num_routers;\n-  int intm_grp_id_b = intm_id_b / num_routers;\n-  \n-  assert(intm_grp_id_a >= 0 && intm_grp_id_b >=0);\n-\n-  int my_grp_id = s->router_id / num_routers;\n-\n-  int num_min_chans;\n-  vector<int> direct_intra;\n-  if(my_grp_id == dest_grp_id)\n-  {\n-       local_min = true;\n-       direct_intra = get_intra_router(s, s->router_id, dest_router_id, num_routers); \n-       num_min_chans = direct_intra.size();\n-  }\n-  else\n-  {\n-      num_min_chans = connectionList[my_grp_id][dest_grp_id].size();\n-  }\n-  int num_nonmin_chans_a = connectionList[my_grp_id][intm_grp_id_a].size();\n-  int num_nonmin_chans_b = connectionList[my_grp_id][intm_grp_id_b].size();\n-  int min_chan_a = -1, min_chan_b = -1, nonmin_chan_a = -1, nonmin_chan_b = -1;\n+  int num_min_chans = connectionList[my_grp_id][dest_grp_id].size();\n+  int num_nonmin_chans = connectionList[my_grp_id][intm_grp_id].size();\n+  int min_chan_a, min_chan_b, nonmin_chan_a, nonmin_chan_b;\n   int min_rtr_a, min_rtr_b, nonmin_rtr_a, nonmin_rtr_b;\n   vector<int> dest_rtr_as, dest_rtr_bs;\n   int min_port_a, min_port_b, nonmin_port_a, nonmin_port_b;\n@@ -2912,45 +2734,31 @@ static int do_global_adaptive_routing( router_state * s,\n       min_chan_b = (min_chan_a + 1) % num_min_chans;\n \n   int chana1 = 0;\n+  //chana1 = tw_rand_integer(lp->rng, 0, interGroupLinks[s->router_id][dest_grp_id].size()-1);\n+  //chana1=0;\n \n-  assert(min_chan_a >= 0);\n-  if(!local_min)\n-  {\n-    min_rtr_a = connectionList[my_grp_id][dest_grp_id][min_chan_a];\n-    noIntraA = false;\n-    if(min_rtr_a == s->router_id) {\n-        noIntraA = true;\n-        min_rtr_a = interGroupLinks[s->router_id][dest_grp_id][chana1].dest;\n-    }\n-    if(num_min_chans > 1) {\n-        assert(min_chan_b >= 0);\n-        noIntraB = false;\n-        min_rtr_b = connectionList[my_grp_id][dest_grp_id][min_chan_b];\n+  min_rtr_a = connectionList[my_grp_id][dest_grp_id][min_chan_a];\n+  noIntraA = false;\n+  if(min_rtr_a == s->router_id) {\n+    noIntraA = true;\n+    min_rtr_a = interGroupLinks[s->router_id][dest_grp_id][chana1].dest;\n+  }\n+  if(num_min_chans > 1) {\n+    noIntraB = false;\n+    min_rtr_b = connectionList[my_grp_id][dest_grp_id][min_chan_b];\n     \n-        if(min_rtr_b == s->router_id) {\n-            noIntraB = true;\n-            min_rtr_b = interGroupLinks[s->router_id][dest_grp_id][chana1].dest;\n-        }\n-    }\n-  \n-    if(noIntraA) {\n-        dest_rtr_as.push_back(min_rtr_a);\n-    } else {\n-        dest_rtr_as = get_intra_router(s, s->router_id, min_rtr_a, s->params->num_routers);\n+    if(min_rtr_b == s->router_id) {\n+      noIntraB = true;\n+      min_rtr_b = interGroupLinks[s->router_id][dest_grp_id][chana1].dest;\n     }\n   }\n-  else\n-  {\n-      noIntraA = true;\n-      noIntraB = true;\n-\n-      assert(direct_intra.size() > 0);\n-      min_rtr_a = direct_intra[min_chan_a]; \n-      dest_rtr_as.push_back(min_rtr_a);\n-\n-      if(num_min_chans > 1)\n-          min_rtr_b = direct_intra[min_chan_b];\n+  \n+  if(noIntraA) {\n+    dest_rtr_as.push_back(min_rtr_a);\n+  } else {\n+    dest_rtr_as = get_intra_router(s, s->router_id, min_rtr_a, s->params->num_routers);\n   }\n+  \n   int dest_rtr_b_sel;\n   int dest_rtr_a_sel = tw_rand_integer(lp->rng, 0, dest_rtr_as.size() - 1);\n \n@@ -2973,51 +2781,29 @@ static int do_global_adaptive_routing( router_state * s,\n     min_port_b = get_output_port(s, msg, lp, bf, min_rtr_b_id);\n   }\n \n-  /* if a direct global channel exists for non-minimal route in the source group then give a priority to that. */\n-  if(msg->my_l_hop == max_lvc_src_g)\n-  {\n-    assert(routing == PROG_ADAPTIVE);\n-    nonmin_chan_a = find_chan(s->router_id, intm_grp_id_a, num_routers);\n-    nonmin_chan_b = find_chan(s->router_id, intm_grp_id_b, num_routers);\n-    assert(nonmin_chan_a >= 0 && nonmin_chan_b >= 0);\n-  }\n   /* two possible nonminimal routes */\n-  int rand_a = tw_rand_integer(lp->rng, 0, num_nonmin_chans_a - 1);\n-  int rand_b = tw_rand_integer(lp->rng, 0, num_nonmin_chans_b - 1);\n+  nonmin_chan_a = tw_rand_integer(lp->rng, 0, num_nonmin_chans - 1);\n+  nonmin_chan_b = tw_rand_integer(lp->rng, 0, num_nonmin_chans - 1);\n \n+  if(nonmin_chan_a == nonmin_chan_b && num_nonmin_chans > 1)\n+      nonmin_chan_b = (nonmin_chan_a + 1) % num_nonmin_chans;\n+\n+  nonmin_rtr_a = connectionList[my_grp_id][intm_grp_id][nonmin_chan_a]; \n   noIntraA = false;\n-  if(nonmin_chan_a != -1) {\n-    /* TODO: For a 2-D dragonfly, this can be more than one link. */\n+  if(nonmin_rtr_a == s->router_id) {\n     bf->c25=1;\n     noIntraA = true;\n-    nonmin_rtr_a = interGroupLinks[s->router_id][intm_grp_id_a][0].dest;\n+    nonmin_rtr_a = interGroupLinks[s->router_id][intm_grp_id][0].dest;\n   }\n-  else\n-  {\n-    assert(rand_a >= 0);\n-    nonmin_chan_a = rand_a;\n-    nonmin_rtr_a = connectionList[my_grp_id][intm_grp_id_a][rand_a];\n-    if(nonmin_rtr_a == s->router_id)\n-        noIntraA = true;\n-  }\n-  assert(nonmin_chan_a >= 0);\n   \n-  if(num_nonmin_chans_b > 0) {\n+  if(num_nonmin_chans > 1) {\n+    nonmin_rtr_b = connectionList[my_grp_id][intm_grp_id][nonmin_chan_b];\n     noIntraB = false;\n-    if(nonmin_chan_b != -1) {\n+    if(nonmin_rtr_b == s->router_id) {\n       bf->c26=1;\n       noIntraB = true;\n-      nonmin_rtr_b = interGroupLinks[s->router_id][intm_grp_id_b][0].dest;\n-    }\n-    else\n-    {\n-       assert(rand_b >= 0);\n-       nonmin_chan_b = rand_b;\n-       nonmin_rtr_b = connectionList[my_grp_id][intm_grp_id_b][rand_b];\n-       if(nonmin_rtr_b == s->router_id)\n-           noIntraB = true;\n+      nonmin_rtr_b = interGroupLinks[s->router_id][intm_grp_id][0].dest;\n     }\n-    assert(nonmin_chan_b >= 0);\n   }\n \n   if(noIntraA) {\n@@ -3032,9 +2818,7 @@ static int do_global_adaptive_routing( router_state * s,\n           dest_rtr_as[dest_rtr_a_sel] % num_routers_per_mgrp, &nonmin_rtr_a_id); \n   nonmin_port_a = get_output_port(s, msg, lp, bf, nonmin_rtr_a_id); \n \n-  assert(nonmin_port_a >= 0);\n-\n-  if(num_nonmin_chans_b > 0)\n+  if(num_nonmin_chans > 1)\n   {\n     bf->c11 = 1;\n     if(noIntraB) {\n@@ -3047,35 +2831,53 @@ static int do_global_adaptive_routing( router_state * s,\n     codes_mapping_get_lp_id(lp_group_name, LP_CONFIG_NM_ROUT, s->anno, 0, dest_rtr_bs[dest_rtr_b_sel] / num_routers_per_mgrp,\n           dest_rtr_bs[dest_rtr_b_sel] % num_routers_per_mgrp, &nonmin_rtr_b_id); \n     nonmin_port_b = get_output_port(s, msg, lp, bf, nonmin_rtr_b_id);\n-    assert(nonmin_port_b >= 0);\n   }\n+  /*randomly select two minimal routes and two non-minimal routes */\n+  /*int minimal_next_stop=get_next_stop(s, lp, msg, MINIMAL, dest_router_id);\n+  minimal_out_port = get_output_port(s, msg, lp, minimal_next_stop);\n+  int nonmin_next_stop = get_next_stop(s, lp, msg, NON_MINIMAL, dest_router_id);\n+  nonmin_out_port = get_output_port(s, msg, lp, nonmin_next_stop);\n+ */\n   int min_port_a_count = 0, min_port_b_count = 0;\n   int nonmin_port_a_count = 0, nonmin_port_b_count = 0;\n \n-  min_port_a_count = get_port_score(s, min_port_a, 0);\n+  for(int k = 0; k < s->params->num_vcs; k++)\n+  {\n+    min_port_a_count += s->vc_occupancy[min_port_a][k];\n+  }\n+  min_port_a_count += s->queued_count[min_port_a];\n   \n   if(num_min_chans > 1)\n   {\n-      min_port_b_count = get_port_score(s, min_port_b, 0);\n+      for(int k = 0; k < s->params->num_vcs; k++)\n+      {\n+        min_port_b_count += s->vc_occupancy[min_port_b][k];\n+      }\n+      min_port_b_count += s->queued_count[min_port_b];\n   }\n   \n-  nonmin_port_a_count = get_port_score(s, nonmin_port_a, BIAS_MIN);\n+  for(int k = 0; k < s->params->num_vcs; k++)\n+  {\n+    nonmin_port_a_count += s->vc_occupancy[nonmin_port_a][k];\n+  }\n+  nonmin_port_a_count += s->queued_count[nonmin_port_a];\n \n-  if(num_nonmin_chans_b > 0)\n+  if(num_nonmin_chans > 1)\n   {\n-      assert(nonmin_port_b >= 0);\n-      nonmin_port_b_count += get_port_score(s, nonmin_port_b, BIAS_MIN);\n+      for(int k = 0; k < s->params->num_vcs; k++)\n+      {\n+        nonmin_port_b_count += s->vc_occupancy[nonmin_port_b][k];\n+      }\n+      nonmin_port_b_count += s->queued_count[nonmin_port_b];\n   }\n   int next_min_stop = -1, next_nonmin_stop = -1;\n   int next_min_count = -1, next_nonmin_count = -1;\n \n   /* First compare which of the nonminimal ports has less congestions */\n-  int sel_nonmin = 0;\n-  if(num_nonmin_chans_b > 0 && nonmin_port_a_count > nonmin_port_b_count)\n+  if(num_nonmin_chans > 1 && nonmin_port_a_count > nonmin_port_b_count)\n   {\n       next_nonmin_count = nonmin_port_b_count;\n       next_nonmin_stop = nonmin_chan_b;\n-      sel_nonmin = 1;\n   }\n   else\n   {\n@@ -3094,17 +2896,16 @@ static int do_global_adaptive_routing( router_state * s,\n       next_min_stop = min_chan_a;\n   }\n \n+  if(BIAS_MIN == 1)\n+  {\n+\tnext_nonmin_count = next_nonmin_count * 2;\n+  }\n   /* Now compare the least congested minimal and non-minimal routes */\n   if(next_min_count > adaptive_threshold && next_min_count > next_nonmin_count)\n   {\n //      printf(\"\\n Minimal chan %d occupancy %d non-min %d occupancy %d \", next_min_stop, next_min_count, next_nonmin_stop, next_nonmin_count);\n       next_chan = next_nonmin_stop;\n       msg->path_type = NON_MINIMAL;\n-\n-      if(sel_nonmin)\n-        msg->intm_rtr_id = intm_id_b;\n-      else\n-        msg->intm_rtr_id = intm_id_a;\n   }\n   else\n   {\n@@ -3129,83 +2930,6 @@ static int do_global_adaptive_routing( router_state * s,\n   }*/\n }\n \n-\n-static void router_verify_valid_receipt(router_state *s, tw_bf *bf, terminal_custom_message *msg, tw_lp *lp)\n-{\n-    if (msg->my_N_hop > s->params->max_hops_notify)\n-    {\n-        printf(\"Router received a packet with %d hops so far! (Notify on > than %d)\\n\",msg->my_N_hop, s->params->max_hops_notify);\n-    }\n-\n-\n-    bool has_valid_connection;\n-    if (msg->last_hop == TERMINAL) {\n-        tw_lpid src_term_lpgid = msg->src_terminal_id;\n-        int src_term_rel_id;\n-\n-        try {\n-            src_term_rel_id = codes_mapping_get_lp_relative_id(src_term_lpgid,0,0);\n-        }\n-        catch (...) {\n-            tw_error(TW_LOC, \"\\nRouter Receipt Verify: Codes Mapping Get LP Rel ID Failure - Terminal\");\n-        }\n-\n-        has_valid_connection = (s->router_id == (src_term_rel_id / s->params->num_cn)); //a router can only receive a packet from a terminal if that terminal belongs to it\n-\n-        if (!has_valid_connection) {\n-            tw_error(TW_LOC, \"\\nRouter received packet from non-existent connection - Terminal\\n\");\n-        }\n-    \n-    }\n-    else if (msg->last_hop == LOCAL) {\n-        int rel_id;\n-\n-        try {\n-            rel_id = codes_mapping_get_lp_relative_id(msg->intm_lp_id,0,0);\n-        }\n-        catch (...) {\n-            tw_error(TW_LOC, \"\\nRouter Receipt Verify: Codes Mapping Get LP Rel ID Failure - Local\");\n-        }\n-\n-        int my_loc_id = s->router_id % s->params->num_routers;\n-        int intm_loc_id = rel_id % s->params->num_routers;\n-\n-        if (intraGroupLinks[my_loc_id][intm_loc_id].size() > 0)\n-            has_valid_connection = true;\n-        else\n-            has_valid_connection = false;\n-        \n-        if (!has_valid_connection) {\n-            tw_error(TW_LOC, \"\\nRouter received packet from non-existent connection - Local\\n\");\n-        }\n-    }\n-    else if (msg->last_hop == GLOBAL) {\n-        int rel_id;\n-\n-        try {\n-            rel_id = rel_id = codes_mapping_get_lp_relative_id(msg->intm_lp_id,0,0);\n-        }\n-        catch (...) {\n-            tw_error(TW_LOC, \"\\nRouter Receipt Verify: Codes Mapping Get LP Rel ID Failure - Global\");\n-        }\n-\n-        int rel_id_grp_id = rel_id / s->params->num_routers;\n-\n-        if (interGroupLinks[s->router_id][rel_id_grp_id].size() > 0)\n-            has_valid_connection = true;\n-        else\n-            has_valid_connection = false;\n-        \n-        if (!has_valid_connection) {\n-            tw_error(TW_LOC, \"\\nRouter received packet from non-existent connection - Global\\n\");\n-        }\n-    }\n-    else {\n-        tw_error(TW_LOC, \"\\nUnspecified msg->last_hop when received by a router\\n\");\n-    }\n-    \n-}\n-\n static void router_packet_receive_rc(router_state * s,\n         tw_bf * bf,\n         terminal_custom_message * msg,\n@@ -3217,27 +2941,15 @@ static void router_packet_receive_rc(router_state * s,\n     int output_port = msg->saved_vc;\n     int output_chan = msg->saved_channel;\n \n-    if(bf->c15)\n-    {\n-        tw_rand_reverse_unif(lp->rng);\n-    }\n-    if(bf->c18)\n-    {\n-        tw_rand_reverse_unif(lp->rng);\n-        tw_rand_reverse_unif(lp->rng);\n-    }\n-    if(bf->c3)\n-    {\n-        tw_rand_reverse_unif(lp->rng);\n-        tw_rand_reverse_unif(lp->rng);\n-        tw_rand_reverse_unif(lp->rng);\n-    }\n+    tw_rand_reverse_unif(lp->rng);\n \n     if(bf->c20)\n     {\n         for(int i = 0; i < 8; i++)\n             tw_rand_reverse_unif(lp->rng);\n             \n+        //tw_rand_reverse_unif(lp->rng);\n+    \n         if(bf->c10)\n         {\n             tw_rand_reverse_unif(lp->rng);\n@@ -3256,14 +2968,9 @@ static void router_packet_receive_rc(router_state * s,\n     }\n     if(bf->c19)\n         tw_rand_reverse_unif(lp->rng);\n-    if(bf->c16)\n-        tw_rand_reverse_unif(lp->rng);\n-    if(bf->c17)\n-        tw_rand_reverse_unif(lp->rng);\n     if(bf->c21)\n         tw_rand_reverse_unif(lp->rng);\n \n-\n     tw_rand_reverse_unif(lp->rng);\n     if(bf->c2) {\n         tw_rand_reverse_unif(lp->rng);\n@@ -3276,6 +2983,10 @@ static void router_packet_receive_rc(router_state * s,\n         }\n       }\n       if(bf->c4) {\n+          if(bf->c22)\n+          {\n+            s->last_buf_full[output_port][output_chan] = msg->saved_busy_time;\n+          }\n       delete_terminal_custom_message_list(return_tail(s->queued_msgs[output_port], \n           s->queued_msgs_tail[output_port], output_chan));\n       s->queued_count[output_port] -= s->params->chunk_size; \n@@ -3289,33 +3000,32 @@ router_packet_receive( router_state * s,\n \t\t\tterminal_custom_message * msg, \n \t\t\ttw_lp * lp )\n {\n-  router_verify_valid_receipt(s, bf, msg, lp);\n-\n   router_ecount++;\n \n   tw_stime ts;\n \n-  int num_routers = s->params->num_routers;\n-  int num_groups = s->params->num_groups;\n-  int total_routers = s->params->total_routers;\n-\n   int next_stop = -1, output_port = -1, output_chan = -1, adap_chan = -1;\n   int dest_router_id = codes_mapping_get_lp_relative_id(msg->dest_terminal_id, 0, 0) / s->params->num_cn;\n-  int local_grp_id = s->router_id / num_routers;\n-  int src_grp_id = msg->origin_router_id / num_routers;\n-  int dest_grp_id = dest_router_id / num_routers;\n-  int intm_router_id, intm_router_id_b;\n+  int local_grp_id = s->router_id / s->params->num_routers;\n+  int src_grp_id = msg->origin_router_id / s->params->num_routers;\n+  int dest_grp_id = dest_router_id / s->params->num_routers;\n+  int intm_router_id;\n   short prev_path_type = 0, next_path_type = 0;\n \n-  terminal_custom_message_list * cur_chunk = (terminal_custom_message_list*)calloc(1, sizeof(terminal_custom_message_list));\n+  terminal_custom_message_list * cur_chunk = (terminal_custom_message_list*)calloc(sizeof(terminal_custom_message_list), 1);\n   init_terminal_custom_message_list(cur_chunk, msg);\n   \n+  if(routing == MINIMAL || \n+     routing == NON_MINIMAL)\t\n+   cur_chunk->msg.path_type = routing; /*defaults to the routing algorithm if we \n+                                don't have adaptive or progressive adaptive routing here*/\n+       \n+//  printf(\"\\n Packet %llu source %d arrived at router %d \", msg->packet_ID, msg->src_terminal_id, s->router_id);\n   /* Set the default route as minimal for prog-adaptive */\n-  if(cur_chunk->msg.last_hop == TERMINAL)\n+  if((routing == PROG_ADAPTIVE || routing == ADAPTIVE) && cur_chunk->msg.last_hop == TERMINAL)\n       cur_chunk->msg.path_type = MINIMAL;\n \n   /* for prog-adaptive routing, record the current route of packet */\n-  int get_direct_con = 0;\n   prev_path_type = cur_chunk->msg.path_type;\n \n   /* Here we check for local or global adaptive routing. If destination router\n@@ -3323,46 +3033,20 @@ router_packet_receive( router_state * s,\n    * intermediate router ID which is in the same group. */\n   if(src_grp_id != dest_grp_id)\n   {\n-      if(cur_chunk->msg.my_l_hop == max_lvc_src_g)\n-      {\n-        bf->c3 = 1;\n-        vector<int> direct_rtrs = get_indirect_conns(s, lp, dest_grp_id);\n-        assert(direct_rtrs.size() > 0);\n-        int indxa = tw_rand_integer(lp->rng, 0, direct_rtrs.size() - 1); \n-        intm_router_id = direct_rtrs[indxa];\n-        int indxb = tw_rand_integer(lp->rng, 0, direct_rtrs.size() - 1); \n-        intm_router_id_b = direct_rtrs[indxb];\n-        assert(intm_router_id / num_routers != local_grp_id);\n-        assert(intm_router_id_b / num_routers != local_grp_id);\n-      }\n-      else\n-      {\n-          bf->c18 = 1;\n-          intm_router_id = tw_rand_integer(lp->rng, 0, total_routers - 1);\n-          intm_router_id_b = tw_rand_integer(lp->rng, 0, total_routers - 1); \n-          if((intm_router_id/num_routers) == local_grp_id)\n-                intm_router_id = (intm_router_id + num_routers) % total_routers; \n-        \n-         if((intm_router_id_b/num_routers) == local_grp_id)\n-         {\n-            intm_router_id_b = (intm_router_id_b + num_routers) % total_routers;\n-         }\n-         \n-         assert(intm_router_id / num_routers != local_grp_id);\n-         assert(intm_router_id_b / num_routers != local_grp_id);\n-      }\n+      intm_router_id = tw_rand_integer(lp->rng, 0, s->params->total_routers - 1); \n   }\n   else\n-  {\n-     bf->c15 = 1;\n-    intm_router_id = (src_grp_id * num_routers) + \n-                      (((s->router_id % num_routers) + \n-                       tw_rand_integer(lp->rng, 1, num_routers - 1)) % num_routers);\n-  }\n-  \n-  if(routing == NON_MINIMAL)\n-      cur_chunk->msg.path_type = NON_MINIMAL;\n-  \n+    intm_router_id = (src_grp_id * s->params->num_routers) + \n+                      (((s->router_id % s->params->num_routers) + \n+                       tw_rand_integer(lp->rng, 1, s->params->num_routers - 1)) % s->params->num_routers);\n+\n+  /* For global adaptive routing, we make sure that a different group\n+   * is selected. For local adaptive routing, if the same router as self is\n+   * selected then we choose the neighboring router. */\n+  if(src_grp_id != dest_grp_id \n+      && (intm_router_id / s->params->num_routers) == local_grp_id)\n+    intm_router_id = (s->router_id + s->params->num_routers) % s->params->total_routers;\n+\n   /* progressive adaptive routing is only triggered when packet has to traverse a\n    * global channel. It doesn't make sense to use it within a group */\n   if(dest_grp_id != src_grp_id && \n@@ -3370,16 +3054,14 @@ router_packet_receive( router_state * s,\n               && routing == ADAPTIVE) \n           || (cur_chunk->msg.path_type == MINIMAL \n               && routing == PROG_ADAPTIVE \n-//              && s->router_id != dest_router_id)))\n-            && local_grp_id == src_grp_id)))\n+              && s->group_id == src_grp_id)))\n   {\n        bf->c20 = 1;\n-       adap_chan = do_global_adaptive_routing(s, lp, &(cur_chunk->msg), bf, dest_router_id, intm_router_id, intm_router_id_b);\n+       adap_chan = do_global_adaptive_routing(s, lp, &(cur_chunk->msg), bf, dest_router_id, intm_router_id);\n   }\n   /* If destination router is in the same group then local adaptive routing is\n    * triggered */\n \n-\n   if(cur_chunk->msg.origin_router_id == dest_router_id)\n       cur_chunk->msg.path_type = MINIMAL;\n \n@@ -3389,8 +3071,17 @@ router_packet_receive( router_state * s,\n           && cur_chunk->msg.last_hop == TERMINAL)\n   {\n       \n+      if(DF_DALLY == 0)\n+      {\n         bf->c6 = 1;\n         do_local_adaptive_routing(s, lp, &(cur_chunk->msg), bf, dest_router_id, intm_router_id);\n+      }\n+      else if(DF_DALLY == 1)\n+      {\n+        cur_chunk->msg.path_type = MINIMAL;\n+      }\n+      else\n+          tw_error(TW_LOC, \"\\n topology type not set correctly! \");\n   }\n \n   next_path_type = cur_chunk->msg.path_type;\n@@ -3401,12 +3092,12 @@ router_packet_receive( router_state * s,\n   assert(cur_chunk->msg.path_type == MINIMAL || cur_chunk->msg.path_type == NON_MINIMAL);\n  \n   /* If non-minimal, set the random destination */\n-  if(cur_chunk->msg.last_hop == TERMINAL \n-          && cur_chunk->msg.path_type == NON_MINIMAL\n-          && cur_chunk->msg.intm_rtr_id == -1)\n+  if((cur_chunk->msg.last_hop == TERMINAL \n+              || (routing == PROG_ADAPTIVE && s->group_id == src_grp_id && prev_path_type != next_path_type))\n+          && cur_chunk->msg.path_type == NON_MINIMAL)\n   {\n-    cur_chunk->msg.nonmin_done = 0;\n     cur_chunk->msg.intm_rtr_id = intm_router_id;\n+    cur_chunk->msg.nonmin_done = 0;\n   }\n \n   if(cur_chunk->msg.path_type == NON_MINIMAL)\n@@ -3415,6 +3106,7 @@ router_packet_receive( router_state * s,\n       * If not, set the non-minimal destination.*/\n     if(s->router_id == cur_chunk->msg.intm_rtr_id)\n     {\n+        //assert(cur_chunk->msg.my_l_hop <= 6);\n         cur_chunk->msg.nonmin_done = 1;\n     }\n     else if(cur_chunk->msg.nonmin_done == 0)\n@@ -3424,19 +3116,14 @@ router_packet_receive( router_state * s,\n     }\n   }\n \n-if(cur_chunk->msg.path_type == NON_MINIMAL)\n-{\n-      if((cur_chunk->msg.my_l_hop == max_lvc_src_g && cur_chunk->msg.my_g_hop == min_gvc_src_g)\n-|| (cur_chunk->msg.my_l_hop == max_lvc_intm_g && cur_chunk->msg.my_g_hop == min_gvc_intm_g))\n-      get_direct_con = 1;\n-}\n   /* If the packet route has just changed to non-minimal with prog-adaptive\n    * routing, we have to compute the next stop based on that */\n   int do_chan_selection = 0;\n   if(routing == PROG_ADAPTIVE && prev_path_type != next_path_type && s->group_id == src_grp_id)\n+  {\n       do_chan_selection = 1;\n-  \n-  next_stop = get_next_stop(s, lp, bf, &(cur_chunk->msg), dest_router_id, adap_chan, do_chan_selection, get_direct_con);\n+  }\n+  next_stop = get_next_stop(s, lp, bf, &(cur_chunk->msg), dest_router_id, adap_chan, do_chan_selection);\n \n   if(cur_chunk->msg.packet_ID == LLU(TRACK_PKT) && cur_chunk->msg.src_terminal_id == T_ID)\n     printf(\"\\n Packet %llu arrived at router %u next stop %d final stop %d local hops %d global hops %d\", cur_chunk->msg.packet_ID, s->router_id, next_stop, dest_router_id, cur_chunk->msg.my_l_hop, cur_chunk->msg.my_g_hop);\n@@ -3450,24 +3137,39 @@ if(cur_chunk->msg.path_type == NON_MINIMAL)\n \n   output_chan = 0;\n   if(output_port < s->params->intra_grp_radix) {\n-   output_chan = msg->my_l_hop;\n-  // if(DF_DALLY == 1)\n-  // {\n-  //  if(cur_chunk->msg.my_g_hop == 1 && cur_chunk->msg.last_hop == GLOBAL) {\n-  //      output_chan = 1;\n-  //  } else if (cur_chunk->msg.my_g_hop == 2) {\n-  //      output_chan = 3;\n-  //  }\n-  // }\n-  //else {\n-      /* TODO: Recheck VC count after things are in order for a 2-D dragonfly. */\n-  //  if(cur_chunk->msg.my_g_hop == 1 && cur_chunk->msg.last_hop == GLOBAL) {\n-    //    output_chan = 2;\n-   // }\n-   // else if (cur_chunk->msg.my_g_hop == 2 && cur_chunk->msg.last_hop == GLOBAL) {\n-     //   output_chan = 6;\n-    //}\n-  //}\n+   if(DF_DALLY == 0)\n+   {\n+    if(cur_chunk->msg.my_g_hop == 1) {\n+      if(routing == PROG_ADAPTIVE && cur_chunk->msg.my_l_hop < 4) {\n+        cur_chunk->msg.my_l_hop = 4;\n+      } else if(cur_chunk->msg.my_l_hop < 2) {\n+        cur_chunk->msg.my_l_hop = 2;\n+      }\n+    } else if (cur_chunk->msg.my_g_hop == 2) {\n+      if(routing == PROG_ADAPTIVE && cur_chunk->msg.my_l_hop < 6) {\n+        cur_chunk->msg.my_l_hop = 6;\n+      } else if(cur_chunk->msg.my_l_hop < 4) {\n+        cur_chunk->msg.my_l_hop = 4;\n+      }\n+    }\n+   }\n+  else {\n+    if(cur_chunk->msg.my_g_hop == 1) {\n+        if(routing == PROG_ADAPTIVE && cur_chunk->msg.my_l_hop < 2){\n+            cur_chunk->msg.my_l_hop = 2;\n+        } else if(cur_chunk->msg.my_l_hop < 1){\n+            cur_chunk->msg.my_l_hop = 1;\n+        }\n+    }\n+    else if (cur_chunk->msg.my_g_hop == 2) {\n+     if(routing == PROG_ADAPTIVE && cur_chunk->msg.my_l_hop < 4) {\n+         cur_chunk->msg.my_l_hop = 4;\n+     }\n+     else if(cur_chunk->msg.my_l_hop < 3)\n+        cur_chunk->msg.my_l_hop = 3;\n+    }\n+  }\n+    output_chan = cur_chunk->msg.my_l_hop;\n     max_vc_size = s->params->local_vc_size;\n     cur_chunk->msg.my_l_hop++;\n   } else if(output_port < (s->params->intra_grp_radix + \n@@ -3491,7 +3193,7 @@ if(cur_chunk->msg.path_type == NON_MINIMAL)\n \n   if(msg->remote_event_size_bytes > 0) {\n     void *m_data_src = model_net_method_get_edata(DRAGONFLY_CUSTOM_ROUTER, msg);\n-    cur_chunk->event_data = (char*)calloc(1, msg->remote_event_size_bytes);\n+    cur_chunk->event_data = (char*)malloc(msg->remote_event_size_bytes);\n     memcpy(cur_chunk->event_data, m_data_src, msg->remote_event_size_bytes);\n   }\n \n@@ -3523,6 +3225,17 @@ if(cur_chunk->msg.path_type == NON_MINIMAL)\n     append_to_terminal_custom_message_list( s->queued_msgs[output_port], \n       s->queued_msgs_tail[output_port], output_chan, cur_chunk);\n     s->queued_count[output_port] += s->params->chunk_size;\n+\n+    /* a check for pending msgs is non-empty then we dont set anything. If\n+     * that is empty then we check if last_buf_full is set or not. If already\n+     * set then we don't overwrite it. If two packets arrive next to each other\n+     * then the first person should be setting it. */\n+    if(s->pending_msgs[output_port][output_chan] == NULL && s->last_buf_full[output_port][output_chan] == 0.0)\n+          {\n+            bf->c22 = 1;\n+            msg->saved_busy_time = s->last_buf_full[output_port][output_chan];\n+            s->last_buf_full[output_port][output_chan] = tw_now(lp);\n+          }\n   }\n \n   msg->saved_vc = output_port;\n@@ -3541,17 +3254,8 @@ static void router_packet_send_rc(router_state * s,\n     int output_chan = msg->saved_channel;\n     if(bf->c1) {\n         s->in_send_loop[output_port] = 1;\n-        if(bf->c2) {\n-            s->last_buf_full[output_port] = msg->saved_busy_time;\n-        }\n         return;  \n     }\n-  if(bf->c8)\n-  {\n-    s->busy_time[output_port] = msg->saved_rcv_time;\n-    s->busy_time_sample[output_port] = msg->saved_sample_time;\n-    s->last_buf_full[output_port] = msg->saved_busy_time;\n-  }\n       \n     tw_rand_reverse_unif(lp->rng);\n       \n@@ -3617,26 +3321,9 @@ router_packet_send( router_state * s,\n   if(cur_entry == NULL) {\n     bf->c1 = 1;\n     s->in_send_loop[output_port] = 0;\n-    if(s->queued_count[output_port] && !s->last_buf_full[output_port]) \n-    {\n-        bf->c2 = 1; \n-        msg->saved_busy_time = s->last_buf_full[output_port];\n-        s->last_buf_full[output_port] = tw_now(lp);\n-    }\n     return;\n   }\n \n-  if(s->last_buf_full[output_port]) \n-  {\n-    bf->c8 = 1;\n-    msg->saved_rcv_time = s->busy_time[output_port]; \n-    msg->saved_busy_time = s->last_buf_full[output_port]; \n-    msg->saved_sample_time = s->busy_time_sample[output_port];  \n-    s->busy_time[output_port] += (tw_now(lp) - s->last_buf_full[output_port]); \n-    s->busy_time_sample[output_port] += (tw_now(lp) - s->last_buf_full[output_port]);\n-    s->last_buf_full[output_port] = 0.0;\n-  }\n-\n   int to_terminal = 1, global = 0;\n   double delay = s->params->cn_delay;\n   double bandwidth = s->params->cn_bandwidth;\n@@ -3780,7 +3467,7 @@ static void router_buf_update_rc(router_state * s,\n         s->busy_time_sample[indx] = msg->saved_sample_time;\n         s->ross_rsample.busy_time[indx] = msg->saved_sample_time;\n         s->busy_time_ross_sample[indx] = msg->saved_busy_time_ross;\n-        s->last_buf_full[indx] = msg->saved_busy_time;\n+        s->last_buf_full[indx][output_chan] = msg->saved_busy_time;\n       }\n       if(bf->c1) {\n         terminal_custom_message_list* head = return_tail(s->pending_msgs[indx],\n@@ -3803,18 +3490,18 @@ static void router_buf_update(router_state * s, tw_bf * bf, terminal_custom_mess\n   int output_chan = msg->output_chan;\n   s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n   \n-  if(s->last_buf_full[indx] > 0.0)\n+  if(s->last_buf_full[indx][output_chan] > 0.0)\n   {\n     bf->c3 = 1;\n     msg->saved_rcv_time = s->busy_time[indx];\n-    msg->saved_busy_time = s->last_buf_full[indx];\n+    msg->saved_busy_time = s->last_buf_full[indx][output_chan];\n     msg->saved_sample_time = s->busy_time_sample[indx];\n     msg->saved_busy_time_ross = s->busy_time_ross_sample[indx];\n-    s->busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n-    s->busy_time_sample[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n-    s->ross_rsample.busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n-    s->busy_time_ross_sample[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n-    s->last_buf_full[indx] = 0.0;\n+    s->busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n+    s->busy_time_sample[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n+    s->ross_rsample.busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n+    s->busy_time_ross_sample[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n+    s->last_buf_full[indx][output_chan] = 0.0;\n   }\n   if(s->queued_msgs[indx][output_chan] != NULL) {\n     bf->c1 = 1;\n@@ -3949,7 +3636,8 @@ tw_lptype dragonfly_custom_lps[] =\n };\n }\n \n-/* For ROSS event tracing */\n+/* ROSS Instrumentation layer */\n+// event tracing callback - used router and terminal LPs\n void custom_dragonfly_event_collect(terminal_custom_message *m, tw_lp *lp, char *buffer, int *collect_flag)\n {\n     (void)lp;\n@@ -3959,6 +3647,7 @@ void custom_dragonfly_event_collect(terminal_custom_message *m, tw_lp *lp, char \n     memcpy(buffer, &type, sizeof(type));\n }\n \n+// GVT-based and real time sampling callback for terminals\n void custom_dragonfly_model_stat_collect(terminal_state *s, tw_lp *lp, char *buffer)\n {\n     (void)lp;\n@@ -4000,6 +3689,7 @@ void custom_dragonfly_model_stat_collect(terminal_state *s, tw_lp *lp, char *buf\n     return;\n }\n \n+// GVT-based and real time sampling callback for routers\n void custom_dfly_router_model_stat_collect(router_state *s, tw_lp *lp, char *buffer)\n {\n     (void)lp;\n@@ -4049,7 +3739,7 @@ static void custom_router_register_model_types(st_model_types *base_type)\n {\n     st_model_type_register(LP_CONFIG_NM_ROUT, base_type);\n }\n-/*** END of ROSS event tracing additions */\n+/*** END of ROSS Instrumentation support */\n \n /* returns the dragonfly lp type for lp registration */\n static const tw_lptype* dragonfly_custom_get_cn_lp_type(void)\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 46,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/dragonfly-plus.C",
                        "old_path": "src/networks/model-net/dragonfly-plus.C",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/dragonfly-plus.C\n+++ b/src/networks/model-net/dragonfly-plus.C\n@@ -312,13 +312,14 @@ struct terminal_state\n     long finished_chunks;\n     long finished_packets;\n \n-    tw_stime *last_buf_full;\n+    tw_stime last_buf_full;\n     tw_stime busy_time;\n \n     tw_stime max_latency;\n     tw_stime min_latency;\n \n     char output_buf[4096];\n+    char output_buf2[4096];\n     /* For LP suspend functionality */\n     int error_ct;\n \n@@ -337,6 +338,14 @@ struct terminal_state\n     /* for logging forward and reverse events */\n     long fwd_events;\n     long rev_events;\n+\n+    // for ROSS Instrumentation\n+    long fin_chunks_ross_sample;\n+    long data_size_ross_sample;\n+    long fin_hops_ross_sample;\n+    tw_stime fin_chunks_time_ross_sample;\n+    tw_stime busy_time_ross_sample;\n+    struct dfly_cn_sample ross_sample;\n };\n \n /* terminal event type (1-4) */\n@@ -451,7 +460,7 @@ struct router_state\n     int *global_channel;\n \n     tw_stime *next_output_available_time;\n-    tw_stime **last_buf_full;\n+    tw_stime *last_buf_full;\n \n     tw_stime *busy_time;\n     tw_stime *busy_time_sample;\n@@ -478,8 +487,41 @@ struct router_state\n \n     long fwd_events;\n     long rev_events;\n+\n+    // for ROSS instrumentation\n+    tw_stime* busy_time_ross_sample;\n+    int64_t * link_traffic_ross_sample;\n+    struct dfly_router_sample ross_rsample;\n };\n \n+/* ROSS model instrumentation */\n+void dfly_plus_event_collect(terminal_plus_message *m, tw_lp *lp, char *buffer, int *collect_flag);\n+void dfly_plus_model_stat_collect(terminal_state *s, tw_lp *lp, char *buffer);\n+void dfly_plus_router_model_stat_collect(router_state *s, tw_lp *lp, char *buffer);\n+static void ross_dfly_plus_rsample_fn(router_state * s, tw_bf * bf, tw_lp * lp, struct dfly_router_sample *sample);\n+static void ross_dfly_plus_rsample_rc_fn(router_state * s, tw_bf * bf, tw_lp * lp, struct dfly_router_sample *sample);\n+static void ross_dfly_plus_sample_fn(terminal_state * s, tw_bf * bf, tw_lp * lp, struct dfly_cn_sample *sample);\n+static void ross_dfly_plus_sample_rc_fn(terminal_state * s, tw_bf * bf, tw_lp * lp, struct dfly_cn_sample *sample);\n+\n+st_model_types dfly_plus_model_types[] = {\n+    {(ev_trace_f) dfly_plus_event_collect,\n+     sizeof(int),\n+     (model_stat_f) dfly_plus_model_stat_collect,\n+     sizeof(tw_lpid) + sizeof(long) * 2 + sizeof(double) + sizeof(tw_stime) *2,\n+     (sample_event_f) ross_dfly_plus_sample_fn,\n+     (sample_revent_f) ross_dfly_plus_sample_rc_fn,\n+     sizeof(struct dfly_cn_sample) } , \n+    {(ev_trace_f) dfly_plus_event_collect,\n+     sizeof(int),\n+     (model_stat_f) dfly_plus_router_model_stat_collect,\n+     0, //updated in router_plus_setup() since it's based on the radix\n+     (sample_event_f) ross_dfly_plus_rsample_fn,\n+     (sample_revent_f) ross_dfly_plus_rsample_rc_fn,\n+     0 } , //updated in router_plus_setup() since it's based on the radix    \n+    {NULL, 0, NULL, 0, NULL, NULL, 0}\n+};\n+/* End of ROSS model instrumentation */\n+\n int dragonfly_plus_get_assigned_router_id(int terminal_id, const dragonfly_plus_param *p);\n \n static short routing = MINIMAL;\n@@ -1159,10 +1201,9 @@ void terminal_plus_init(terminal_state *s, tw_lp *lp)\n     rc_stack_create(&s->st);\n     s->num_vcs = 1;\n     s->vc_occupancy = (int *) calloc(s->num_vcs, sizeof(int));\n-    s->last_buf_full = (tw_stime *) calloc(s->num_vcs, sizeof(tw_stime));\n+    s->last_buf_full = 0.0;\n \n     for (i = 0; i < s->num_vcs; i++) {\n-        s->last_buf_full[i] = 0.0;\n         s->vc_occupancy[i] = 0;\n     }\n \n@@ -1254,10 +1295,20 @@ void router_plus_setup(router_state *r, tw_lp *lp)\n     r->queued_msgs_tail =\n         (terminal_plus_message_list ***) calloc(p->radix, sizeof(terminal_plus_message_list **));\n     r->queued_count = (int *) calloc(p->radix, sizeof(int));\n-    r->last_buf_full = (tw_stime **) calloc(p->radix, sizeof(tw_stime *));\n+    r->last_buf_full = (tw_stime *) calloc(p->radix, sizeof(tw_stime));\n     r->busy_time = (tw_stime *) calloc(p->radix, sizeof(tw_stime));\n     r->busy_time_sample = (tw_stime *) calloc(p->radix, sizeof(tw_stime));\n \n+    /* set up for ROSS stats sampling */\n+    r->link_traffic_ross_sample = (int64_t*)calloc(p->radix, sizeof(int64_t));\n+    r->busy_time_ross_sample = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n+    if (g_st_model_stats)\n+        lp->model_types->mstat_sz = sizeof(tw_lpid) + (sizeof(int64_t) + sizeof(tw_stime)) * p->radix;\n+    if (g_st_use_analysis_lps && g_st_model_stats)\n+        lp->model_types->sample_struct_sz = sizeof(struct dfly_router_sample) + (sizeof(tw_stime) + sizeof(int64_t)) * p->radix;\n+    r->ross_rsample.busy_time = (tw_stime*)calloc(p->radix, sizeof(tw_stime));\n+    r->ross_rsample.link_traffic_sample = (int64_t*)calloc(p->radix, sizeof(int64_t));\n+\n     rc_stack_create(&r->st);\n \n     for (int i = 0; i < p->radix; i++) {\n@@ -1272,7 +1323,7 @@ void router_plus_setup(router_state *r, tw_lp *lp)\n         r->vc_occupancy[i] = (int *) calloc(p->num_vcs, sizeof(int));\n         r->pending_msgs[i] =\n             (terminal_plus_message_list **) calloc(p->num_vcs, sizeof(terminal_plus_message_list *));\n-        r->last_buf_full[i] = (tw_stime *) calloc(p->num_vcs, sizeof(tw_stime));\n+        r->last_buf_full[i] = 0.0;\n         r->pending_msgs_tail[i] =\n             (terminal_plus_message_list **) calloc(p->num_vcs, sizeof(terminal_plus_message_list *));\n         r->queued_msgs[i] =\n@@ -1280,7 +1331,6 @@ void router_plus_setup(router_state *r, tw_lp *lp)\n         r->queued_msgs_tail[i] =\n             (terminal_plus_message_list **) calloc(p->num_vcs, sizeof(terminal_plus_message_list *));\n         for (int j = 0; j < p->num_vcs; j++) {\n-            r->last_buf_full[i][j] = 0.0;\n             r->vc_occupancy[i][j] = 0;\n             r->pending_msgs[i][j] = NULL;\n             r->pending_msgs_tail[i][j] = NULL;\n@@ -1439,9 +1489,6 @@ static void packet_generate_rc(terminal_state *s, tw_bf *bf, terminal_plus_messa\n     }\n     if (bf->c11) {\n         s->issueIdle = 0;\n-        if (bf->c8) {\n-            s->last_buf_full[0] = msg->saved_busy_time;\n-        }\n     }\n     struct mn_stats *stat;\n     stat = model_net_find_stats(msg->category, s->dragonfly_stats_array);\n@@ -1532,13 +1579,6 @@ static void packet_generate(terminal_state *s, tw_bf *bf, terminal_plus_message \n     else {\n         bf->c11 = 1;\n         s->issueIdle = 1;\n-\n-        if (s->last_buf_full[0] == 0.0) {\n-            bf->c8 = 1;\n-            msg->saved_busy_time = s->last_buf_full[0];\n-            /* TODO: Assumes a single vc from terminal to router */\n-            s->last_buf_full[0] = tw_now(lp);\n-        }\n     }\n \n     if (s->in_send_loop == 0) {\n@@ -1570,8 +1610,8 @@ static void packet_send_rc(terminal_state *s, tw_bf *bf, terminal_plus_message *\n     if (bf->c1) {\n         s->in_send_loop = 1;\n \n-        if (bf->c10)\n-            s->last_buf_full[0] = msg->saved_busy_time;\n+        if (bf->c3)\n+            s->last_buf_full = msg->saved_busy_time;\n \n         return;\n     }\n@@ -1600,8 +1640,10 @@ static void packet_send_rc(terminal_state *s, tw_bf *bf, terminal_plus_message *\n         s->issueIdle = 1;\n         if (bf->c6) {\n             s->busy_time = msg->saved_total_time;\n-            s->last_buf_full[0] = msg->saved_busy_time;\n+            s->last_buf_full = msg->saved_busy_time;\n             s->busy_time_sample = msg->saved_sample_time;\n+            s->ross_sample.busy_time_sample = msg->saved_sample_time;\n+            s->busy_time_ross_sample = msg->saved_busy_time_ross;\n         }\n     }\n     return;\n@@ -1615,18 +1657,21 @@ static void packet_send(terminal_state *s, tw_bf *bf, terminal_plus_message *msg\n     tw_lpid router_id;\n \n     terminal_plus_message_list *cur_entry = s->terminal_msgs[0];\n+    bool noEmptyVC = false;\n \n     if (s->vc_occupancy[0] + s->params->chunk_size > s->params->cn_vc_size) {\n-        if (s->last_buf_full[0] == 0.0) {\n-            bf->c10 = 1;\n-            msg->saved_busy_time = s->last_buf_full[0];\n-            s->last_buf_full[0] = tw_now(lp);\n-        }\n+        noEmptyVC = true;\n     }\n \n     if (s->vc_occupancy[0] + s->params->chunk_size > s->params->cn_vc_size || cur_entry == NULL) {\n         bf->c1 = 1;\n         s->in_send_loop = 0;\n+        if(noEmptyVC && !s->last_buf_full)\n+        {\n+            bf->c3 = 1;\n+            msg->saved_busy_time = s->last_buf_full;\n+            s->last_buf_full = tw_now(lp); \n+        }\n         return;\n     }\n \n@@ -1709,15 +1754,18 @@ static void packet_send(terminal_state *s, tw_bf *bf, terminal_plus_message *msg\n         ts += tw_rand_unif(lp->rng);\n         model_net_method_idle_event(ts, 0, lp);\n \n-        if (s->last_buf_full[0] > 0.0) {\n+        if (s->last_buf_full > 0.0) {\n             bf->c6 = 1;\n             msg->saved_total_time = s->busy_time;\n-            msg->saved_busy_time = s->last_buf_full[0];\n+            msg->saved_busy_time = s->last_buf_full;\n             msg->saved_sample_time = s->busy_time_sample;\n \n-            s->busy_time += (tw_now(lp) - s->last_buf_full[0]);\n-            s->busy_time_sample += (tw_now(lp) - s->last_buf_full[0]);\n-            s->last_buf_full[0] = 0.0;\n+            s->busy_time += (tw_now(lp) - s->last_buf_full);\n+            s->busy_time_sample += (tw_now(lp) - s->last_buf_full);\n+            s->ross_sample.busy_time_sample += (tw_now(lp) - s->last_buf_full);\n+            msg->saved_busy_time_ross = s->busy_time_ross_sample;\n+            s->busy_time_ross_sample += (tw_now(lp) - s->last_buf_full);\n+            s->last_buf_full = 0.0;\n         }\n     }\n     return;\n@@ -1740,12 +1788,18 @@ static void packet_arrive_rc(terminal_state *s, tw_bf *bf, terminal_plus_message\n     N_finished_chunks--;\n     s->finished_chunks--;\n     s->fin_chunks_sample--;\n+    s->ross_sample.fin_chunks_sample--;\n+    s->fin_chunks_ross_sample--;\n \n     total_hops -= msg->my_N_hop;\n     s->total_hops -= msg->my_N_hop;\n     s->fin_hops_sample -= msg->my_N_hop;\n+    s->ross_sample.fin_hops_sample -= msg->my_N_hop;\n+    s->fin_hops_ross_sample -= msg->my_N_hop;\n     dragonfly_total_time = msg->saved_total_time;\n     s->fin_chunks_time = msg->saved_sample_time;\n+    s->ross_sample.fin_chunks_time = msg->saved_sample_time;\n+    s->fin_chunks_time_ross_sample = msg->saved_fin_chunks_ross;\n     s->total_time = msg->saved_avg_time;\n \n     struct qhash_head *hash_link = NULL;\n@@ -1784,6 +1838,8 @@ static void packet_arrive_rc(terminal_state *s, tw_bf *bf, terminal_plus_message\n         total_msg_sz -= msg->total_size;\n         s->total_msg_size -= msg->total_size;\n         s->data_size_sample -= msg->total_size;\n+        s->ross_sample.data_size_sample -= msg->total_size;\n+        s->data_size_ross_sample -= msg->total_size;\n \n         struct dfly_qhash_entry *d_entry_pop = (dfly_qhash_entry *) rc_stack_pop(s->st);\n         qhash_add(s->rank_tbl, &key, &(d_entry_pop->hash_link));\n@@ -1906,6 +1962,8 @@ static void packet_arrive(terminal_state *s, tw_bf *bf, terminal_plus_message *m\n     s->finished_chunks++;\n     /* Finished chunks per sample */\n     s->fin_chunks_sample++;\n+    s->ross_sample.fin_chunks_sample++;\n+    s->fin_chunks_ross_sample++;\n \n     /* WE do not allow self messages through dragonfly */\n     assert(lp->gid != msg->src_terminal_id);\n@@ -1935,6 +1993,9 @@ static void packet_arrive(terminal_state *s, tw_bf *bf, terminal_plus_message *m\n     /* save the sample time */\n     msg->saved_sample_time = s->fin_chunks_time;\n     s->fin_chunks_time += (tw_now(lp) - msg->travel_start_time);\n+    s->ross_sample.fin_chunks_time += (tw_now(lp) - msg->travel_start_time);\n+    msg->saved_fin_chunks_ross = s->fin_chunks_time_ross_sample;\n+    s->fin_chunks_time_ross_sample += (tw_now(lp) - msg->travel_start_time);\n \n     /* save the total time per LP */\n     msg->saved_avg_time = s->total_time;\n@@ -1945,6 +2006,8 @@ static void packet_arrive(terminal_state *s, tw_bf *bf, terminal_plus_message *m\n     total_hops += msg->my_N_hop;\n     s->total_hops += msg->my_N_hop;\n     s->fin_hops_sample += msg->my_N_hop;\n+    s->ross_sample.fin_hops_sample += msg->my_N_hop;\n+    s->fin_hops_ross_sample += msg->my_N_hop;\n \n     mn_stats *stat = model_net_find_stats(msg->category, s->dragonfly_stats_array);\n     msg->saved_rcv_time = stat->recv_time;\n@@ -2023,6 +2086,8 @@ static void packet_arrive(terminal_state *s, tw_bf *bf, terminal_plus_message *m\n         bf->c7 = 1;\n \n         s->data_size_sample += msg->total_size;\n+        s->ross_sample.data_size_sample += msg->total_size;\n+        s->data_size_ross_sample += msg->total_size;\n         N_finished_msgs++;\n         total_msg_sz += msg->total_size;\n         s->total_msg_size += msg->total_size;\n@@ -2347,28 +2412,54 @@ void dragonfly_plus_terminal_final(terminal_state *s, tw_lp *lp)\n {\n     model_net_print_stats(lp->gid, s->dragonfly_stats_array);\n \n+    int written = 0;\n+    if (s->terminal_id == 0) {\n+        written += sprintf(s->output_buf + written, \"# Format <source_id> <source_type> <dest_id> < dest_type>  <link_type> <link_traffic> <link_saturation>\");\n+    }\n+    written += sprintf(s->output_buf + written, \"\\n%u %s %llu %s %s %llu %lf\",\n+        s->terminal_id, \"T\", s->router_id, \"R\", \"CN\", LLU(s->total_msg_size), s->busy_time);\n+\n+    lp_io_write(lp->gid, (char*)\"dragonfly-plus-link-stats\", written, s->output_buf);\n+\n+\n     if (s->terminal_id == 0) {\n         char meta_filename[64];\n-        sprintf(meta_filename, \"dragonfly-msg-stats.meta\");\n+        sprintf(meta_filename, \"dragonfly-plus-cn-stats.meta\");\n \n-        FILE *fp = fopen(meta_filename, \"w+\");\n-        fprintf(fp,\n-                \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets \"\n-                \"finished> <Avg hops> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n+        FILE * fp = fopen(meta_filename, \"w+\");\n+        fprintf(fp, \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n     }\n-    int written = 0;\n+   \n+    written = 0;\n+    written += sprintf(s->output_buf2 + written, \"%llu %llu %lf %lf %lf %lf %llu %lf\\n\", \n+            lp->gid, s->terminal_id, s->total_time/s->finished_chunks, \n+            s->busy_time, s->max_latency, s->min_latency,\n+            s->finished_packets, (double)s->total_hops/s->finished_chunks);\n \n-    written += sprintf(s->output_buf + written, \"%llu %u %llu %lf %ld %lf %lf %lf %lf\\n\", LLU(lp->gid),\n-                       s->terminal_id, LLU(s->total_msg_size), s->total_time / s->finished_chunks,\n-                       s->finished_packets, (double) s->total_hops / s->finished_chunks, s->busy_time,\n-                       s->max_latency, s->min_latency);\n \n-    lp_io_write(lp->gid, (char *) \"dragonfly-msg-stats\", written, s->output_buf);\n+    lp_io_write(lp->gid, (char*)\"dragonfly-plus-cn-stats\", written, s->output_buf2); \n+\n+    // if (s->terminal_id == 0) {\n+    //     char meta_filename[64];\n+    //     sprintf(meta_filename, \"dragonfly-msg-stats.meta\");\n+\n+    //     FILE *fp = fopen(meta_filename, \"w+\");\n+    //     fprintf(fp,\n+    //             \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets \"\n+    //             \"finished> <Avg hops> <Busy Time> <Max packet Latency> <Min packet Latency >\\n\");\n+    // }\n+    // int written = 0;\n+\n+    // written += sprintf(s->output_buf + written, \"%llu %u %llu %lf %ld %lf %lf %lf %lf\\n\", LLU(lp->gid),\n+    //                    s->terminal_id, LLU(s->total_msg_size), s->total_time / s->finished_chunks,\n+    //                    s->finished_packets, (double) s->total_hops / s->finished_chunks, s->busy_time,\n+    //                    s->max_latency, s->min_latency);\n+\n+    // lp_io_write(lp->gid, (char *) \"dragonfly-msg-stats\", written, s->output_buf);\n \n     if (s->terminal_msgs[0] != NULL)\n         printf(\"[%llu] leftover terminal messages \\n\", LLU(lp->gid));\n \n-\n     // if(s->packet_gen != s->packet_fin)\n     //    printf(\"\\n generated %d finished %d \", s->packet_gen, s->packet_fin);\n \n@@ -2383,33 +2474,6 @@ void dragonfly_plus_terminal_final(terminal_state *s, tw_lp *lp)\n \n void dragonfly_plus_router_final(router_state *s, tw_lp *lp)\n {\n-    // int max_gc_usage = 0;\n-    // int min_gc_usage = INT_MAX;\n-\n-    // int running_sum = 0;\n-    // for(int i = 0; i < s->params->num_global_connections; i++)\n-    // {\n-    //     int gc_val = s->gc_usage[i];\n-    //     running_sum += gc_val;\n-\n-    //     if (gc_val > max_gc_usage)\n-    //         max_gc_usage = gc_val;\n-    //     if (gc_val < min_gc_usage)\n-    //         min_gc_usage = gc_val;\n-    // }\n-    // double mean_gc_usage = (double) running_sum / (double) s->params->num_global_connections; \n-\n-    // if (s->dfp_router_type == SPINE) {\n-    //     printf(\"Router %d in group %d:   Min GC Usage= %d    Max GC Usage= %d     Mean GC Usage= %.2f\", s->router_id, s->router_id / s->params->num_routers, min_gc_usage, max_gc_usage, mean_gc_usage);\n-    //     printf(\"\\t[\");\n-    //     for(int i = 0; i < s->params->num_global_connections; i++)\n-    //     {\n-    //         printf(\"%d \",s->gc_usage[i]);\n-    //     }\n-    //     printf(\"]\\n\");\n-    // }\n-\n-\n     free(s->global_channel);\n     int i, j;\n     for (i = 0; i < s->params->radix; i++) {\n@@ -2426,60 +2490,101 @@ void dragonfly_plus_router_final(router_state *s, tw_lp *lp)\n \n     rc_stack_destroy(s->st);\n \n-    /*MM: These statistics will need to be updated for dragonfly plus.\n-     * Especially the meta file information on router ports still have green\n-     * and black links. */\n     const dragonfly_plus_param *p = s->params;\n     int written = 0;\n-    if (!s->router_id) {\n-        written =\n-            sprintf(s->output_buf, \"# Format <Type> <LP ID> <Group ID> <Router ID> <Busy time per router port(s)>\");\n-        written += sprintf(s->output_buf + written, \"\\n# Router ports in the order: %d Intra Links, %d Inter Links %d Terminal Links. Hyphens for Unconnected ports (No terminals on Spine routers)\", p->intra_grp_radix, p->num_global_connections, p->num_cn);  \n-    }\n-\n-    char router_type[10];\n-    if (s->dfp_router_type == LEAF)\n-        strcpy(router_type,\"LEAF\");\n-    else if(s->dfp_router_type == SPINE)\n-        strcpy(router_type,\"SPINE\");\n-\n-    written += sprintf(s->output_buf + written, \"\\n%s %llu %d %d\", router_type, LLU(lp->gid), s->router_id / p->num_routers, s->router_id % p->num_routers);\n-    for (int d = 0; d < p->radix; d++) {\n-        bool printed_hyphen = false;\n-        ConnectionType port_type = s->connMan->get_port_type(d);\n-        \n-        if (port_type == 0) {\n-            written += sprintf(s->output_buf + written, \" -\");\n-            printed_hyphen = true;\n+    int src_rel_id = s->router_id % p->num_routers;\n+    int local_grp_id = s->router_id / p->num_routers;\n+\n+    for( int d = 0; d < p->intra_grp_radix; d++)\n+    {\n+        if (d != src_rel_id) {\n+            int dest_ab_id = local_grp_id * p->num_routers + d;\n+            written += sprintf(s->output_buf + written, \"\\n%d %s %d %s %s %llu %lf\",\n+                s->router_id,\n+                \"R\",\n+                dest_ab_id,\n+                \"R\",\n+                \"L\",\n+                s->link_traffic[d],\n+                s->busy_time[d] );\n         }\n-        if (printed_hyphen == false)\n-            written += sprintf(s->output_buf + written, \" %lf\", s->busy_time[d]);\n     }\n \n-    sprintf(s->output_buf + written, \"\\n\");\n-    lp_io_write(lp->gid, (char *) \"dragonfly-plus-router-stats\", written, s->output_buf);\n+    vector< Connection > my_global_links = s->connMan->get_connections_by_type(CONN_GLOBAL);\n+    vector< Connection >::iterator it = my_global_links.begin();\n \n-    written = 0;\n-    if (!s->router_id) {\n-        written =\n-            sprintf(s->output_buf2, \"# Format <LP ID> <Group ID> <Router ID> <Busy time per router port(s)>\");\n-        written += sprintf(s->output_buf2 + written, \"\\n# Router ports in the order: %d Intra Links, %d Inter Links %d Terminal Links. Hyphens for Unconnected ports (No terminals on Spine routers)\", p->intra_grp_radix, p->num_global_connections, p->num_cn);  \n+    for(; it != my_global_links.end(); it++)\n+    {\n+        int dest_rtr_id = it->dest_gid;\n+        int port_no = it->port;\n+        assert(port_no >= 0 && port_no < p->radix);\n+        written += sprintf(s->output_buf + written, \"\\n%d %s %d %s %s %llu %lf\",\n+            s->router_id,\n+            \"R\",\n+            dest_rtr_id,\n+            \"R\",\n+            \"G\",\n+            s->link_traffic[port_no],\n+            s->busy_time[port_no] );\n     }\n-    written += sprintf(s->output_buf2 + written, \"\\n%s %llu %d %d\", router_type, LLU(lp->gid), s->router_id / p->num_routers, s->router_id % p->num_routers);\n \n-    for (int d = 0; d < p->radix; d++) {\n-        bool printed_hyphen = false;\n-        ConnectionType port_type = s->connMan->get_port_type(d);\n+    sprintf(s->output_buf + written, \"\\n\");\n+    lp_io_write(lp->gid, (char*)\"dragonfly-plus-link-stats\", written, s->output_buf);\n+\n+    // /*MM: These statistics will need to be updated for dragonfly plus.\n+    //  * Especially the meta file information on router ports still have green\n+    //  * and black links. */\n+    // const dragonfly_plus_param *p = s->params;\n+    // int written = 0;\n+    // if (!s->router_id) {\n+    //     written =\n+    //         sprintf(s->output_buf, \"# Format <Type> <LP ID> <Group ID> <Router ID> <Busy time per router port(s)>\");\n+    //     written += sprintf(s->output_buf + written, \"\\n# Router ports in the order: %d Intra Links, %d Inter Links %d Terminal Links. Hyphens for Unconnected ports (No terminals on Spine routers)\", p->intra_grp_radix, p->num_global_connections, p->num_cn);  \n+    // }\n \n-        if (port_type == 0) {\n-            written += sprintf(s->output_buf2 + written, \" -\");\n-            printed_hyphen = true;\n-        }\n-        if (printed_hyphen == false)\n-            written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n-    }\n+    // char router_type[10];\n+    // if (s->dfp_router_type == LEAF)\n+    //     strcpy(router_type,\"LEAF\");\n+    // else if(s->dfp_router_type == SPINE)\n+    //     strcpy(router_type,\"SPINE\");\n+\n+    // written += sprintf(s->output_buf + written, \"\\n%s %llu %d %d\", router_type, LLU(lp->gid), s->router_id / p->num_routers, s->router_id % p->num_routers);\n+    // for (int d = 0; d < p->radix; d++) {\n+    //     bool printed_hyphen = false;\n+    //     ConnectionType port_type = s->connMan->get_port_type(d);\n+        \n+    //     if (port_type == 0) {\n+    //         written += sprintf(s->output_buf + written, \" -\");\n+    //         printed_hyphen = true;\n+    //     }\n+    //     if (printed_hyphen == false)\n+    //         written += sprintf(s->output_buf + written, \" %lf\", s->busy_time[d]);\n+    // }\n \n-    lp_io_write(lp->gid, (char *) \"dragonfly-plus-router-traffic\", written, s->output_buf2);\n+    // sprintf(s->output_buf + written, \"\\n\");\n+    // lp_io_write(lp->gid, (char *) \"dragonfly-plus-router-stats\", written, s->output_buf);\n+\n+    // written = 0;\n+    // if (!s->router_id) {\n+    //     written =\n+    //         sprintf(s->output_buf2, \"# Format <LP ID> <Group ID> <Router ID> <Busy time per router port(s)>\");\n+    //     written += sprintf(s->output_buf2 + written, \"\\n# Router ports in the order: %d Intra Links, %d Inter Links %d Terminal Links. Hyphens for Unconnected ports (No terminals on Spine routers)\", p->intra_grp_radix, p->num_global_connections, p->num_cn);  \n+    // }\n+    // written += sprintf(s->output_buf2 + written, \"\\n%s %llu %d %d\", router_type, LLU(lp->gid), s->router_id / p->num_routers, s->router_id % p->num_routers);\n+\n+    // for (int d = 0; d < p->radix; d++) {\n+    //     bool printed_hyphen = false;\n+    //     ConnectionType port_type = s->connMan->get_port_type(d);\n+\n+    //     if (port_type == 0) {\n+    //         written += sprintf(s->output_buf2 + written, \" -\");\n+    //         printed_hyphen = true;\n+    //     }\n+    //     if (printed_hyphen == false)\n+    //         written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n+    // }\n+\n+    // lp_io_write(lp->gid, (char *) \"dragonfly-plus-router-traffic\", written, s->output_buf2);\n }\n \n static int get_min_hops_to_dest_from_conn(router_state *s, tw_bf *bf, terminal_plus_message *msg, tw_lp *lp, Connection conn)\n@@ -3190,9 +3295,6 @@ static void router_packet_receive_rc(router_state *s, tw_bf *bf, terminal_plus_m\n         }\n     }\n     if (bf->c4) {\n-        if (bf->c22) {\n-            s->last_buf_full[output_port][output_chan] = msg->saved_busy_time;\n-        }\n         delete_terminal_plus_message_list(\n             return_tail(s->queued_msgs[output_port], s->queued_msgs_tail[output_port], output_chan));\n         s->queued_count[output_port] -= s->params->chunk_size;\n@@ -3331,17 +3433,6 @@ static void router_packet_receive(router_state *s, tw_bf *bf, terminal_plus_mess\n         append_to_terminal_plus_message_list(s->queued_msgs[output_port], s->queued_msgs_tail[output_port],\n                                              output_chan, cur_chunk);\n         s->queued_count[output_port] += s->params->chunk_size;\n-\n-        /* a check for pending msgs is non-empty then we dont set anything. If\n-         * that is empty then we check if last_buf_full is set or not. If already\n-         * set then we don't overwrite it. If two packets arrive next to each other\n-         * then the first person should be setting it. */\n-        if (s->pending_msgs[output_port][output_chan] == NULL &&\n-            s->last_buf_full[output_port][output_chan] == 0.0) {\n-            bf->c22 = 1;\n-            msg->saved_busy_time = s->last_buf_full[output_port][output_chan];\n-            s->last_buf_full[output_port][output_chan] = tw_now(lp);\n-        }\n     }\n \n     msg->saved_vc = output_port;\n@@ -3358,9 +3449,21 @@ static void router_packet_send_rc(router_state *s, tw_bf *bf, terminal_plus_mess\n     int output_chan = msg->saved_channel;\n     if (bf->c1) {\n         s->in_send_loop[output_port] = 1;\n+        if(bf->c2) {\n+            s->last_buf_full[output_port] = msg->saved_busy_time;\n+        }\n         return;\n     }\n \n+    if(bf->c8)\n+    {\n+        s->busy_time[output_port] = msg->saved_rcv_time;\n+        s->busy_time_sample[output_port] = msg->saved_sample_time;\n+        s->ross_rsample.busy_time[output_port] = msg->saved_sample_time;\n+        s->busy_time_ross_sample[output_port] = msg->saved_busy_time_ross;\n+        s->last_buf_full[output_port] = msg->saved_busy_time;\n+    }\n+\n     tw_rand_reverse_unif(lp->rng);\n \n     terminal_plus_message_list *cur_entry = (terminal_plus_message_list *) rc_stack_pop(s->st);\n@@ -3369,10 +3472,14 @@ static void router_packet_send_rc(router_state *s, tw_bf *bf, terminal_plus_mess\n     if (bf->c11) {\n         s->link_traffic[output_port] -= cur_entry->msg.packet_size % s->params->chunk_size;\n         s->link_traffic_sample[output_port] -= cur_entry->msg.packet_size % s->params->chunk_size;\n+        s->ross_rsample.link_traffic_sample[output_port] -= cur_entry->msg.packet_size % s->params->chunk_size;\n+        s->link_traffic_ross_sample[output_port] -= cur_entry->msg.packet_size % s->params->chunk_size;\n     }\n     if (bf->c12) {\n         s->link_traffic[output_port] -= s->params->chunk_size;\n         s->link_traffic_sample[output_port] -= s->params->chunk_size;\n+        s->ross_rsample.link_traffic_sample[output_port] -= s->params->chunk_size;\n+        s->link_traffic_ross_sample[output_port] -= s->params->chunk_size;\n     }\n     s->next_output_available_time[output_port] = msg->saved_available_time;\n \n@@ -3416,9 +3523,29 @@ static void router_packet_send(router_state *s, tw_bf *bf, terminal_plus_message\n     if (cur_entry == NULL) {\n         bf->c1 = 1;\n         s->in_send_loop[output_port] = 0;\n+        if (s->queued_count[output_port] && !s->last_buf_full[output_port]) \n+        {\n+            bf->c2 = 1; \n+            msg->saved_busy_time = s->last_buf_full[output_port];\n+            s->last_buf_full[output_port] = tw_now(lp);\n+        }\n         return;\n     }\n \n+    if (s->last_buf_full[output_port]) \n+    {\n+        bf->c8 = 1;\n+        msg->saved_rcv_time = s->busy_time[output_port]; \n+        msg->saved_busy_time = s->last_buf_full[output_port]; \n+        msg->saved_sample_time = s->busy_time_sample[output_port];  \n+        s->busy_time[output_port] += (tw_now(lp) - s->last_buf_full[output_port]); \n+        s->busy_time_sample[output_port] += (tw_now(lp) - s->last_buf_full[output_port]);\n+        s->ross_rsample.busy_time[output_port] += (tw_now(lp) - s->last_buf_full[output_port]);\n+        msg->saved_busy_time_ross = s->busy_time_ross_sample[output_port];\n+        s->busy_time_ross_sample[output_port] += (tw_now(lp) - s->last_buf_full[output_port]);\n+        s->last_buf_full[output_port] = 0.0;\n+    }\n+\n     int to_terminal = 1, global = 0;\n     double delay = s->params->cn_delay;\n     double bandwidth = s->params->cn_bandwidth;\n@@ -3484,11 +3611,15 @@ static void router_packet_send(router_state *s, tw_bf *bf, terminal_plus_message\n         bf->c11 = 1;\n         s->link_traffic[output_port] += (cur_entry->msg.packet_size % s->params->chunk_size);\n         s->link_traffic_sample[output_port] += (cur_entry->msg.packet_size % s->params->chunk_size);\n+        s->ross_rsample.link_traffic_sample[output_port] += (cur_entry->msg.packet_size % s->params->chunk_size);\n+        s->link_traffic_ross_sample[output_port] += (cur_entry->msg.packet_size % s->params->chunk_size);\n     }\n     else {\n         bf->c12 = 1;\n         s->link_traffic[output_port] += s->params->chunk_size;\n         s->link_traffic_sample[output_port] += s->params->chunk_size;\n+        s->ross_rsample.link_traffic_sample[output_port] += s->params->chunk_size;\n+        s->link_traffic_ross_sample[output_port] += s->params->chunk_size;\n     }\n \n     /* Determine the event type. If the packet has arrived at the final\n@@ -3543,7 +3674,9 @@ static void router_buf_update_rc(router_state *s, tw_bf *bf, terminal_plus_messa\n     if (bf->c3) {\n         s->busy_time[indx] = msg->saved_rcv_time;\n         s->busy_time_sample[indx] = msg->saved_sample_time;\n-        s->last_buf_full[indx][output_chan] = msg->saved_busy_time;\n+        s->ross_rsample.busy_time[indx] = msg->saved_sample_time;\n+        s->busy_time_ross_sample[indx] = msg->saved_busy_time_ross;\n+        s->last_buf_full[indx] = msg->saved_busy_time;\n     }\n     if (bf->c1) {\n         terminal_plus_message_list *head =\n@@ -3566,14 +3699,17 @@ static void router_buf_update(router_state *s, tw_bf *bf, terminal_plus_message \n     int output_chan = msg->output_chan;\n     s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n \n-    if (s->last_buf_full[indx][output_chan] > 0.0) {\n+    if (s->last_buf_full[indx] > 0.0) {\n         bf->c3 = 1;\n         msg->saved_rcv_time = s->busy_time[indx];\n-        msg->saved_busy_time = s->last_buf_full[indx][output_chan];\n+        msg->saved_busy_time = s->last_buf_full[indx];\n         msg->saved_sample_time = s->busy_time_sample[indx];\n-        s->busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n-        s->busy_time_sample[indx] += (tw_now(lp) - s->last_buf_full[indx][output_chan]);\n-        s->last_buf_full[indx][output_chan] = 0.0;\n+        s->busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+        s->busy_time_sample[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+        s->ross_rsample.busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+        msg->saved_busy_time_ross = s->busy_time_ross_sample[indx];\n+        s->busy_time_ross_sample[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+        s->last_buf_full[indx] = 0.0;\n     }\n     if (s->queued_msgs[indx][output_chan] != NULL) {\n         bf->c1 = 1;\n@@ -3721,6 +3857,203 @@ static void router_plus_register(tw_lptype *base_type)\n     lp_type_register(LP_CONFIG_NM_ROUT, base_type);\n }\n \n+/* ROSS Instrumentation layer */\n+// virtual time sampling callback - router forward\n+static void ross_dfly_plus_rsample_fn(router_state * s, tw_bf * bf, tw_lp * lp, struct dfly_router_sample *sample)\n+{\n+    (void)lp;\n+    (void)bf;\n+\n+    const dragonfly_plus_param * p = s->params; \n+    int i = 0;\n+\n+    sample->router_id = s->router_id;\n+    sample->end_time = tw_now(lp);\n+    sample->fwd_events = s->fwd_events;\n+    sample->rev_events = s->rev_events;\n+    sample->busy_time = (tw_stime*)((&sample->rev_events) + 1);\n+    sample->link_traffic_sample = (int64_t*)((&sample->busy_time[0]) + p->radix);\n+\n+    for(; i < p->radix; i++)\n+    {\n+        sample->busy_time[i] = s->ross_rsample.busy_time[i]; \n+        sample->link_traffic_sample[i] = s->ross_rsample.link_traffic_sample[i]; \n+    }\n+\n+    /* clear up the current router stats */\n+    s->fwd_events = 0;\n+    s->rev_events = 0;\n+\n+    for( i = 0; i < p->radix; i++)\n+    {\n+        s->ross_rsample.busy_time[i] = 0;\n+        s->ross_rsample.link_traffic_sample[i] = 0;\n+    }\n+}\n+\n+// virtual time sampling callback - router reverse\n+static void ross_dfly_plus_rsample_rc_fn(router_state * s, tw_bf * bf, tw_lp * lp, struct dfly_router_sample *sample)\n+{\n+    (void)lp;\n+    (void)bf;\n+    \n+    const dragonfly_plus_param * p = s->params;\n+    int i =0;\n+\n+    for(; i < p->radix; i++)\n+    {\n+        s->ross_rsample.busy_time[i] = sample->busy_time[i];\n+        s->ross_rsample.link_traffic_sample[i] = sample->link_traffic_sample[i];\n+    }\n+\n+    s->fwd_events = sample->fwd_events;\n+    s->rev_events = sample->rev_events;\n+}\n+\n+// virtual time sampling callback - terminal forward\n+static void ross_dfly_plus_sample_fn(terminal_state * s, tw_bf * bf, tw_lp * lp, struct dfly_cn_sample *sample)\n+{\n+    (void)lp;\n+    (void)bf;\n+    \n+    sample->terminal_id = s->terminal_id;\n+    sample->fin_chunks_sample = s->ross_sample.fin_chunks_sample;\n+    sample->data_size_sample = s->ross_sample.data_size_sample;\n+    sample->fin_hops_sample = s->ross_sample.fin_hops_sample;\n+    sample->fin_chunks_time = s->ross_sample.fin_chunks_time;\n+    sample->busy_time_sample = s->ross_sample.busy_time_sample;\n+    sample->end_time = tw_now(lp);\n+    sample->fwd_events = s->fwd_events;\n+    sample->rev_events = s->rev_events;\n+\n+    s->ross_sample.fin_chunks_sample = 0;\n+    s->ross_sample.data_size_sample = 0;\n+    s->ross_sample.fin_hops_sample = 0;\n+    s->fwd_events = 0;\n+    s->rev_events = 0;\n+    s->ross_sample.fin_chunks_time = 0;\n+    s->ross_sample.busy_time_sample = 0;\n+}\n+\n+// virtual time sampling callback - terminal reverse\n+static void ross_dfly_plus_sample_rc_fn(terminal_state * s, tw_bf * bf, tw_lp * lp, struct dfly_cn_sample *sample)\n+{\n+    (void)lp;\n+    (void)bf;\n+\n+    s->ross_sample.busy_time_sample = sample->busy_time_sample;\n+    s->ross_sample.fin_chunks_time = sample->fin_chunks_time;\n+    s->ross_sample.fin_hops_sample = sample->fin_hops_sample;\n+    s->ross_sample.data_size_sample = sample->data_size_sample;\n+    s->ross_sample.fin_chunks_sample = sample->fin_chunks_sample;\n+    s->fwd_events = sample->fwd_events;\n+    s->rev_events = sample->rev_events;\n+}\n+\n+// event tracing callback - used router and terminal LPs\n+void dfly_plus_event_collect(terminal_plus_message *m, tw_lp *lp, char *buffer, int *collect_flag)\n+{\n+    (void)lp;\n+    (void)collect_flag;\n+\n+    int type = (int) m->type;\n+    memcpy(buffer, &type, sizeof(type));\n+}\n+\n+// GVT-based and real time sampling callback for terminals\n+void dfly_plus_model_stat_collect(terminal_state *s, tw_lp *lp, char *buffer)\n+{\n+    (void)lp;\n+\n+    int index = 0;\n+    tw_lpid id = 0;\n+    long tmp = 0;\n+    tw_stime tmp2 = 0;\n+    \n+    id = s->terminal_id;\n+    memcpy(&buffer[index], &id, sizeof(id));\n+    index += sizeof(id);\n+\n+    tmp = s->fin_chunks_ross_sample;\n+    memcpy(&buffer[index], &tmp, sizeof(tmp));\n+    index += sizeof(tmp);\n+    s->fin_chunks_ross_sample = 0;\n+\n+    tmp = s->data_size_ross_sample;\n+    memcpy(&buffer[index], &tmp, sizeof(tmp));\n+    index += sizeof(tmp);\n+    s->data_size_ross_sample = 0;\n+\n+    tmp = s->fin_hops_ross_sample;\n+    memcpy(&buffer[index], &tmp, sizeof(tmp));\n+    index += sizeof(tmp);\n+    s->fin_hops_ross_sample = 0;\n+\n+    tmp2 = s->fin_chunks_time_ross_sample;\n+    memcpy(&buffer[index], &tmp2, sizeof(tmp2));\n+    index += sizeof(tmp2);\n+    s->fin_chunks_time_ross_sample = 0;\n+\n+    tmp2 = s->busy_time_ross_sample;\n+    memcpy(&buffer[index], &tmp2, sizeof(tmp2));\n+    index += sizeof(tmp2);\n+    s->busy_time_ross_sample = 0;\n+\n+    return;\n+}\n+\n+// GVT-based and real time sampling callback for routers\n+void dfly_plus_router_model_stat_collect(router_state *s, tw_lp *lp, char *buffer)\n+{\n+    (void)lp;\n+\n+    const dragonfly_plus_param * p = s->params; \n+    int i, index = 0;\n+\n+    tw_lpid id = 0;\n+    tw_stime tmp = 0;\n+    int64_t tmp2 = 0;\n+\n+    id = s->router_id;\n+    memcpy(&buffer[index], &id, sizeof(id));\n+    index += sizeof(id);\n+\n+    for(i = 0; i < p->radix; i++)\n+    {\n+        tmp = s->busy_time_ross_sample[i];\n+        memcpy(&buffer[index], &tmp, sizeof(tmp));\n+        index += sizeof(tmp);\n+        s->busy_time_ross_sample[i] = 0; \n+\n+        tmp2 = s->link_traffic_ross_sample[i];\n+        memcpy(&buffer[index], &tmp2, sizeof(tmp2));\n+        index += sizeof(tmp2);\n+        s->link_traffic_ross_sample[i] = 0; \n+    }\n+    return;\n+}\n+\n+static const st_model_types  *dfly_plus_get_model_types(void)\n+{\n+    return(&dfly_plus_model_types[0]);\n+}\n+\n+static const st_model_types  *dfly_plus_router_get_model_types(void)\n+{\n+    return(&dfly_plus_model_types[1]);\n+}\n+\n+static void dfly_plus_register_model_types(st_model_types *base_type)\n+{\n+    st_model_type_register(LP_CONFIG_NM_TERM, base_type);\n+}\n+\n+static void dfly_plus_router_register_model_types(st_model_types *base_type)\n+{\n+    st_model_type_register(LP_CONFIG_NM_ROUT, base_type);\n+}\n+/*** END of ROSS Instrumentation support */\n+\n extern \"C\" {\n /* data structure for dragonfly statistics */\n struct model_net_method dragonfly_plus_method = {\n@@ -3736,10 +4069,12 @@ struct model_net_method dragonfly_plus_method = {\n     dragonfly_plus_report_stats,\n     NULL,\n     NULL,\n-    NULL,  //(event_f)dragonfly_plus_sample_fn,\n-    NULL,  //(revent_f)dragonfly_plus_sample_rc_fn,\n+    NULL, //(event_f)dragonfly_plus_sample_fn,\n+    NULL, //(revent_f)dragonfly_plus_sample_rc_fn,\n     (init_f) dragonfly_plus_sample_init,\n-    NULL,  //(final_f)dragonfly_plus_sample_fin\n+    NULL, //(final_f)dragonfly_plus_sample_fin,\n+    dfly_plus_register_model_types,\n+    dfly_plus_get_model_types,\n };\n \n struct model_net_method dragonfly_plus_router_method = {\n@@ -3755,10 +4090,12 @@ struct model_net_method dragonfly_plus_router_method = {\n     NULL,  // not yet supported\n     NULL,\n     NULL,\n-    NULL,  //(event_f)dragonfly_plus_rsample_fn,\n-    NULL,  //(revent_f)dragonfly_plus_rsample_rc_fn,\n+    NULL, //(event_f)dragonfly_plus_rsample_fn,\n+    NULL, //(revent_f)dragonfly_plus_rsample_rc_fn,\n     (init_f) dragonfly_plus_rsample_init,\n-    NULL,  //(final_f)dragonfly_plus_rsample_fin\n+    NULL, //(final_f)dragonfly_plus_rsample_fin,\n+    dfly_plus_router_register_model_types,\n+    dfly_plus_router_get_model_types,\n };\n \n // #ifdef ENABLE_CORTEX\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 47,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/express-mesh.C",
                        "old_path": "src/networks/model-net/express-mesh.C",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/express-mesh.C\n+++ b/src/networks/model-net/express-mesh.C\n@@ -435,7 +435,7 @@ static void local_read_config(const char * anno, local_param *params){\n   p->total_terminals = p->total_routers * p->num_cn;\n \n   int rank;\n-  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n+  MPI_Comm_rank(MPI_COMM_CODES, &rank);\n   if(!rank) {\n     printf(\"\\n Total nodes %d routers %d radix %d \\n\",\n         p->total_terminals, p->total_routers, p->radix);\n@@ -480,22 +480,22 @@ static void local_report_stats()\n   long total_gen, total_fin;\n \n   MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG,\n-      MPI_SUM, 0, MPI_COMM_WORLD);\n+      MPI_SUM, 0, MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_msgs, &total_finished_msgs, 1, MPI_LONG_LONG, MPI_SUM,\n-      0, MPI_COMM_WORLD);\n+      0, MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_chunks, &total_finished_chunks, 1, MPI_LONG_LONG,\n-      MPI_SUM, 0, MPI_COMM_WORLD);\n+      MPI_SUM, 0, MPI_COMM_CODES);\n   MPI_Reduce( &total_msg_sz, &final_msg_sz, 1, MPI_LONG_LONG, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &local_total_time, &avg_time, 1,MPI_DOUBLE, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &local_max_latency, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n \n-  MPI_Reduce( &packet_gen, &total_gen, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-  MPI_Reduce( &packet_fin, &total_fin, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n+  MPI_Reduce( &packet_gen, &total_gen, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+  MPI_Reduce( &packet_fin, &total_fin, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n \n   /* print statistics */\n   if(!g_tw_mynode)\n@@ -2547,7 +2547,9 @@ struct model_net_method express_mesh_method  =\n   NULL,//(event_f)local_sample_fn,\n   NULL,//(revent_f)local_sample_rc_fn,\n   (init_f)local_sample_init,\n-  NULL//(final_f)local_sample_fin,\n+  NULL,//(final_f)local_sample_fin,\n+  NULL, // for ROSS instrumentation\n+  NULL  // for ROSS instrumentation\n };\n \n struct model_net_method express_mesh_router_method =\n@@ -2567,7 +2569,9 @@ struct model_net_method express_mesh_router_method =\n   NULL,//(event_f)local_rsample_fn,\n   NULL,//(revent_f)local_rsample_rc_fn,\n   (init_f)local_rsample_init,\n-  NULL//(final_f)local_rsample_fin,\n+  NULL,//(final_f)local_rsample_fin,\n+  NULL, // for ROSS instrumentation\n+  NULL  // for ROSS instrumentation\n };\n \n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 48,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/fattree.c",
                        "old_path": "src/networks/model-net/fattree.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/fattree.c\n+++ b/src/networks/model-net/fattree.c\n@@ -730,10 +730,12 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n   \n   int i;\n \n-  p->ft_type = 1;\n+  p->ft_type = 0;\n   configuration_get_value_int(&config, \"PARAMS\", \"ft_type\", anno,\n       &p->ft_type);\n   if(!g_tw_mynode) printf(\"FT type is %d\\n\", p->ft_type);\n+  if(p->ft_type == 1) printf(\"Use of FT type 1 is deprecated; please use type 0 for similar functionality\\n\");\n+  if(p->ft_type == 2) printf(\"You have chosen FT type 2: this is for cases in which different NICs are desired for different rails.\\n\");\n \n   configuration_get_value_int(&config, \"PARAMS\", \"num_levels\", anno,\n       &p->num_levels);\n@@ -866,9 +868,9 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n   if(!g_tw_mynode) printf(\"FT num rails is %d\\n\", p->num_rails);\n   \n   if(p->ft_type == 2) {\n-    p->ports_per_nic = p->num_rails;\n-  } else {\n     p->ports_per_nic = 1;\n+  } else {\n+    p->ports_per_nic = p->num_rails;\n   }\n \n   p->router_delay = 50;\n@@ -1022,7 +1024,7 @@ void ft_terminal_init( ft_terminal_state * s, tw_lp * lp )\n    int num_lps = codes_mapping_get_lp_count(lp_group_name, 1, LP_CONFIG_NM,\n            s->anno, 0);\n \n-   if(s->params->ft_type != 2) {\n+   if(s->params->ft_type == 2) {\n     num_lps /= s->params->num_rails;\n    }\n \n@@ -1031,7 +1033,7 @@ void ft_terminal_init( ft_terminal_state * s, tw_lp * lp )\n          \"%d, not the given value of %d\\n\", s->params->l0_term_size, num_lps);\n    }\n   \n-   if(s->params->ft_type != 2) {\n+   if(s->params->ft_type == 2) {\n     s->terminal_id = (mapping_rep_id * num_lps) + (mapping_offset/s->params->num_rails);\n     s->rail_id = (mapping_offset % s->params->num_rails);\n    } else {\n@@ -1040,7 +1042,7 @@ void ft_terminal_init( ft_terminal_state * s, tw_lp * lp )\n    }\n    s->switch_id = s->terminal_id / s->params->l0_term_size;\n    s->switch_lp = (tw_lpid*)malloc(s->params->ports_per_nic * sizeof(tw_lpid));\n-   if(s->params->ft_type != 2) {\n+   if(s->params->ft_type == 2) {\n      codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n          s->switch_id, 0 + s->params->num_levels * s->rail_id, &s->switch_lp[0]);\n    } else {\n@@ -1215,7 +1217,7 @@ void switch_init(switch_state * r, tw_lp * lp)\n   //if at level 0, first half ports go to terminals\n   if(r->switch_level == 0) {\n     int term_rails, term_railid;\n-    if(p->ft_type != 2) {\n+    if(p->ft_type == 2) {\n       term_rails = p->num_rails;\n       term_railid = r->rail_id;\n     } else {\n@@ -1898,7 +1900,7 @@ void switch_packet_receive_rc(switch_state * s,\n \ts_arrive_r++;\n #endif\n     int output_port = msg->saved_vc;\n-    if(s->params->routing != STATIC) {\n+    if(s->params->routing != STATIC && !bf->c10) {\n       tw_rand_reverse_unif(lp->rng);\n     }\n     if(bf->c1)\n@@ -2667,12 +2669,13 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n     tw_lp * lp, int *out_off) {\n   (void)bf;\n   (void)lp;\n+  bf->c10 = 0;\n   int outport = -1;\n   int start_port, end_port;\n   fattree_param *p = s->params;\n \n   int dest_term_local_id = codes_mapping_get_lp_relative_id(msg->dest_terminal_id, 0, 0);\n-  if(s->params->ft_type != 2) {\n+  if(s->params->ft_type == 2) {\n     dest_term_local_id /= s->params->num_rails;\n   }\n   /* either do static oblivious routing, if set up properly via LFTs */\n@@ -2692,6 +2695,7 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n     if(dest_term_local_id >= s->start_lneigh && dest_term_local_id < s->end_lneigh) {\n       outport = dest_term_local_id - s->start_lneigh;\n       *out_off = 0;\n+      bf->c10 = 1;\n       return outport;\n     } else { //go up the least congested path\n       start_port = s->num_lcons;\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 49,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/loggp.c",
                        "old_path": "src/networks/model-net/loggp.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/loggp.c\n+++ b/src/networks/model-net/loggp.c\n@@ -160,7 +160,9 @@ struct model_net_method loggp_method =\n     .mn_sample_fn = NULL,\n     .mn_sample_rc_fn = NULL,\n     .mn_sample_init_fn = NULL,\n-    .mn_sample_fini_fn = NULL\n+    .mn_sample_fini_fn = NULL,\n+    .mn_model_stat_register = NULL, // for ROSS instrumentation\n+    .mn_get_model_stat_types = NULL // for ROSS instrumentation\n };\n \n static void loggp_init(\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 50,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/model-net.c",
                        "old_path": "src/networks/model-net/model-net.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/model-net.c\n+++ b/src/networks/model-net/model-net.c\n@@ -271,12 +271,12 @@ static model_net_event_return model_net_noop_event(\n     model_net_event_return num_rng_calls = 0;\n     tw_stime poffset = mn_in_sequence ? mn_msg_offset : 0.0;\n     tw_stime delay = codes_local_latency(sender);\n+    num_rng_calls++; // rng call is in codes_local_latency\n \n     tw_stime sendTime = message_size * codes_cn_delay;\n \n     if (self_event_size && self_event != NULL) {\n         poffset += delay;\n-        num_rng_calls++;\n         tw_event *e = tw_event_new(sender->gid, poffset+offset+sendTime, sender);\n         memcpy(tw_event_data(e), self_event, self_event_size);\n         tw_event_send(e);\n@@ -284,7 +284,6 @@ static model_net_event_return model_net_noop_event(\n \n     if (remote_event_size && remote_event != NULL) {\n         poffset += delay;\n-        num_rng_calls++;\n         /* special case - in a \"pull\" event, the \"remote\" message is actually\n          * to self */\n         tw_event *e = tw_event_new(is_pull ? sender->gid : final_dest_lp,\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 51,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/net-template.C",
                        "old_path": "src/networks/model-net/net-template.C",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/net-template.C\n+++ b/src/networks/model-net/net-template.C\n@@ -401,22 +401,22 @@ static void local_report_stats()\n   long total_gen, total_fin;\n \n   MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG,\n-      MPI_SUM, 0, MPI_COMM_WORLD);\n+      MPI_SUM, 0, MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_msgs, &total_finished_msgs, 1, MPI_LONG_LONG, MPI_SUM,\n-      0, MPI_COMM_WORLD);\n+      0, MPI_COMM_CODES);\n   MPI_Reduce( &N_finished_chunks, &total_finished_chunks, 1, MPI_LONG_LONG,\n-      MPI_SUM, 0, MPI_COMM_WORLD);\n+      MPI_SUM, 0, MPI_COMM_CODES);\n   MPI_Reduce( &total_msg_sz, &final_msg_sz, 1, MPI_LONG_LONG, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &local_total_time, &avg_time, 1,MPI_DOUBLE, MPI_SUM, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n   MPI_Reduce( &local_max_latency, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0,\n-      MPI_COMM_WORLD);\n+      MPI_COMM_CODES);\n \n-  MPI_Reduce( &packet_gen, &total_gen, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-  MPI_Reduce( &packet_fin, &total_fin, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n+  MPI_Reduce( &packet_gen, &total_gen, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+  MPI_Reduce( &packet_fin, &total_fin, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n \n   /* print statistics */\n   if(!g_tw_mynode)\n@@ -2186,7 +2186,9 @@ struct model_net_method NETWORK_method  =\n   NULL,//(event_f)local_sample_fn,\n   NULL,//(revent_f)local_sample_rc_fn,\n   (init_f)local_sample_init,\n-  NULL//(final_f)local_sample_fin,\n+  NULL,//(final_f)local_sample_fin,\n+  NULL, // for ROSS instrumentation\n+  NULL  // for ROSS instrumentation\n };\n \n struct model_net_method NETWORK_router_method =\n@@ -2206,7 +2208,9 @@ struct model_net_method NETWORK_router_method =\n   NULL,//(event_f)local_rsample_fn,\n   NULL,//(revent_f)local_rsample_rc_fn,\n   (init_f)local_rsample_init,\n-  NULL//(final_f)local_rsample_fin,\n+  NULL,//(final_f)local_rsample_fin,\n+  NULL, // for ROSS instrumentation\n+  NULL  // for ROSS instrumentation\n };\n \n }\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 52,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/simplenet-upd.c",
                        "old_path": "src/networks/model-net/simplenet-upd.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/simplenet-upd.c\n+++ b/src/networks/model-net/simplenet-upd.c\n@@ -125,7 +125,9 @@ struct model_net_method simplenet_method =\n     .mn_sample_fn = NULL,\n     .mn_sample_rc_fn = NULL,\n     .mn_sample_init_fn = NULL,\n-    .mn_sample_fini_fn = NULL\n+    .mn_sample_fini_fn = NULL,\n+    .mn_model_stat_register = NULL, // for ROSS instrumentation\n+    .mn_get_model_stat_types = NULL // for ROSS instrumentation\n };\n \n static void sn_init(\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 53,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/simplep2p.c",
                        "old_path": "src/networks/model-net/simplep2p.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/simplep2p.c\n+++ b/src/networks/model-net/simplep2p.c\n@@ -155,7 +155,9 @@ struct model_net_method simplep2p_method =\n     .mn_sample_fn = NULL,\n     .mn_sample_rc_fn = NULL,\n     .mn_sample_init_fn = NULL,\n-    .mn_sample_fini_fn = NULL\n+    .mn_sample_fini_fn = NULL,\n+    .mn_model_stat_register = NULL, // for ROSS instrumentation\n+    .mn_get_model_stat_types = NULL // for ROSS instrumentation\n };\n \n static void sp_init(\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 54,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/slimfly.c",
                        "old_path": "src/networks/model-net/slimfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/slimfly.c\n+++ b/src/networks/model-net/slimfly.c\n@@ -638,19 +638,19 @@ static void slimfly_report_stats()\n     float throughput_avg = 0.0;\n     float throughput_avg2 = 0.0;\n \n-    MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &N_finished_msgs, &total_finished_msgs, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &N_finished_chunks, &total_finished_chunks, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &total_msg_sz, &final_msg_sz, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &slimfly_total_time, &avg_time, 1,MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce( &slimfly_max_latency, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);\n-\n-    MPI_Reduce(&pe_throughput_percent, &throughput_avg, 1, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce(&pe_throughput, &throughput_avg2, 1, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_WORLD);\n-\n-    MPI_Reduce(&minimal_count, &total_minimal_packets, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n-    MPI_Reduce(&nonmin_count, &total_nonmin_packets, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n+    MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &N_finished_msgs, &total_finished_msgs, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &N_finished_chunks, &total_finished_chunks, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &total_msg_sz, &final_msg_sz, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &slimfly_total_time, &avg_time, 1,MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce( &slimfly_max_latency, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_CODES);\n+\n+    MPI_Reduce(&pe_throughput_percent, &throughput_avg, 1, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce(&pe_throughput, &throughput_avg2, 1, MPI_FLOAT, MPI_SUM, 0, MPI_COMM_CODES);\n+\n+    MPI_Reduce(&minimal_count, &total_minimal_packets, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_CODES);\n+    MPI_Reduce(&nonmin_count, &total_nonmin_packets, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_CODES);\n \n     /* print statistics */\n     if(!g_tw_mynode)\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 55,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/torus.c",
                        "old_path": "src/networks/model-net/torus.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/torus.c\n+++ b/src/networks/model-net/torus.c\n@@ -2018,7 +2018,9 @@ struct model_net_method torus_method =\n    .mn_sample_fn = NULL,\n    .mn_sample_rc_fn = NULL,\n    .mn_sample_init_fn = NULL,\n-   .mn_sample_fini_fn = NULL\n+   .mn_sample_fini_fn = NULL,\n+   .mn_model_stat_register = NULL, // for ROSS instrumentation\n+   .mn_get_model_stat_types = NULL // for ROSS instrumentation\n };\n \n /* user-facing modelnet functions */\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 56,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/util/codes-comm.c",
                        "old_path": "src/util/codes-comm.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/util/codes-comm.c\n+++ b/src/util/codes-comm.c\n@@ -5,10 +5,20 @@\n  */\n \n #include <mpi.h>\n+#include <ross.h>\n \n MPI_Comm MPI_COMM_CODES = MPI_COMM_WORLD;\n \n /*\n+ * Needs to be called AFTER tw_init() because in tw_init, \n+ * ROSS may split the MPI_COMM_ROSS communicator\n+ */\n+void codes_comm_update()\n+{\n+    MPI_COMM_CODES = MPI_COMM_ROSS;\n+}\n+\n+/*\n  * Local variables:\n  *  c-indent-level: 4\n  *  c-basic-offset: 4\n"
                    },
                    {
                        "merge_request_diff_id": 1613,
                        "relative_order": 57,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "tests/Makefile.subdir",
                        "old_path": "tests/Makefile.subdir",
                        "binary": false,
                        "utf8_diff": "--- a/tests/Makefile.subdir\n+++ b/tests/Makefile.subdir\n@@ -46,7 +46,7 @@ EXTRA_DIST += tests/download-traces.sh \\\n  tests/workload/codes-workload-test.conf \\\n  tests/workload/README.txt \\\n  tests/workload/darshan-dump.sh \\\n- tests/workload/example.darshan.gz \\\n+ tests/workload/example.darshan \\\n  tests/mapping_test.sh \\\n  tests/lsm-test.sh \\\n  tests/resource-test.sh \\\n@@ -80,6 +80,7 @@ EXTRA_DIST += tests/download-traces.sh \\\n  tests/conf/modelnet-test-bw.conf \\\n  tests/conf/modelnet-test-bw-tri.conf \\\n  tests/conf/modelnet-test.conf \\\n+ tests/conf/modelnet-test-em.conf\t\\\n  tests/conf/modelnet-test-dragonfly.conf \\\n  tests/conf/modelnet-test-slimfly.conf \\\n  tests/conf/modelnet-test-loggp.conf \\\n"
                    }
                ]
            },
            "events": [
                {
                    "id": 48069,
                    "project_id": 68,
                    "author_id": 75,
                    "target_id": 943,
                    "created_at": "2018-08-24T22:19:02.639Z",
                    "updated_at": "2018-08-24T22:19:02.639Z",
                    "target_type": "MergeRequest",
                    "action": 3
                },
                {
                    "id": 48061,
                    "project_id": 68,
                    "author_id": 75,
                    "target_id": 943,
                    "created_at": "2018-08-24T21:33:15.762Z",
                    "updated_at": "2018-08-24T21:33:15.762Z",
                    "target_type": "MergeRequest",
                    "action": 1
                }
            ],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        },
        {
            "id": 20,
            "target_branch": "master",
            "source_branch": "slimfly-merge",
            "source_project_id": 68,
            "author_id": 85,
            "assignee_id": 75,
            "title": "Slimfly LP-IO Update",
            "created_at": "2016-07-18T17:57:25.918Z",
            "updated_at": "2016-07-18T20:27:15.837Z",
            "state": "merged",
            "merge_status": "can_be_merged",
            "target_project_id": 68,
            "iid": 6,
            "description": "Fixed issue #152 .\r\nUpdated Slim Fly workload README accordingly",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": "1"
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": "06a7bce8107bebf18f3d6970206b2f3f7f7089db",
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": "611d1ea72cf3da85c560d83de720e16e935e4ffd",
            "source_branch_sha": null,
            "target_branch_sha": "fb41c9c0b553f6a042834de25dec05fc8c5f70ba",
            "metrics": {
                "id": 524,
                "merge_request_id": 20,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2016-07-18T17:57:25.918Z",
                "updated_at": "2016-07-18T20:27:15.837Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": null,
                "latest_closed_at": null
            },
            "notes": [
                {
                    "id": 2038,
                    "note": "mentioned in commit 06a7bce8107bebf18f3d6970206b2f3f7f7089db",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2016-07-18T20:27:15.785Z",
                    "updated_at": "2016-07-18T20:27:15.785Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 20,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "8d68f164ea61f955c93073a6d2d537b38697ecb1",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                },
                {
                    "id": 2037,
                    "note": "Status changed to merged",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2016-07-18T20:27:14.334Z",
                    "updated_at": "2016-07-18T20:27:14.334Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 20,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "9fef6add89634ceae7879340a861d5083bf9f703",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                }
            ],
            "merge_request_diff": {
                "id": 20,
                "state": "collected",
                "merge_request_id": 20,
                "created_at": "2016-07-18T17:57:25.946Z",
                "updated_at": "2016-07-18T17:57:26.075Z",
                "base_commit_sha": "f27745b7a89273ec6660e19dd697d34087675794",
                "real_size": "2",
                "head_commit_sha": "611d1ea72cf3da85c560d83de720e16e935e4ffd",
                "start_commit_sha": null,
                "commits_count": 2,
                "merge_request_diff_commits": [
                    {
                        "authored_date": "2016-07-18T17:53:12.000Z",
                        "committed_date": "2016-07-18T17:53:12.000Z",
                        "merge_request_diff_id": 20,
                        "relative_order": 0,
                        "sha": "611d1ea72cf3da85c560d83de720e16e935e4ffd",
                        "author_name": "Noah",
                        "author_email": "wolfen@rpi.edu",
                        "committer_name": "Noah",
                        "committer_email": "wolfen@rpi.edu",
                        "message": "Fixed issue %152 (providing commandline options for LP IO output). Updated slimfly workload README.\n"
                    },
                    {
                        "authored_date": "2016-07-18T17:05:23.000Z",
                        "committed_date": "2016-07-18T17:05:23.000Z",
                        "merge_request_diff_id": 20,
                        "relative_order": 1,
                        "sha": "ad1e90b5bf2ed150baab1c850c2d87ba1f75cf88",
                        "author_name": "Noah",
                        "author_email": "wolfen@rpi.edu",
                        "committer_name": "Noah",
                        "committer_email": "wolfen@rpi.edu",
                        "message": "Adding commit_f to slimfly synthetic workload to comply with new ROSS API\n"
                    }
                ],
                "merge_request_diff_files": [
                    {
                        "merge_request_diff_id": 20,
                        "relative_order": 0,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100755",
                        "b_mode": "100755",
                        "new_path": "src/network-workloads/README_synthetic_slimfly.txt",
                        "old_path": "src/network-workloads/README_synthetic_slimfly.txt",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/README_synthetic_slimfly.txt\n+++ b/src/network-workloads/README_synthetic_slimfly.txt\n@@ -19,12 +19,14 @@ HOW TO RUN:\n \n ROSS optimistic mode:\n mpirun -n 4 src/network-workloads/model-net-synthetic-slimfly --sync=3 --traffic=1 \n+--lp-io-dir=mn_synthetic --lp-io-use-suffix=1\n --load=0.95 -- ../../jenkins/codes/src/network-workloads/conf/modelnet-synthetic-slimfly-min.conf\n \n ROSS serial mode:\n \n ./src/network-workloads/model-net-synthetic-slimfly --sync=1 --traffic=1 \n---load=0.95 -- ../../jenkins/codes/src/network-workloads/conf/modelnet-synthetic-slimfly-min.conf\n+--lp-io-dir=mn_synthetic --lp-io-use-suffix=1\n+--load=0.95 -- ../src/network-workloads/conf/modelnet-synthetic-slimfly-min.conf\n \n options:\n \n"
                    },
                    {
                        "merge_request_diff_id": 20,
                        "relative_order": 1,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-synthetic-slimfly.c",
                        "old_path": "src/network-workloads/model-net-synthetic-slimfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/network-workloads/model-net-synthetic-slimfly.c\n+++ b/src/network-workloads/model-net-synthetic-slimfly.c\n@@ -40,6 +40,11 @@ int *worst_dest;\t\t\t\t\t\t//Array mapping worst case destination for each router\n int num_terminals;\n int total_routers;\n \n+static char lp_io_dir[356] = {'\\0'};\n+static lp_io_handle io_handle;\n+static unsigned int lp_io_use_suffix = 0;\n+static int do_lp_io = 0;\n+\n /* whether to pull instead of push */\n static int do_pull = 0;\n \n@@ -114,6 +119,7 @@ tw_lptype svr_lp = {\n     (pre_run_f) NULL,\n     (event_f) svr_event,\n     (revent_f) svr_rev_event,\n+    (commit_f) NULL,\n     (final_f)  svr_finalize,\n     (map_f) codes_mapping,\n     sizeof(svr_state),\n@@ -124,8 +130,10 @@ const tw_optdef app_opt [] =\n         TWOPT_GROUP(\"Model net synthetic traffic \" ),\n         TWOPT_UINT(\"traffic\", traffic, \"UNIFORM RANDOM=1, NEAREST NEIGHBOR=2 \"),\n         TWOPT_STIME(\"arrival_time\", arrival_time, \"INTER-ARRIVAL TIME\"),\n-        TWOPT_STIME(\"load\", load, \"percentage of packet inter-arrival rate to simulate\"),\n-        TWOPT_END(),\n+        TWOPT_STIME(\"load\", load, \"percentage of packet inter-arrival rate to simulate\"), \n+        TWOPT_CHAR(\"lp-io-dir\", lp_io_dir, \"Where to place io output (unspecified -> no output\"),\n+        TWOPT_UINT(\"lp-io-use-suffix\", lp_io_use_suffix, \"Whether to append uniq suffix to lp-io directory (default 0)\"),\n+\tTWOPT_END(),\n };\n \n const tw_lptype* svr_get_lp_type()\n@@ -431,14 +439,9 @@ int main(\n     int rank;\n     int num_nets;\n     int *net_ids;\n-    char* anno;\n-\n-    lp_io_handle handle;\n-\n+ \n     tw_opt_add(app_opt);\n     tw_init(&argc, &argv);\n-    offset = 1;\n-\n \n     if(argc < 2)\n     {\n@@ -455,18 +458,10 @@ int main(\n     svr_add_lp_type();\n     codes_mapping_setup();\n     net_ids = model_net_configure(&num_nets);\n-    assert(num_nets==1);\n+//    assert(num_nets==1);\n     net_id = *net_ids;\n     free(net_ids);\n \n-//slimfly \n-/*    if(net_id != DRAGONFLY)\n-    {\n-\tprintf(\"\\n The test works with dragonfly model configuration only! \");\n-        MPI_Finalize();\n-        return 0;\n-    }\n-*/\n     num_servers_per_rep = codes_mapping_get_lp_count(\"MODELNET_GRP\", 1, \"server\", NULL, 1);\n     configuration_get_value_int(&config, \"PARAMS\", \"num_terminals\", NULL, &num_terminals);\n     configuration_get_value_int(&config, \"PARAMS\", \"num_routers\", NULL, &num_routers_per_grp);\n@@ -475,10 +470,19 @@ int main(\n     num_nodes_per_grp = num_routers_per_grp * num_servers_per_rep;\n     total_routers = num_routers_per_grp * num_routers_per_grp * 2;\n \n-    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_WORLD) < 0)\n+/*    if(lp_io_prepare(\"modelnet-test\", LP_IO_UNIQ_SUFFIX, &handle, MPI_COMM_WORLD) < 0)\n     {\n         return(-1);\n     }\n+*/\n+\n+    if(lp_io_dir[0])\n+    {\n+        do_lp_io = 1;\n+        int flags = lp_io_use_suffix ? LP_IO_UNIQ_SUFFIX : 0;\n+        int ret = lp_io_prepare(lp_io_dir, flags, &io_handle, MPI_COMM_WORLD);\n+        assert(ret == 0 || !\"lp_io_prepare failure\");\n+    }\n \n     //WORST_CASE Initialization array\n    if(traffic == WORST_CASE)\n@@ -494,8 +498,15 @@ int main(\n #endif\n    }\n \n-    tw_run();\n-    model_net_report_stats(net_id);\n+   tw_run();\n+\n+ \n+   if (do_lp_io){\n+       int ret = lp_io_flush(io_handle, MPI_COMM_WORLD);\n+       assert(ret == 0 || !\"lp_io_flush failure\");\n+   }\n+\n+   model_net_report_stats(net_id);\n \n     if(rank == 0)\n     {\n@@ -511,11 +522,12 @@ int main(\n #endif\n     }\n \n-    if(lp_io_flush(handle, MPI_COMM_WORLD) < 0)\n+/*    if(lp_io_flush(handle, MPI_COMM_WORLD) < 0)\n     {\n+        assert(ret == 0 || !\"lp_io_flush failure\");\n         return(-1);\n     }\n-\n+*/\n     tw_end();\n \n     if(rank == 0)\n"
                    }
                ]
            },
            "events": [],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        },
        {
            "id": 175,
            "target_branch": "master",
            "source_branch": "llnl-udpates",
            "source_project_id": 68,
            "author_id": 219,
            "assignee_id": 75,
            "title": "Express Mesh + fat-tree changes",
            "created_at": "2017-07-25T08:14:06.062Z",
            "updated_at": "2017-07-26T17:13:14.908Z",
            "state": "closed",
            "merge_status": "can_be_merged",
            "target_project_id": 68,
            "iid": 33,
            "description": "",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": "0"
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": null,
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": "f6da330a13d72b7336a6f20c87deef814bd2f58d",
            "source_branch_sha": "f6da330a13d72b7336a6f20c87deef814bd2f58d",
            "target_branch_sha": "fb41c9c0b553f6a042834de25dec05fc8c5f70ba",
            "metrics": {
                "id": 139,
                "merge_request_id": 175,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2017-07-25T08:14:06.406Z",
                "updated_at": "2017-07-25T08:14:06.406Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": null,
                "latest_closed_at": null
            },
            "notes": [
                {
                    "id": 5595,
                    "note": "added 1 commit\n\n* f6da330a - Fixing compilers warnings for print format and unused variables, uncommenting sampling functions\n\n[Compare with previous version](https://xgitlab.cels.anl.gov/codes/codes/merge_requests/33/diffs?diff_id=272&start_sha=921d3e486f04520d4bb19b970e1a0aaea49b24ef)",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2017-07-26T15:48:49.125Z",
                    "updated_at": "2017-07-26T15:48:49.125Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 175,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "4591ba9f847126a58395140b2cd912b2ec853f07",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                },
                {
                    "id": 5582,
                    "note": "mentioned in merge request !21",
                    "noteable_type": "MergeRequest",
                    "author_id": 219,
                    "created_at": "2017-07-25T08:14:49.161Z",
                    "updated_at": "2017-07-25T08:14:49.161Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 175,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "c4a2573bea7d92888423ccbfd6ec8e0bd00bc4d3",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Nikhil"
                    },
                    "events": []
                },
                {
                    "id": 5597,
                    "note": "closed",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2017-07-26T17:13:14.907Z",
                    "updated_at": "2017-07-26T17:13:14.907Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 175,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "44ace348d4bd07c289e073ee822eba87c75ef9e1",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                },
                {
                    "id": 5584,
                    "note": "@nwolfey21 this should have the priority queue issue fixed.",
                    "noteable_type": "MergeRequest",
                    "author_id": 219,
                    "created_at": "2017-07-25T08:16:18.683Z",
                    "updated_at": "2017-07-25T08:16:18.683Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": "",
                    "noteable_id": 175,
                    "system": false,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "ed7af630a73b24aaae655d89d8a5e0b9ab1b41a2",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Nikhil"
                    },
                    "events": []
                },
                {
                    "id": 5583,
                    "note": "Need to be tested and compiled, but please review meanwhile.",
                    "noteable_type": "MergeRequest",
                    "author_id": 219,
                    "created_at": "2017-07-25T08:15:35.788Z",
                    "updated_at": "2017-07-25T08:15:35.788Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": "",
                    "noteable_id": 175,
                    "system": false,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "b8e16b349a5e50ae4f5311d1363151d898511191",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Nikhil"
                    },
                    "events": []
                }
            ],
            "merge_request_diff": {
                "id": 272,
                "state": "collected",
                "merge_request_id": 175,
                "created_at": "2017-07-26T15:48:43.063Z",
                "updated_at": "2017-07-26T15:48:44.754Z",
                "base_commit_sha": "e7c122ef755d1c44dbc30a8756d22055c917e947",
                "real_size": "12+",
                "head_commit_sha": "f6da330a13d72b7336a6f20c87deef814bd2f58d",
                "start_commit_sha": "e7c122ef755d1c44dbc30a8756d22055c917e947",
                "commits_count": 9,
                "merge_request_diff_commits": [
                    {
                        "authored_date": "2017-07-26T15:46:55.000Z",
                        "committed_date": "2017-07-26T15:46:55.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 0,
                        "sha": "f6da330a13d72b7336a6f20c87deef814bd2f58d",
                        "author_name": "mubarak",
                        "author_email": "mubarak@mcs.anl.gov",
                        "committer_name": "mubarak",
                        "committer_email": "mubarak@mcs.anl.gov",
                        "message": "Fixing compilers warnings for print format and unused variables, uncommenting sampling functions\n"
                    },
                    {
                        "authored_date": "2017-07-25T08:10:46.000Z",
                        "committed_date": "2017-07-25T08:10:46.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 1,
                        "sha": "921d3e486f04520d4bb19b970e1a0aaea49b24ef",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Fix bug introduced in 77e85ef978ec40a17d239e0ab52b222e075fee09\n\nChange-Id: I430c19d46be11f00c4123118334f7e68f835a846\n"
                    },
                    {
                        "authored_date": "2017-07-25T08:05:34.000Z",
                        "committed_date": "2017-07-25T08:05:34.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 2,
                        "sha": "577f97966feaf3b8f8e71f3ba8faded12ae9e129",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Change NIC seq delay default to a low value\n\nChange-Id: I07a70c6bc91e89634997998cf4ff07f74af67b53\n"
                    },
                    {
                        "authored_date": "2017-03-12T03:35:01.000Z",
                        "committed_date": "2017-07-25T07:49:42.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 3,
                        "sha": "ab362140fb8faf55f5127b4168dc389bb4be2fb3",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Sensible defaults\n\nChange-Id: I4740549495b8a5eac920dc9f7f0419aadeb2a84a\n"
                    },
                    {
                        "authored_date": "2017-02-26T23:23:40.000Z",
                        "committed_date": "2017-07-25T07:49:41.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 4,
                        "sha": "2ac5ad7f55b2ccda7b4668ab111460b10e67747e",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Portability fixes\n\nChange-Id: Ied69812e2b6600c54a3e14cdf6aad8c99109f84d\n"
                    },
                    {
                        "authored_date": "2017-02-06T08:33:21.000Z",
                        "committed_date": "2017-07-25T07:49:41.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 5,
                        "sha": "743d45619da34901609ba2a2ea047ba979374b6d",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Update fattree doc to discuss tapering.\n\nChange-Id: I128ea0b1683e8f9aad4b305b8d2d7415addebb65\nTODO: update needed for multi rail, ft type 2, and within node config.\n"
                    },
                    {
                        "authored_date": "2017-02-06T08:06:24.000Z",
                        "committed_date": "2017-07-25T07:49:41.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 6,
                        "sha": "c970df9116c0945821810d2c6d4fa3fca56ac953",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Slimfly clean up and bugfixes\n\nChange-Id: Idb19f79dca5007f2c1f79e44814b8ae393ae282b\n"
                    },
                    {
                        "authored_date": "2016-12-11T01:42:49.000Z",
                        "committed_date": "2017-07-25T07:49:39.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 7,
                        "sha": "cc7d2f63b00a44ddbb1835de957c69453647fe67",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Changes to Fat-tree network\n\n-- Multi rail\n-- Tapering\n-- Within node handling\n"
                    },
                    {
                        "authored_date": "2016-09-13T03:21:33.000Z",
                        "committed_date": "2017-07-25T07:46:39.000Z",
                        "merge_request_diff_id": 272,
                        "relative_order": 8,
                        "sha": "8c5755739d921068ad951c897c2a9e6e36015dfc",
                        "author_name": "Nikhil Jain",
                        "author_email": "nikhil.jain@acm.org",
                        "committer_name": "Nikhil Jain",
                        "committer_email": "nikhil.jain@acm.org",
                        "message": "Add Express Mesh as a network option.\n\n-- Some commits include fixes in other networks\n"
                    }
                ],
                "merge_request_diff_files": [
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 0,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "codes/model-net-lp.h",
                        "old_path": "codes/model-net-lp.h",
                        "binary": false,
                        "utf8_diff": "--- a/codes/model-net-lp.h\n+++ b/codes/model-net-lp.h\n@@ -29,6 +29,7 @@ extern \"C\" {\n #include \"net/simplenet-upd.h\"\n #include \"net/simplep2p.h\"\n #include \"net/torus.h\"\n+#include \"net/express-mesh.h\"\n \n extern int model_net_base_magic;\n \n@@ -90,6 +91,8 @@ void model_net_method_send_msg_recv_event_rc(tw_lp *sender);\n // method - strange and disturbing things will happen otherwise\n void model_net_method_idle_event(tw_stime offset_ts, int is_recv_queue,\n         tw_lp * lp);\n+void model_net_method_idle_event2(tw_stime offset_ts, int is_recv_queue,\n+        int queue_offset, tw_lp * lp);\n \n // Get a ptr to past the message struct area, where the self/remote events\n // are located, given the type of network.\n@@ -114,6 +117,8 @@ typedef struct model_net_base_msg {\n     // no need for event type - in wrap message\n     model_net_request req;\n     int is_from_remote;\n+    int isQueueReq;\n+    tw_stime save_ts;\n     // parameters to pass to new messages (via model_net_set_msg_params)\n     // TODO: make this a union for multiple types of parameters\n     mn_sched_params sched_params;\n@@ -132,6 +137,7 @@ typedef struct model_net_wrap_msg {\n         sn_message              m_snet;  // simplenet\n         sp_message              m_sp2p;  // simplep2p\n         nodes_message           m_torus; // torus\n+        em_message              m_em; // express-mesh\n         // add new ones here\n     } msg;\n } model_net_wrap_msg;\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 1,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "codes/model-net.h",
                        "old_path": "codes/model-net.h",
                        "binary": false,
                        "utf8_diff": "--- a/codes/model-net.h\n+++ b/codes/model-net.h\n@@ -72,6 +72,8 @@ typedef struct mn_stats mn_stats;\n     X(DRAGONFLY_CUSTOM, \"modelnet_dragonfly_custom\", \"dragonfly_custom\", &dragonfly_custom_method)\\\n     X(DRAGONFLY_CUSTOM_ROUTER, \"modelnet_dragonfly_custom_router\", \"dragonfly_custom_router\", &dragonfly_custom_router_method)\\\n     X(LOGGP,     \"modelnet_loggp\",     \"loggp\",     &loggp_method)\\\n+    X(EXPRESS_MESH, \"modelnet_express_mesh\", \"express_mesh\", &express_mesh_method)\\\n+    X(EXPRESS_MESH_ROUTER, \"modelnet_express_mesh_router\", \"express_mesh_router\", &express_mesh_router_method)\\\n     X(MAX_NETS,  NULL,                 NULL,        NULL)\n \n #define X(a,b,c,d) a,\n@@ -123,6 +125,7 @@ typedef struct model_net_request {\n     uint64_t msg_id;\n     int      net_id;\n     int      is_pull;\n+    int      queue_offset;\n     int      remote_event_size;\n     int      self_event_size;\n     char     category[CATEGORY_NAME_MAX];\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 2,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "codes/net/common-net.h",
                        "old_path": "codes/net/common-net.h",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/codes/net/common-net.h\n@@ -0,0 +1,118 @@\n+#ifndef COMMON_NET_H\n+#define COMMON_NET_H\n+#include \"codes/model-net-lp.h\"\n+#include \"codes/quickhash.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+struct mn_hash_key\n+{\n+  uint64_t message_id;\n+  tw_lpid sender_id;\n+};\n+\n+struct mn_qhash_entry\n+{\n+  struct mn_hash_key key;\n+  char * remote_event_data;\n+  int num_chunks;\n+  int remote_event_size;\n+  struct qhash_head hash_link;\n+};\n+\n+extern int mn_rank_hash_compare(void *key, struct qhash_head *link);\n+\n+extern int mn_hash_func(void *k, int table_size);\n+\n+extern void free_tmp(void * ptr);\n+\n+typedef struct message_list message_list;\n+\n+struct message_list {\n+  union {\n+    terminal_message dfly_msg;\n+    em_message em_msg;\n+  };\n+  char* event_data;\n+  message_list *next;\n+  message_list *prev;\n+  int port, index;\n+  message_list *altq_next, *altq_prev;\n+  int in_alt_q, altq_port;\n+};\n+\n+extern void append_to_message_list(  \n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index, \n+    message_list *msg);\n+\n+extern void prepend_to_message_list(  \n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index, \n+    message_list *msg);\n+\n+extern message_list* return_head(\n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index);\n+\n+extern message_list* return_tail(\n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index);\n+\n+extern void delete_from_message_list(\n+    message_list *** allq, \n+    message_list *** alltail,\n+    message_list *msg);\n+\n+extern void add_to_message_list(\n+    message_list *** allq, \n+    message_list *** alltail,\n+    message_list *msg);\n+\n+extern void altq_append_to_message_list(  \n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index, \n+    message_list *msg);\n+\n+extern void altq_prepend_to_message_list(  \n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index, \n+    message_list *msg);\n+\n+extern message_list* altq_return_head(\n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index);\n+\n+extern message_list* altq_return_tail(\n+    message_list ** thisq,\n+    message_list ** thistail,\n+    int index);\n+\n+extern void altq_delete_from_message_list(\n+    message_list *** allq, \n+    message_list *** alltail,\n+    message_list *msg);\n+\n+extern void altq_add_to_message_list(\n+    message_list *** allq, \n+    message_list *** alltail,\n+    message_list *msg);\n+\n+extern void delete_message_list(void *thism);\n+extern tw_stime bytes_to_ns(uint64_t bytes, double GB_p_s);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 3,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "codes/net/express-mesh.h",
                        "old_path": "codes/net/express-mesh.h",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/codes/net/express-mesh.h\n@@ -0,0 +1,88 @@\n+/*\n+ * Copyright (C) 2014 University of Chicago.\n+ * See COPYRIGHT notice in top-level directory.\n+ *\n+ */\n+\n+#ifndef EXPRESS_MESH_H\n+#define EXPRESS_MESH_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <ross.h>\n+\n+typedef struct em_message em_message;\n+\n+struct em_message\n+{\n+  /* magic number */\n+  int magic;\n+  /* flit travel start time*/\n+  tw_stime travel_start_time;\n+ /* packet ID of the flit  */\n+  unsigned long long packet_ID;\n+  /* event type of the flit */\n+  short  type;\n+  /* category: comes from codes */\n+  char category[CATEGORY_NAME_MAX];\n+\n+  /* final destination LP ID, this comes from codes can be a server or any other LP type*/\n+  tw_lpid final_dest_gid;\n+  /*sending LP ID from CODES, can be a server or any other LP type */\n+  tw_lpid sender_lp;\n+  tw_lpid sender_mn_lp; // source modelnet id\n+ /* destination terminal ID */\n+  tw_lpid dest_terminal_id;\n+  int dest_terminal;\n+  /* source terminal ID */\n+  tw_lpid src_terminal_id;\n+\n+  short saved_channel;\n+  short my_N_hop;\n+  short hops[8];\n+\n+  /* Intermediate LP ID from which this message is coming */\n+  unsigned int intm_lp_id;\n+  short saved_vc;\n+  short dim_change;\n+  /* last hop of the message, can be a terminal, local router or global router */\n+  int last_hop;\n+  /* For routing */\n+  uint64_t chunk_id;\n+  uint64_t packet_size;\n+  uint64_t message_id;\n+  uint64_t total_size;\n+\n+  int saved_remote_esize;\n+  int remote_event_size_bytes;\n+  int local_event_size_bytes;\n+\n+  // For buffer message\n+  int vc_index;\n+  int output_chan;\n+  model_net_event_return event_rc;\n+  int is_pull;\n+  uint64_t pull_size;\n+\n+  /* for reverse computation */   \n+  tw_stime saved_available_time;\n+  tw_stime saved_avg_time;\n+  tw_stime saved_rcv_time;\n+  tw_stime saved_busy_time; \n+  tw_stime saved_total_time;\n+  tw_stime saved_hist_start_time;\n+  tw_stime saved_sample_time;\n+  tw_stime msg_start_time;\n+\n+  int saved_hist_num;\n+  int saved_occupancy;\n+};\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \n+\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 4,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "codes/net/fattree.h",
                        "old_path": "codes/net/fattree.h",
                        "binary": false,
                        "utf8_diff": "--- a/codes/net/fattree.h\n+++ b/codes/net/fattree.h\n@@ -49,6 +49,7 @@ struct fattree_message\n \n   // For buffer message\n   short vc_index;\n+  short rail_id;\n   short vc_off;\n   int is_pull;\n   model_net_event_return event_rc;\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 5,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/Makefile.subdir",
                        "old_path": "src/Makefile.subdir",
                        "binary": false,
                        "utf8_diff": "--- a/src/Makefile.subdir\n+++ b/src/Makefile.subdir\n@@ -87,6 +87,7 @@ nobase_include_HEADERS = \\\n \tcodes/model-net-lp.h \\\n \tcodes/model-net-sched.h \\\n \tcodes/model-net-inspect.h \\\n+\tcodes/net/common-net.h \\\n \tcodes/net/dragonfly.h \\\n \tcodes/net/dragonfly-custom.h \\\n \tcodes/net/slimfly.h \\\n@@ -94,6 +95,7 @@ nobase_include_HEADERS = \\\n \tcodes/net/loggp.h \\\n \tcodes/net/simplenet-upd.h \\\n \tcodes/net/simplep2p.h \\\n+\tcodes/net/express-mesh.h \\\n \tcodes/net/torus.h \\\n   codes/codes-mpi-replay.h \\\n \tcodes/configfile.h\n@@ -149,8 +151,10 @@ src_libcodes_la_SOURCES =  \\\n \tcodes/rc-stack.h \\\n \tsrc/util/rc-stack.c \\\n \tsrc/networks/model-net/model-net.c \\\n+\tsrc/networks/model-net/common-net.c \\\n \tsrc/networks/model-net/simplenet-upd.c \\\n \tsrc/networks/model-net/torus.c \\\n+\tsrc/networks/model-net/express-mesh.C \\\n \tsrc/networks/model-net/dragonfly.c \\\n \tsrc/networks/model-net/dragonfly-custom.C \\\n \tsrc/networks/model-net/slimfly.c \\\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 6,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/iokernellang/codeslexer.c",
                        "old_path": "src/iokernellang/codeslexer.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/iokernellang/codeslexer.c\n+++ b/src/iokernellang/codeslexer.c\n@@ -1,6 +1,6 @@\n-#line 2 \"codeslexer.c\"\n+#line 2 \"../src/iokernellang/codeslexer.c\"\n \n-#line 4 \"codeslexer.c\"\n+#line 4 \"../src/iokernellang/codeslexer.c\"\n \n #define  YY_INT_ALIGNED short int\n \n@@ -54,6 +54,7 @@ typedef int flex_int32_t;\n typedef unsigned char flex_uint8_t; \n typedef unsigned short int flex_uint16_t;\n typedef unsigned int flex_uint32_t;\n+#endif /* ! C99 */\n \n /* Limits of integral types. */\n #ifndef INT8_MIN\n@@ -84,8 +85,6 @@ typedef unsigned int flex_uint32_t;\n #define UINT32_MAX             (4294967295U)\n #endif\n \n-#endif /* ! C99 */\n-\n #endif /* ! FLEXINT_H */\n \n #ifdef __cplusplus\n@@ -159,15 +158,7 @@ typedef void* yyscan_t;\n \n /* Size of default input buffer. */\n #ifndef YY_BUF_SIZE\n-#ifdef __ia64__\n-/* On IA-64, the buffer size is 16k, not 8k.\n- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n- * Ditto for the __ia64__ case accordingly.\n- */\n-#define YY_BUF_SIZE 32768\n-#else\n #define YY_BUF_SIZE 16384\n-#endif /* __ia64__ */\n #endif\n \n /* The state buf must be large enough to hold one state per character in the main buffer.\n@@ -538,20 +529,20 @@ static yyconst flex_int32_t yy_rule_can_match_eol[37] =\n #define yymore() yymore_used_but_not_detected\n #define YY_MORE_ADJ 0\n #define YY_RESTORE_YY_MORE_OFFSET\n-#line 1 \"codeslexer.l\"\n+#line 1 \"../src/iokernellang/codeslexer.l\"\n /*\n  * Copyright (C) 2013 University of Chicago.\n  * See COPYRIGHT notice in top-level directory.\n  *\n  */\n-#line 8 \"codeslexer.l\"\n+#line 8 \"../src/iokernellang/codeslexer.l\"\n #include <stdlib.h>\n-#include \"CodesIOKernelTypes.h\"\n-#include \"CodesIOKernelParser.h\"\n+#include \"src/iokernellang/CodesIOKernelTypes.h\"\n+#include \"src/iokernellang/CodesIOKernelParser.h\"\n \n #define YY_NO_INPUT\n \n-#line 25 \"codeslexer.l\"\n+#line 25 \"../src/iokernellang/codeslexer.l\"\n \tYYLTYPE *CodesIOKernel_get_lloc  (yyscan_t yyscanner);\n \tint CodesIOKernel_lex_init (yyscan_t* scanner);\n \tint CodesIOKernel_lex(YYSTYPE * lvalp, YYLTYPE * llocp, void * scanner);\n@@ -568,7 +559,7 @@ static yyconst flex_int32_t yy_rule_can_match_eol[37] =\n         #define YY_USER_ACTION /* no user action */;\n #endif\n \n-#line 572 \"codeslexer.c\"\n+#line 563 \"../src/iokernellang/codeslexer.c\"\n \n #define INITIAL 0\n \n@@ -703,12 +694,7 @@ static int input (yyscan_t yyscanner );\n \n /* Amount of stuff to slurp up with each read. */\n #ifndef YY_READ_BUF_SIZE\n-#ifdef __ia64__\n-/* On IA-64, the buffer size is 16k, not 8k */\n-#define YY_READ_BUF_SIZE 16384\n-#else\n #define YY_READ_BUF_SIZE 8192\n-#endif /* __ia64__ */\n #endif\n \n /* Copy whatever the last rule matched to the standard output. */\n@@ -727,7 +713,7 @@ static int input (yyscan_t yyscanner );\n \tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\\n \t\t{ \\\n \t\tint c = '*'; \\\n-\t\tsize_t n; \\\n+\t\tunsigned n; \\\n \t\tfor ( n = 0; n < max_size && \\\n \t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\\n \t\t\tbuf[n] = (char) c; \\\n@@ -812,10 +798,10 @@ YY_DECL\n \tregister int yy_act;\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n \n-#line 43 \"codeslexer.l\"\n+#line 43 \"../src/iokernellang/codeslexer.l\"\n \n \n-#line 819 \"codeslexer.c\"\n+#line 805 \"../src/iokernellang/codeslexer.c\"\n \n     yylval = yylval_param;\n \n@@ -916,7 +902,7 @@ do_action:\t/* This label is used only to access EOF actions. */\n \n case 1:\n YY_RULE_SETUP\n-#line 45 \"codeslexer.l\"\n+#line 45 \"../src/iokernellang/codeslexer.l\"\n {\n \t\tif(yyextra->text != NULL)\n                 {\n@@ -929,7 +915,7 @@ YY_RULE_SETUP\n \tYY_BREAK\n case 2:\n YY_RULE_SETUP\n-#line 55 \"codeslexer.l\"\n+#line 55 \"../src/iokernellang/codeslexer.l\"\n {\n \t\tif(yyextra->text != NULL)\n                 {\n@@ -942,7 +928,7 @@ YY_RULE_SETUP\n \tYY_BREAK\n case 3:\n YY_RULE_SETUP\n-#line 65 \"codeslexer.l\"\n+#line 65 \"../src/iokernellang/codeslexer.l\"\n {\n \t\tif(yyextra->text != NULL)\n                 {\n@@ -955,7 +941,7 @@ YY_RULE_SETUP\n \tYY_BREAK\n case 4:\n YY_RULE_SETUP\n-#line 75 \"codeslexer.l\"\n+#line 75 \"../src/iokernellang/codeslexer.l\"\n {\n \t\tif(yyextra->text != NULL)\n                 {\n@@ -967,166 +953,166 @@ YY_RULE_SETUP\n \tYY_BREAK\n case 5:\n YY_RULE_SETUP\n-#line 84 \"codeslexer.l\"\n+#line 84 \"../src/iokernellang/codeslexer.l\"\n return GE;\n \tYY_BREAK\n case 6:\n YY_RULE_SETUP\n-#line 85 \"codeslexer.l\"\n+#line 85 \"../src/iokernellang/codeslexer.l\"\n return LE;\n \tYY_BREAK\n case 7:\n YY_RULE_SETUP\n-#line 86 \"codeslexer.l\"\n+#line 86 \"../src/iokernellang/codeslexer.l\"\n return EQ;\n \tYY_BREAK\n case 8:\n YY_RULE_SETUP\n-#line 87 \"codeslexer.l\"\n+#line 87 \"../src/iokernellang/codeslexer.l\"\n return NE;\n \tYY_BREAK\n case 9:\n YY_RULE_SETUP\n-#line 88 \"codeslexer.l\"\n+#line 88 \"../src/iokernellang/codeslexer.l\"\n return WHILE;\n \tYY_BREAK\n case 10:\n YY_RULE_SETUP\n-#line 89 \"codeslexer.l\"\n+#line 89 \"../src/iokernellang/codeslexer.l\"\n return IF;\n \tYY_BREAK\n case 11:\n YY_RULE_SETUP\n-#line 90 \"codeslexer.l\"\n+#line 90 \"../src/iokernellang/codeslexer.l\"\n return ELSE;\n \tYY_BREAK\n case 12:\n YY_RULE_SETUP\n-#line 91 \"codeslexer.l\"\n+#line 91 \"../src/iokernellang/codeslexer.l\"\n return PRINT;\n \tYY_BREAK\n case 13:\n YY_RULE_SETUP\n-#line 92 \"codeslexer.l\"\n+#line 92 \"../src/iokernellang/codeslexer.l\"\n return WRITE;\n \tYY_BREAK\n case 14:\n YY_RULE_SETUP\n-#line 93 \"codeslexer.l\"\n+#line 93 \"../src/iokernellang/codeslexer.l\"\n return WRITEAT;\n \tYY_BREAK\n case 15:\n YY_RULE_SETUP\n-#line 94 \"codeslexer.l\"\n+#line 94 \"../src/iokernellang/codeslexer.l\"\n return WRITE_ALL;\n \tYY_BREAK\n case 16:\n YY_RULE_SETUP\n-#line 95 \"codeslexer.l\"\n+#line 95 \"../src/iokernellang/codeslexer.l\"\n return WRITEAT_ALL;\n \tYY_BREAK\n case 17:\n YY_RULE_SETUP\n-#line 96 \"codeslexer.l\"\n+#line 96 \"../src/iokernellang/codeslexer.l\"\n return READ;\n \tYY_BREAK\n case 18:\n YY_RULE_SETUP\n-#line 97 \"codeslexer.l\"\n+#line 97 \"../src/iokernellang/codeslexer.l\"\n return READAT;\n \tYY_BREAK\n case 19:\n YY_RULE_SETUP\n-#line 98 \"codeslexer.l\"\n+#line 98 \"../src/iokernellang/codeslexer.l\"\n return READ_ALL;\n \tYY_BREAK\n case 20:\n YY_RULE_SETUP\n-#line 99 \"codeslexer.l\"\n+#line 99 \"../src/iokernellang/codeslexer.l\"\n return READAT_ALL;\n \tYY_BREAK\n case 21:\n YY_RULE_SETUP\n-#line 100 \"codeslexer.l\"\n+#line 100 \"../src/iokernellang/codeslexer.l\"\n return SYNC;\n \tYY_BREAK\n case 22:\n YY_RULE_SETUP\n-#line 101 \"codeslexer.l\"\n+#line 101 \"../src/iokernellang/codeslexer.l\"\n return DELETE;\n \tYY_BREAK\n case 23:\n YY_RULE_SETUP\n-#line 102 \"codeslexer.l\"\n+#line 102 \"../src/iokernellang/codeslexer.l\"\n return SLEEP;\n \tYY_BREAK\n case 24:\n YY_RULE_SETUP\n-#line 103 \"codeslexer.l\"\n+#line 103 \"../src/iokernellang/codeslexer.l\"\n return OPEN;\n \tYY_BREAK\n case 25:\n YY_RULE_SETUP\n-#line 104 \"codeslexer.l\"\n+#line 104 \"../src/iokernellang/codeslexer.l\"\n return CLOSE;\n \tYY_BREAK\n case 26:\n YY_RULE_SETUP\n-#line 105 \"codeslexer.l\"\n+#line 105 \"../src/iokernellang/codeslexer.l\"\n return FLUSH;\n \tYY_BREAK\n case 27:\n YY_RULE_SETUP\n-#line 106 \"codeslexer.l\"\n+#line 106 \"../src/iokernellang/codeslexer.l\"\n return SEEK;\n \tYY_BREAK\n case 28:\n YY_RULE_SETUP\n-#line 107 \"codeslexer.l\"\n+#line 107 \"../src/iokernellang/codeslexer.l\"\n return GETGROUPID;\n \tYY_BREAK\n case 29:\n YY_RULE_SETUP\n-#line 108 \"codeslexer.l\"\n+#line 108 \"../src/iokernellang/codeslexer.l\"\n return GETNUMGROUPS;\n \tYY_BREAK\n case 30:\n YY_RULE_SETUP\n-#line 109 \"codeslexer.l\"\n+#line 109 \"../src/iokernellang/codeslexer.l\"\n return GETGROUPRANK;\n \tYY_BREAK\n case 31:\n YY_RULE_SETUP\n-#line 110 \"codeslexer.l\"\n+#line 110 \"../src/iokernellang/codeslexer.l\"\n return GETGROUPSIZE;\n \tYY_BREAK\n case 32:\n YY_RULE_SETUP\n-#line 111 \"codeslexer.l\"\n+#line 111 \"../src/iokernellang/codeslexer.l\"\n return GETCURTIME;\n \tYY_BREAK\n case 33:\n YY_RULE_SETUP\n-#line 112 \"codeslexer.l\"\n+#line 112 \"../src/iokernellang/codeslexer.l\"\n return EXIT;\n \tYY_BREAK\n case 34:\n /* rule 34 can match eol */\n YY_RULE_SETUP\n-#line 114 \"codeslexer.l\"\n+#line 114 \"../src/iokernellang/codeslexer.l\"\n ;       /* ignore whitespace */\n \tYY_BREAK\n case 35:\n YY_RULE_SETUP\n-#line 116 \"codeslexer.l\"\n+#line 116 \"../src/iokernellang/codeslexer.l\"\n fprintf(stderr, \"Unknown character\\n\");\n \tYY_BREAK\n case 36:\n YY_RULE_SETUP\n-#line 117 \"codeslexer.l\"\n+#line 117 \"../src/iokernellang/codeslexer.l\"\n ECHO;\n \tYY_BREAK\n-#line 1130 \"codeslexer.c\"\n+#line 1116 \"../src/iokernellang/codeslexer.c\"\n case YY_STATE_EOF(INITIAL):\n \tyyterminate();\n \n@@ -1867,8 +1853,8 @@ YY_BUFFER_STATE CodesIOKernel__scan_string (yyconst char * yystr , yyscan_t yysc\n \n /** Setup the input buffer state to scan the given bytes. The next call to CodesIOKernel_lex() will\n  * scan from a @e copy of @a bytes.\n- * @param yybytes the byte buffer to scan\n- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.\n+ * @param bytes the byte buffer to scan\n+ * @param len the number of bytes in the buffer pointed to by @a bytes.\n  * @param yyscanner The scanner object.\n  * @return the newly allocated buffer state object.\n  */\n@@ -2274,7 +2260,7 @@ void CodesIOKernel_free (void * ptr , yyscan_t yyscanner)\n \n #define YYTABLES_NAME \"yytables\"\n \n-#line 117 \"codeslexer.l\"\n+#line 117 \"../src/iokernellang/codeslexer.l\"\n \n \n \n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 7,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/iokernellang/codeslexer.h",
                        "old_path": "src/iokernellang/codeslexer.h",
                        "binary": false,
                        "utf8_diff": "--- a/src/iokernellang/codeslexer.h\n+++ b/src/iokernellang/codeslexer.h\n@@ -2,9 +2,9 @@\n #define CodesIOKernel_HEADER_H 1\n #define CodesIOKernel_IN_HEADER 1\n \n-#line 6 \"codeslexer.h\"\n+#line 6 \"../src/iokernellang/codeslexer.h\"\n \n-#line 8 \"codeslexer.h\"\n+#line 8 \"../src/iokernellang/codeslexer.h\"\n \n #define  YY_INT_ALIGNED short int\n \n@@ -58,6 +58,7 @@ typedef int flex_int32_t;\n typedef unsigned char flex_uint8_t; \n typedef unsigned short int flex_uint16_t;\n typedef unsigned int flex_uint32_t;\n+#endif /* ! C99 */\n \n /* Limits of integral types. */\n #ifndef INT8_MIN\n@@ -88,8 +89,6 @@ typedef unsigned int flex_uint32_t;\n #define UINT32_MAX             (4294967295U)\n #endif\n \n-#endif /* ! C99 */\n-\n #endif /* ! FLEXINT_H */\n \n #ifdef __cplusplus\n@@ -132,15 +131,7 @@ typedef void* yyscan_t;\n \n /* Size of default input buffer. */\n #ifndef YY_BUF_SIZE\n-#ifdef __ia64__\n-/* On IA-64, the buffer size is 16k, not 8k.\n- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.\n- * Ditto for the __ia64__ case accordingly.\n- */\n-#define YY_BUF_SIZE 32768\n-#else\n #define YY_BUF_SIZE 16384\n-#endif /* __ia64__ */\n #endif\n \n #ifndef YY_TYPEDEF_YY_BUFFER_STATE\n@@ -311,12 +302,7 @@ static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);\n \n /* Amount of stuff to slurp up with each read. */\n #ifndef YY_READ_BUF_SIZE\n-#ifdef __ia64__\n-/* On IA-64, the buffer size is 16k, not 8k */\n-#define YY_READ_BUF_SIZE 16384\n-#else\n #define YY_READ_BUF_SIZE 8192\n-#endif /* __ia64__ */\n #endif\n \n /* Number of entries by which start-condition stack grows. */\n@@ -351,9 +337,9 @@ extern int CodesIOKernel_lex \\\n #undef YY_DECL\n #endif\n \n-#line 117 \"codeslexer.l\"\n+#line 117 \"../src/iokernellang/codeslexer.l\"\n \n \n-#line 358 \"codeslexer.h\"\n+#line 344 \"../src/iokernellang/codeslexer.h\"\n #undef CodesIOKernel_IN_HEADER\n #endif /* CodesIOKernel_HEADER_H */\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 8,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/common-net.c",
                        "old_path": "src/networks/model-net/common-net.c",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/src/networks/model-net/common-net.c\n@@ -0,0 +1,260 @@\n+#include \"codes/net/common-net.h\"\n+#include \"codes/quickhash.h\"\n+#include \"assert.h\"\n+\n+void append_to_message_list(  \n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index, \n+        message_list *msg) {\n+    if(thisq[index] == NULL) {\n+        thisq[index] = msg;\n+    } else {\n+        thistail[index]->next = msg;\n+        msg->prev = thistail[index];\n+    } \n+    thistail[index] = msg;\n+}\n+\n+void prepend_to_message_list(  \n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index, \n+        message_list *msg) {\n+    if(thisq[index] == NULL) {\n+        thistail[index] = msg;\n+    } else {\n+        thisq[index]->prev = msg;\n+        msg->next = thisq[index];\n+    } \n+    thisq[index] = msg;\n+}\n+\n+message_list* return_head(\n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index) {\n+    message_list *head = thisq[index];\n+    if(head != NULL) {\n+        thisq[index] = head->next;\n+        if(head->next != NULL) {\n+            head->next->prev = NULL;\n+            head->next = NULL;\n+        } else {\n+            thistail[index] = NULL;\n+        }\n+    }\n+    return head;\n+}\n+\n+message_list* return_tail(\n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index) {\n+    message_list *tail = thistail[index];\n+    assert(tail);\n+    if(tail->prev != NULL) {\n+        tail->prev->next = NULL;\n+        thistail[index] = tail->prev;\n+        tail->prev = NULL;\n+    } else {\n+        thistail[index] = NULL;\n+        thisq[index] = NULL;\n+    }\n+    return tail;\n+}\n+\n+void delete_from_message_list(message_list *** allq, message_list *** alltail,\n+        message_list *msg) {\n+    message_list ** thisq = allq[msg->port];\n+    message_list ** thistail = alltail[msg->port];\n+    if(thisq[msg->index] == msg) {\n+      thisq[msg->index] = msg->next;\n+    } \n+    if(thistail[msg->index] == msg) {\n+      thistail[msg->index] = msg->prev;\n+    }\n+    if(msg->prev != NULL) {\n+      msg->prev->next = msg->next;\n+    }\n+    if(msg->next != NULL) {\n+      msg->next->prev = msg->prev;\n+    }\n+}\n+\n+void add_to_message_list(message_list *** allq, message_list *** alltail,\n+        message_list *msg) {\n+    message_list ** thisq = allq[msg->port];\n+    message_list ** thistail = alltail[msg->port];\n+    if(thisq[msg->index] == msg->next) {\n+      thisq[msg->index] = msg;\n+    } \n+    if(thistail[msg->index] == msg->prev) {\n+      thistail[msg->index] = msg;\n+    }\n+    if(msg->prev != NULL) {\n+      msg->prev->next = msg;\n+    }\n+    if(msg->next != NULL) {\n+      msg->next->prev = msg;\n+    }\n+}\n+\n+void altq_append_to_message_list(  \n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index, \n+        message_list *msg) {\n+    assert(index == 0);\n+    if(thisq[index] == NULL) {\n+        thisq[index] = msg;\n+    } else {\n+        thistail[index]->altq_next = msg;\n+        msg->altq_prev = thistail[index];\n+    } \n+    thistail[index] = msg;\n+}\n+\n+void altq_prepend_to_message_list(  \n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index, \n+        message_list *msg) {\n+    assert(index == 0);\n+    if(thisq[index] == NULL) {\n+        thistail[index] = msg;\n+    } else {\n+        thisq[index]->altq_prev = msg;\n+        msg->altq_next = thisq[index];\n+    } \n+    thisq[index] = msg;\n+}\n+\n+message_list* altq_return_head(\n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index) {\n+    assert(index == 0);\n+    message_list *head = thisq[index];\n+    if(head != NULL) {\n+        thisq[index] = head->altq_next;\n+        if(head->altq_next != NULL) {\n+            head->altq_next->altq_prev = NULL;\n+            head->altq_next = NULL;\n+        } else {\n+            thistail[index] = NULL;\n+        }\n+    }\n+    return head;\n+}\n+\n+message_list* altq_return_tail(\n+        message_list ** thisq,\n+        message_list ** thistail,\n+        int index) {\n+    assert(index == 0);\n+    message_list *tail = thistail[index];\n+    assert(tail);\n+    if(tail->altq_prev != NULL) {\n+        tail->altq_prev->altq_next = NULL;\n+        thistail[index] = tail->altq_prev;\n+        tail->altq_prev = NULL;\n+    } else {\n+        thistail[index] = NULL;\n+        thisq[index] = NULL;\n+    }\n+    return tail;\n+}\n+\n+void altq_delete_from_message_list(message_list *** allq, message_list *** alltail,\n+        message_list *msg) {\n+    message_list ** thisq = allq[msg->altq_port];\n+    message_list ** thistail = alltail[msg->altq_port];\n+    if(thisq[0] == msg) {\n+      thisq[0] = msg->altq_next;\n+    } \n+    if(thistail[0] == msg) {\n+      thistail[0] = msg->altq_prev;\n+    }\n+    if(msg->altq_prev != NULL) {\n+      msg->altq_prev->altq_next = msg->altq_next;\n+    }\n+    if(msg->altq_next != NULL) {\n+      msg->altq_next->altq_prev = msg->altq_prev;\n+    }\n+}\n+\n+void altq_add_to_message_list(message_list *** allq, message_list *** alltail,\n+        message_list *msg) {\n+    message_list ** thisq = allq[msg->altq_port];\n+    message_list ** thistail = alltail[msg->altq_port];\n+    if(thisq[0] == msg->altq_next) {\n+      thisq[0] = msg;\n+    } \n+    if(thistail[0] == msg->altq_prev) {\n+      thistail[0] = msg;\n+    }\n+    if(msg->altq_prev != NULL) {\n+      msg->altq_prev->altq_next = msg;\n+    }\n+    if(msg->altq_next != NULL) {\n+      msg->altq_next->altq_prev = msg;\n+    }\n+}\n+\n+void delete_message_list(void *thisM) {\n+    message_list *thism = (message_list *)thisM;\n+    if(thism->event_data != NULL) free(thism->event_data);\n+    free(thism);\n+}\n+\n+int mn_rank_hash_compare(void *key, struct qhash_head *link)\n+{\n+  struct mn_hash_key *message_key = (struct mn_hash_key *)key;\n+  struct mn_qhash_entry *tmp = NULL;\n+\n+  tmp = qhash_entry(link, struct mn_qhash_entry, hash_link);\n+\n+  if (tmp->key.message_id == message_key->message_id\n+      && tmp->key.sender_id == message_key->sender_id)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int mn_hash_func(void *k, int table_size)\n+{\n+  struct mn_hash_key *tmp = (struct mn_hash_key *)k;\n+  uint64_t key = (~tmp->message_id) + (tmp->message_id << 18);\n+  key = key * 21;\n+  key = ~key ^ (tmp->sender_id >> 4);\n+  key = key * tmp->sender_id; \n+  return (int)(key & (table_size - 1));\n+}\n+\n+void free_tmp(void * ptr)\n+{\n+  struct mn_qhash_entry * msg = ptr; \n+\n+  if(msg->remote_event_data)\n+    free(msg->remote_event_data);\n+\n+  if(msg)\n+    free(msg);\n+}\n+\n+/* convert GiB/s and bytes to ns */\n+tw_stime bytes_to_ns(uint64_t bytes, double GB_p_s)\n+{\n+  tw_stime time;\n+\n+  /* bytes to GB */\n+  time = ((double)bytes)/(1024.0*1024.0*1024.0);\n+  /* GiB to s */\n+  time = time / GB_p_s;\n+  /* s to ns */\n+  time = time * 1000.0 * 1000.0 * 1000.0;\n+  return(time);\n+}\n+\n+\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 9,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/doc/README.fattree.txt",
                        "old_path": "src/networks/model-net/doc/README.fattree.txt",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/doc/README.fattree.txt\n+++ b/src/networks/model-net/doc/README.fattree.txt\n@@ -51,15 +51,21 @@ Supported PARAMS:\n packet_size, chunk_size (ideally kept same)\n modelnet_scheduler - NIC message scheduler\n modelnet_order=( \"fattree\" ); \n-router_delay : delay caused by switched in ns\n num_levels : number of levels in the fattree (same as fattree_switch)\n+tapering : controls division of ports to nodes at leaf level\n switch_count : number of leaf level switches (same as repetitions)\n switch_radix : radix of the switches\n+router_delay : delay caused by switched in ns\n vc_size : size of switch VCs in bytes\n cn_vc_size : size of VC between NIC and switch in bytes\n link_bandwidth, cn_bandwidth : in GB/s\n routing : {adaptive, static}\n \n+For radix k switches with tapering t, t*k/(t+1) ports are used for connecting\n+to nodes, and remaining are connected to next level switches. fmod(k, t+1) has\n+to be 0. Default tapering is 1, i.e. full bandwidth. Note that, even when\n+tapering is >1, the number of leaf level switches in a Pod are k/2.\n+\n 2- Static Routing\n If static routing is chosen, two more PARAMS must be provided:\n routing_folder :  folder that contain lft files generated using method described below.\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 10,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/dragonfly.c",
                        "old_path": "src/networks/model-net/dragonfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/dragonfly.c\n+++ b/src/networks/model-net/dragonfly.c\n@@ -91,8 +91,8 @@ FILE * dragonfly_log = NULL;\n int sample_bytes_written = 0;\n int sample_rtr_bytes_written = 0;\n \n-char cn_sample_file[MAX_NAME_LENGTH];\n-char router_sample_file[MAX_NAME_LENGTH];\n+char dfly_cn_sample_file[MAX_NAME_LENGTH];\n+char dfly_rtr_sample_file[MAX_NAME_LENGTH];\n \n typedef struct terminal_message_list terminal_message_list;\n struct terminal_message_list {\n@@ -590,9 +590,9 @@ static void dragonfly_read_config(const char * anno, dragonfly_param *params){\n     configuration_get_value_double(&config, \"PARAMS\", \"router_delay\", anno,\n             &p->router_delay);\n \n-    configuration_get_value(&config, \"PARAMS\", \"cn_sample_file\", anno, cn_sample_file,\n+    configuration_get_value(&config, \"PARAMS\", \"cn_sample_file\", anno, dfly_cn_sample_file,\n             MAX_NAME_LENGTH);\n-    configuration_get_value(&config, \"PARAMS\", \"rt_sample_file\", anno, router_sample_file,\n+    configuration_get_value(&config, \"PARAMS\", \"rt_sample_file\", anno, dfly_rtr_sample_file,\n             MAX_NAME_LENGTH);\n     \n     char routing_str[MAX_NAME_LENGTH];\n@@ -2143,10 +2143,10 @@ static void dragonfly_rsample_fin(router_state * s,\n         fclose(fp);\n     }\n     char rt_fn[MAX_NAME_LENGTH];\n-    if(strcmp(router_sample_file, \"\") == 0)\n+    if(strcmp(dfly_rtr_sample_file, \"\") == 0)\n         sprintf(rt_fn, \"dragonfly-router-sampling-%ld.bin\", g_tw_mynode); \n     else\n-        sprintf(rt_fn, \"%s-%ld.bin\", router_sample_file, g_tw_mynode);\n+        sprintf(rt_fn, \"%s-%ld.bin\", dfly_rtr_sample_file, g_tw_mynode);\n     \n     int i = 0;\n \n@@ -2305,10 +2305,10 @@ static void dragonfly_sample_fin(terminal_state * s,\n         fclose(fp);\n     }\n     char rt_fn[MAX_NAME_LENGTH];\n-    if(strncmp(cn_sample_file, \"\", 10) == 0)\n+    if(strncmp(dfly_cn_sample_file, \"\", 10) == 0)\n         sprintf(rt_fn, \"dragonfly-cn-sampling-%ld.bin\", g_tw_mynode); \n     else\n-        sprintf(rt_fn, \"%s-%ld.bin\", cn_sample_file, g_tw_mynode);\n+        sprintf(rt_fn, \"%s-%ld.bin\", dfly_cn_sample_file, g_tw_mynode);\n \n     FILE * fp = fopen(rt_fn, \"a\");\n     fseek(fp, sample_bytes_written, SEEK_SET);\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 11,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/express-mesh.C",
                        "old_path": "src/networks/model-net/express-mesh.C",
                        "binary": false,
                        "utf8_diff": "--- /dev/null\n+++ b/src/networks/model-net/express-mesh.C\n@@ -0,0 +1,2540 @@\n+#include <ross.h>\n+\n+#include \"codes/jenkins-hash.h\"\n+#include \"codes/codes_mapping.h\"\n+#include \"codes/codes.h\"\n+#include \"codes/model-net.h\"\n+#include \"codes/model-net-method.h\"\n+#include \"codes/model-net-lp.h\"\n+#include \"codes/net/express-mesh.h\"\n+#include \"codes/net/common-net.h\"\n+#include \"sys/file.h\"\n+#include \"codes/quickhash.h\"\n+#include \"codes/rc-stack.h\"\n+#include <vector>\n+\n+#define CREDIT_SZ 8\n+\n+#define EM_HASH_TABLE_SIZE 262144\n+\n+#define DEBUG 0\n+#define MAX_STATS 65536\n+#define MULT_FACTOR 2\n+\n+#define LP_CONFIG_NM_TERM (model_net_lp_config_names[EXPRESS_MESH])\n+#define LP_METHOD_NM_TERM (model_net_method_names[EXPRESS_MESH])\n+#define LP_CONFIG_NM_ROUT (model_net_lp_config_names[EXPRESS_MESH_ROUTER])\n+#define LP_METHOD_NM_ROUT (model_net_method_names[EXPRESS_MESH_ROUTER])\n+\n+static long packet_gen = 0, packet_fin = 0;\n+\n+static double maxd(double a, double b) { return a < b ? b : a; }\n+\n+typedef struct em_param em_param;\n+/* annotation-specific parameters (unannotated entry occurs at the \n+ * last index) */\n+static uint64_t                  num_params = 0;\n+static em_param         * all_params = NULL;\n+static const config_anno_map_t * anno_map   = NULL;\n+\n+/* global variables for codes mapping */\n+static char lp_group_name[MAX_NAME_LENGTH];\n+static int mapping_grp_id, mapping_type_id, mapping_rep_id, mapping_offset;\n+\n+/* router magic number */\n+static int router_magic_num = 0;\n+\n+/* terminal magic number */\n+static int terminal_magic_num = 0;\n+\n+static int sample_bytes_written = 0;\n+static int sample_rtr_bytes_written = 0;\n+\n+char em_cn_sample_file[MAX_NAME_LENGTH];\n+char em_rtr_sample_file[MAX_NAME_LENGTH];\n+\n+static void init_message_list(message_list *thism, \n+    em_message *inmsg) {\n+  thism->em_msg = *inmsg;\n+  thism->event_data = NULL;\n+  thism->next = NULL;\n+  thism->prev = NULL;\n+  thism->in_alt_q = 0;\n+  thism->altq_next = NULL;\n+  thism->altq_prev = NULL;\n+}\n+\n+struct em_param\n+{\n+  int n_dims; // Dimensions in the base torus layout\n+  int *dim_length;\n+  int gap; // Gap at which nodes are connected (0 for log)\n+  double link_bandwidth;/* bandwidth of each link */\n+  double cn_bandwidth;/* injection bandwidth */\n+  int num_cn; // number of nodes per router\n+  int num_vcs; /* number of virtual channels */\n+  int vc_size; /* buffer size of the router-router channels */\n+  int cn_vc_size; /* buffer size of the compute node channels */\n+  int chunk_size; /* full-sized packets are broken into smaller chunks.*/\n+  int router_delay;\n+  int routing;\n+  //derived param\n+  int * factor; /* used in torus coordinate calculation */ \n+  int radix, *cons_per_dim, *offset_per_dim;\n+  int total_routers;\n+  int total_terminals;\n+  double cn_delay;\n+  double link_delay;\n+  double credit_delay;\n+};\n+\n+struct em_router_sample\n+{\n+  tw_lpid router_id;\n+  tw_stime* busy_time;\n+  int64_t* link_traffic_sample;\n+  tw_stime end_time;\n+  long fwd_events;\n+  long rev_events;\n+};\n+\n+struct em_cn_sample\n+{\n+  tw_lpid terminal_id;\n+  long fin_chunks_sample;\n+  long data_size_sample;\n+  double fin_hops_sample;\n+  tw_stime fin_chunks_time;\n+  tw_stime busy_time_sample;\n+  tw_stime end_time;\n+  long fwd_events;\n+  long rev_events;\n+};\n+\n+/* handles terminal and router events like packet generate/send/receive/buffer */\n+typedef struct terminal_state terminal_state;\n+typedef struct router_state router_state;\n+\n+/* EM compute node data structure */\n+struct terminal_state\n+{\n+  uint64_t packet_counter;\n+\n+  int packet_gen;\n+  int packet_fin;\n+ \n+  //who am I\n+  unsigned int terminal_id; //what is my local id\n+\n+  //which router I am connected to \n+  unsigned int router_id; \n+  tw_lpid router_gid;\n+\n+  // Each terminal will have an input/output channel(s) with the router\n+  int** vc_occupancy; // NUM_VC\n+  tw_stime terminal_available_time;\n+\n+  //available messages\n+  message_list ***terminal_msgs;\n+  message_list ***terminal_msgs_tail;\n+  int terminal_length;\n+  int in_send_loop;\n+  int issueIdle;\n+\n+  //packet aggregation\n+  struct qhash_table *rank_tbl;\n+  //transient storage\n+  struct rc_stack * st;\n+\n+  const char * anno;\n+  const em_param *params;\n+\n+  //stats\n+  struct mn_stats em_stats_array[CATEGORY_MAX];\n+  tw_stime   total_time;\n+  uint64_t total_msg_size;\n+  double total_hops;\n+  long finished_msgs;\n+  long finished_chunks;\n+  long finished_packets;\n+\n+  //sampling\n+  tw_stime last_buf_full;\n+  tw_stime busy_time;\n+  char output_buf[4096];\n+  long fin_chunks_sample;\n+  long data_size_sample;\n+  double fin_hops_sample;\n+  tw_stime fin_chunks_time;\n+  tw_stime busy_time_sample;\n+  char sample_buf[4096];\n+  struct em_cn_sample * sample_stat;\n+  int op_arr_size;\n+  int max_arr_size;\n+\n+  /* for logging forward and reverse events */\n+  long fwd_events;\n+  long rev_events;\n+};\n+\n+/* terminal event type (1-4) */\n+enum event_t\n+{\n+  T_GENERATE=1,\n+  T_ARRIVE,\n+  T_SEND,\n+  T_BUFFER,\n+  R_SEND,\n+  R_ARRIVE,\n+  R_BUFFER,\n+};\n+typedef enum event_t event_t;\n+\n+/* whether the last hop of a packet was global, local or a terminal */\n+enum last_hop\n+{\n+  ROUTER=1,\n+  TERMINAL\n+};\n+\n+enum ROUTING_ALGO\n+{\n+  STATIC = 0,\n+  ADAPTIVE,\n+};\n+\n+struct router_state\n+{\n+  //who am I\n+  unsigned int router_id;\n+  int* dim_position;\n+\n+  tw_lpid* link_connections;\n+\n+  tw_stime* next_output_available_time;\n+  message_list ***pending_msgs;\n+  message_list ***pending_msgs_tail;\n+  message_list ***queued_msgs;\n+  message_list ***queued_msgs_tail;\n+  int *in_send_loop;\n+  int *queued_count;\n+  struct rc_stack * st;\n+\n+  int** vc_occupancy;\n+  int64_t* link_traffic;\n+\n+  const char * anno;\n+  const em_param *params;\n+\n+  //sampling and stats\n+  tw_stime* last_buf_full;\n+  char output_buf[4096];\n+  char output_buf2[4096];\n+  tw_stime* busy_time;\n+  tw_stime* busy_time_sample;\n+  struct em_router_sample * rsamples;\n+  int op_arr_size;\n+  int max_arr_size;\n+  long fwd_events;\n+  long rev_events;\n+  int64_t * link_traffic_sample;\n+};\n+\n+struct VC_Entry {\n+  int vc;\n+  message_list* entry;\n+};\n+\n+//global stats\n+static tw_stime         em_total_time = 0;\n+static tw_stime         em_max_latency = 0;\n+\n+static long long       total_hops = 0;\n+static long long       N_finished_packets = 0;\n+static long long       total_msg_sz = 0;\n+static long long       N_finished_msgs = 0;\n+static long long       N_finished_chunks = 0;\n+\n+/* returns the EM message size */\n+static int em_get_msg_sz(void)\n+{\n+  return sizeof(em_message);\n+}\n+\n+/* helper functions - convert between flat ids and torus n-dimensional ids */\n+static void to_dim_id(\n+    int flat_id,\n+    int ndims,\n+    const int *dim_lens,\n+    int *out_dim_ids)\n+{\n+  for (int i = 0; i < ndims; i++) {\n+    out_dim_ids[i] = flat_id % dim_lens[i];\n+    flat_id /= dim_lens[i];\n+  }\n+}\n+\n+static int to_flat_id(\n+    int ndims,\n+    const int *dim_lens,\n+    const int *dim_ids)\n+{\n+  int flat_id = dim_ids[0];\n+  int mult = dim_lens[0];\n+  for (int i = 1; i < ndims; i++) {\n+    flat_id += dim_ids[i] * mult;\n+    mult *= dim_lens[i];\n+  }\n+  return flat_id;\n+}\n+\n+static void em_read_config(const char * anno, em_param *params){\n+  em_param *p = params;\n+  \n+  int rc = configuration_get_value_int(&config, \"PARAMS\", \"n_dims\", anno, \n+      &p->n_dims);\n+  if(rc) {\n+    tw_error(TW_LOC, \"Number of dimensions not specified\\n\");\n+  }\n+  \n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"gap\", anno, &p->gap);\n+  if(rc) {\n+    tw_error(TW_LOC, \"Gap not specified\\n\");\n+  }\n+    \n+  char dim_length_str[MAX_NAME_LENGTH];\n+  rc = configuration_get_value(&config, \"PARAMS\", \"dim_length\", anno,\n+      dim_length_str, MAX_NAME_LENGTH);\n+  if (rc == 0){\n+    tw_error(TW_LOC, \"couldn't read PARAMS:dim_length\");\n+  }\n+  char* token;\n+  p->dim_length= (int*)malloc(p->n_dims * sizeof(*p->dim_length));\n+  token = strtok(dim_length_str, \",\");\n+  int i = 0;\n+  while(token != NULL)\n+  {\n+    sscanf(token, \"%d\", &p->dim_length[i]);\n+    if(p->dim_length[i] <= 0)\n+    {\n+      tw_error(TW_LOC, \"Invalid torus dimension specified \"\n+          \"(%d at pos %d), exiting... \", p->dim_length[i], i);\n+    }\n+    i++;\n+    token = strtok(NULL,\",\");\n+  }\n+  \n+  rc = configuration_get_value_double(&config, \"PARAMS\", \"link_bandwidth\", \n+      anno, &p->link_bandwidth);\n+  if(rc) {\n+    p->link_bandwidth = 5.25;\n+    fprintf(stderr, \"Bandwidth of links  not specified, setting to %lf\\n\", \n+        p->link_bandwidth);\n+  }\n+\n+  rc = configuration_get_value_double(&config, \"PARAMS\", \"cn_bandwidth\", \n+      anno, &p->cn_bandwidth);\n+  if(rc) {\n+    p->cn_bandwidth = 5.25;\n+    fprintf(stderr, \"Bandwidth of compute node channels not specified, setting \"\n+        \"to %lf\\n\", p->cn_bandwidth);\n+  }\n+\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"num_cn\", anno, \n+      &p->num_cn);\n+  if(rc) {\n+    tw_error(TW_LOC, \"Nodes per router (num_cn) not specified\\n\");\n+  }\n+\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"num_vcs\", anno, \n+      &p->num_vcs);\n+  if(rc) {\n+    p->num_vcs = 1;\n+  }\n+  \n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"chunk_size\", anno, \n+      &p->chunk_size);\n+  if(rc) {\n+    p->chunk_size = 512;\n+    fprintf(stderr, \"Chunk size for packets is specified, setting to %d\\n\", \n+      p->chunk_size);\n+  }\n+\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"vc_size\", anno, \n+      &p->vc_size);\n+  if(rc) {\n+    p->vc_size = 32768;\n+    fprintf(stderr, \"Buffer size of link channels not specified, setting to %d\\n\", \n+      p->vc_size);\n+  }\n+\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"cn_vc_size\", anno, \n+      &p->cn_vc_size);\n+  if(rc) {\n+    p->cn_vc_size = 65536;\n+    fprintf(stderr, \"Buffer size of compute node channels not specified, \"\n+        \"setting to %d\\n\", p->cn_vc_size);\n+  }\n+\n+  p->router_delay = 50;\n+  configuration_get_value_int(&config, \"PARAMS\", \"router_delay\", anno,\n+      &p->router_delay);\n+\n+  configuration_get_value(&config, \"PARAMS\", \"cn_sample_file\", anno, \n+      em_cn_sample_file, MAX_NAME_LENGTH);\n+  configuration_get_value(&config, \"PARAMS\", \"rt_sample_file\", anno, \n+      em_rtr_sample_file, MAX_NAME_LENGTH);\n+\n+  char routing_str[MAX_NAME_LENGTH];\n+  configuration_get_value(&config, \"PARAMS\", \"routing\", anno, routing_str,\n+      MAX_NAME_LENGTH);\n+  if(strcmp(routing_str, \"static\") == 0)\n+    p->routing = STATIC;\n+  else if (strcmp(routing_str, \"adaptive\") == 0) {\n+    p->routing = ADAPTIVE;\n+    if(p->num_vcs < 2) {\n+      p->num_vcs = 2;\n+    }\n+  }\n+  else\n+  {\n+    p->routing = STATIC;\n+    fprintf(stderr, \n+        \"No routing protocol specified, setting to static routing\\n\");\n+  }\n+\n+  // set the derived parameters\n+  p->radix = 0;\n+  p->total_routers = 1;\n+  p->cons_per_dim = (int *)malloc(p->n_dims * sizeof(int));\n+  p->offset_per_dim = (int *)malloc(p->n_dims * sizeof(int));\n+  for(int i = 0; i < p->n_dims; i++) {\n+    p->cons_per_dim[i] = 2 + (p->dim_length[i] - 3)/p->gap;\n+    p->radix += p->cons_per_dim[i];\n+    p->total_routers *= p->dim_length[i];\n+    if(i == 0) {\n+      p->offset_per_dim[i] = p->num_cn;\n+    } else {\n+      p->offset_per_dim[i] = p->offset_per_dim[i - 1] + p->cons_per_dim[i - 1];\n+    }\n+  }\n+\n+  if(p->num_cn != (p->radix/(p->n_dims * p->gap))) {\n+    printf(\"Unbalanced system: expected num_cn - %d, obtained %d\\n\",\n+      p->radix/(p->n_dims * p->gap), p->num_cn);\n+  }\n+  p->radix += p->num_cn;\n+  p->total_terminals = p->total_routers * p->num_cn;\n+\n+  int rank;\n+  MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n+  if(!rank) {\n+    printf(\"\\n Total nodes %d routers %d radix %d \\n\",\n+        p->total_terminals, p->total_routers, p->radix);\n+  }\n+\n+  p->cn_delay = bytes_to_ns(1, p->cn_bandwidth);\n+  p->link_delay = bytes_to_ns(1, p->link_bandwidth);\n+  p->credit_delay = bytes_to_ns(CREDIT_SZ, p->link_bandwidth);\n+}\n+\n+static void em_configure(){\n+  anno_map = codes_mapping_get_lp_anno_map(LP_CONFIG_NM_TERM);\n+  assert(anno_map);\n+  num_params = anno_map->num_annos + (anno_map->has_unanno_lp > 0);\n+  all_params = (em_param *)malloc(num_params * sizeof(*all_params));\n+\n+  for (int i = 0; i < anno_map->num_annos; i++){\n+    const char * anno = anno_map->annotations[i].ptr;\n+    em_read_config(anno, &all_params[i]);\n+  }\n+  if (anno_map->has_unanno_lp > 0){\n+    em_read_config(NULL, &all_params[anno_map->num_annos]);\n+  }\n+}\n+\n+/* report EM statistics like average and maximum packet latency, average number of hops traversed */\n+static void em_report_stats()\n+{\n+  long long avg_hops, total_finished_packets, total_finished_chunks;\n+  long long total_finished_msgs, final_msg_sz;\n+  tw_stime avg_time, max_time;\n+  int total_minimal_packets, total_nonmin_packets;\n+  long total_gen, total_fin;\n+\n+  MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0, \n+      MPI_COMM_WORLD);\n+  MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG, \n+      MPI_SUM, 0, MPI_COMM_WORLD);\n+  MPI_Reduce( &N_finished_msgs, &total_finished_msgs, 1, MPI_LONG_LONG, MPI_SUM, \n+      0, MPI_COMM_WORLD);\n+  MPI_Reduce( &N_finished_chunks, &total_finished_chunks, 1, MPI_LONG_LONG, \n+      MPI_SUM, 0, MPI_COMM_WORLD);\n+  MPI_Reduce( &total_msg_sz, &final_msg_sz, 1, MPI_LONG_LONG, MPI_SUM, 0, \n+      MPI_COMM_WORLD);\n+  MPI_Reduce( &em_total_time, &avg_time, 1,MPI_DOUBLE, MPI_SUM, 0, \n+      MPI_COMM_WORLD);\n+  MPI_Reduce( &em_max_latency, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0, \n+      MPI_COMM_WORLD);\n+\n+  MPI_Reduce( &packet_gen, &total_gen, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n+  MPI_Reduce( &packet_fin, &total_fin, 1, MPI_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n+\n+  /* print statistics */\n+  if(!g_tw_mynode)\n+  {\t\n+    printf(\" Average number of hops traversed %f average chunk latency %lf us \"\n+      \"maximum chunk latency %lf us avg message size %lf bytes finished \"\n+      \"messages %lld finished chunks %lld \\n\", \n+      (float)avg_hops/total_finished_chunks, \n+      avg_time/(total_finished_chunks*1000), max_time/1000, \n+      (float)final_msg_sz/total_finished_msgs, total_finished_msgs, \n+      total_finished_chunks);\n+    printf(\"\\n Total packets generated %ld finished %ld \\n\", total_gen, total_fin);\n+  }\n+  return;\n+}\n+\n+/* initialize a EM compute node terminal */\n+static void \n+terminal_init( terminal_state * s, tw_lp * lp )\n+{\n+  s->packet_gen = 0;\n+  s->packet_fin = 0;\n+\n+  uint32_t h1 = 0, h2 = 0; \n+  bj_hashlittle2(LP_METHOD_NM_TERM, strlen(LP_METHOD_NM_TERM), &h1, &h2);\n+  terminal_magic_num = h1 + h2;\n+\n+  int i;\n+  char anno[MAX_NAME_LENGTH];\n+  codes_mapping_get_lp_info(lp->gid, lp_group_name, &mapping_grp_id, NULL,\n+      &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n+\n+  if (anno[0] == '\\0') {\n+    s->anno = NULL;\n+    s->params = &all_params[num_params-1];\n+  } else {\n+    s->anno = strdup(anno);\n+    int id = configuration_get_annotation_index(anno, anno_map);\n+    s->params = &all_params[id];\n+  }\n+\n+  int num_lps = codes_mapping_get_lp_count(lp_group_name, 0, LP_CONFIG_NM_TERM,\n+      s->anno, 0);\n+\n+  if(num_lps != s->params->total_terminals) {\n+    tw_error(TW_LOC, \"Number of terminals LP does not match number of nodes\\n\");\n+  }\n+\n+  s->terminal_id = codes_mapping_get_lp_relative_id(lp->gid, 0, 0);  \n+\n+  s->router_id = (int)s->terminal_id / s->params->num_cn;\n+  s->router_gid = codes_mapping_get_lpid_from_relative(s->router_id, NULL, \n+      LP_CONFIG_NM_ROUT, s->anno, 1);\n+\n+  s->terminal_available_time = 0.0;\n+  s->packet_counter = 0;\n+  s->finished_msgs = 0;\n+  s->finished_chunks = 0;\n+  s->finished_packets = 0;\n+  s->total_time = 0.0;\n+  s->total_msg_size = 0;\n+\n+  s->last_buf_full = 0.0;\n+  s->busy_time = 0.0;\n+\n+  s->fwd_events = 0;\n+  s->rev_events = 0;\n+\n+  rc_stack_create(&s->st);\n+  s->vc_occupancy = (int **)malloc(sizeof(int*));\n+\n+  s->vc_occupancy[0] = (int*)malloc(s->params->num_vcs * sizeof(int));\n+  for(i = 0; i < s->params->num_vcs; i++ ) {\n+    s->vc_occupancy[0][i] = 0;\n+  }\n+\n+  s->rank_tbl = qhash_init(mn_rank_hash_compare, mn_hash_func, EM_HASH_TABLE_SIZE);\n+\n+  if(!s->rank_tbl)\n+    tw_error(TW_LOC, \"\\n Hash table not initialized! \");\n+\n+  s->terminal_msgs = (message_list ***)malloc(sizeof(message_list**));\n+  s->terminal_msgs_tail = (message_list ***)malloc(sizeof(message_list**));\n+  s->terminal_msgs[0] = \n+    (message_list **)malloc(s->params->num_vcs * sizeof(message_list*));\n+  s->terminal_msgs_tail[0] = \n+    (message_list **)malloc(s->params->num_vcs * sizeof(message_list*));\n+  for(i = 0; i < s->params->num_vcs; i++ ) {\n+    s->terminal_msgs[0][i] = NULL;\n+    s->terminal_msgs_tail[0][i] = NULL;\n+  }\n+  s->terminal_length = 0;\n+  s->in_send_loop = 0;\n+  s->issueIdle = 0;\n+\n+  return;\n+}\n+\n+static void router_setup(router_state * r, tw_lp * lp)\n+{\n+  uint32_t h1 = 0, h2 = 0; \n+  bj_hashlittle2(LP_METHOD_NM_ROUT, strlen(LP_METHOD_NM_ROUT), &h1, &h2);\n+  router_magic_num = h1 + h2;\n+\n+  char anno[MAX_NAME_LENGTH];\n+  codes_mapping_get_lp_info(lp->gid, lp_group_name, &mapping_grp_id, NULL,\n+      &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n+\n+  if (anno[0] == '\\0'){\n+    r->anno = NULL;\n+    r->params = &all_params[num_params-1];\n+  } else{\n+    r->anno = strdup(anno);\n+    int id = configuration_get_annotation_index(anno, anno_map);\n+    r->params = &all_params[id];\n+  }\n+  \n+  em_param *p = (em_param *)r->params;\n+  r->dim_position = (int *)malloc(p->n_dims * sizeof(int));\n+  r->link_connections = (tw_lpid *)malloc(p->radix * sizeof(tw_lpid));\n+\n+  r->router_id = codes_mapping_get_lp_relative_id(lp->gid, 0, 0);\n+  to_dim_id(r->router_id, r->params->n_dims, r->params->dim_length, \n+      r->dim_position);\n+\n+  //set up connections\n+  int curr_con = 0;\n+  int first = r->router_id * p->num_cn;\n+  for(; curr_con < p->num_cn; curr_con++) {\n+    r->link_connections[curr_con] = codes_mapping_get_lpid_from_relative(\n+      first, NULL, LP_CONFIG_NM_TERM, r->anno, 1);\n+    first++;\n+  }\n+  \n+  int temp_dim_pos[p->n_dims];\n+  for(int i = 0; i < p->n_dims; i++)\n+    temp_dim_pos[i] = r->dim_position[i];\n+\n+  for(int curr_dim = 0; curr_dim < p->n_dims; curr_dim++) {\n+    curr_con = p->offset_per_dim[curr_dim];\n+    for(int loc = 0; loc < p->dim_length[curr_dim]; loc++) {\n+      if(loc != r->dim_position[curr_dim]) {\n+        if(loc == r->dim_position[curr_dim] - 1 || \n+           loc == r->dim_position[curr_dim] + 1 ||\n+           (loc < r->dim_position[curr_dim] && \n+           ((r->dim_position[curr_dim] - 1 - loc) % p->gap == 0)) || \n+           (loc > r->dim_position[curr_dim] && \n+           ((loc - r->dim_position[curr_dim] - 1) % p->gap == 0))) {\n+          temp_dim_pos[curr_dim] = loc;\n+          int neigh_id = to_flat_id(p->n_dims, p->dim_length, temp_dim_pos);\n+          temp_dim_pos[curr_dim] = r->dim_position[curr_dim];\n+          r->link_connections[curr_con] = codes_mapping_get_lpid_from_relative(\n+              neigh_id, NULL, LP_CONFIG_NM_ROUT, r->anno, 1);\n+          curr_con++;\n+        }\n+      }\n+    }\n+  }\n+\n+  r->fwd_events = 0;\n+  r->rev_events = 0;\n+\n+  r->next_output_available_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+  r->link_traffic = (int64_t*)malloc(p->radix * sizeof(int64_t));\n+  r->link_traffic_sample = (int64_t*)malloc(p->radix * sizeof(int64_t));\n+\n+  r->vc_occupancy = (int**)malloc(p->radix * sizeof(int*));\n+  r->in_send_loop = (int*)malloc(p->radix * sizeof(int));\n+  r->pending_msgs = \n+    (message_list ***)malloc(p->radix * sizeof(message_list**));\n+  r->pending_msgs_tail = \n+    (message_list ***)malloc(p->radix * sizeof(message_list**));\n+  r->queued_msgs = \n+    (message_list ***)malloc(p->radix * sizeof(message_list**));\n+  r->queued_msgs_tail = \n+    (message_list ***)malloc(p->radix * sizeof(message_list**));\n+  r->queued_count = (int*)malloc(p->radix * sizeof(int));\n+  r->last_buf_full = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+  r->busy_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+  r->busy_time_sample = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n+\n+  rc_stack_create(&r->st);\n+  for(int i = 0; i < p->radix; i++)\n+  {\n+    // Set credit & router occupancy\n+    r->last_buf_full[i] = 0.0;\n+    r->busy_time[i] = 0.0;\n+    r->busy_time_sample[i] = 0.0;\n+    r->next_output_available_time[i] = 0;\n+    r->link_traffic[i] = 0;\n+    r->link_traffic_sample[i] = 0;\n+    r->queued_count[i] = 0;    \n+    r->in_send_loop[i] = 0;\n+    r->vc_occupancy[i] = (int *)malloc(p->num_vcs * sizeof(int));\n+    r->pending_msgs[i] = (message_list **)malloc(p->num_vcs * \n+        sizeof(message_list*));\n+    r->pending_msgs_tail[i] = (message_list **)malloc(p->num_vcs * \n+        sizeof(message_list*));\n+    r->queued_msgs[i] = (message_list **)malloc(p->num_vcs * \n+        sizeof(message_list*));\n+    r->queued_msgs_tail[i] = (message_list **)malloc(p->num_vcs * \n+        sizeof(message_list*));\n+    for(int j = 0; j < p->num_vcs; j++) {\n+      r->vc_occupancy[i][j] = 0;\n+      r->pending_msgs[i][j] = NULL;\n+      r->pending_msgs_tail[i][j] = NULL;\n+      r->queued_msgs[i][j] = NULL;\n+      r->queued_msgs_tail[i][j] = NULL;\n+    }\n+  }\n+  return;\n+}\t\n+\n+\n+/* EM packet event , generates a EM packet on the compute node */\n+static tw_stime em_packet_event(\n+    model_net_request const * req,\n+    uint64_t message_offset,\n+    uint64_t packet_size,\n+    tw_stime offset,\n+    mn_sched_params const * sched_params,\n+    void const * remote_event,\n+    void const * self_event,\n+    tw_lp *sender,\n+    int is_last_pckt)\n+{\n+  (void)message_offset;\n+  (void)sched_params;\n+  tw_event * e_new;\n+  tw_stime xfer_to_nic_time;\n+  em_message * msg;\n+  char* tmp_ptr;\n+\n+  xfer_to_nic_time = codes_local_latency(sender); \n+  e_new = model_net_method_event_new(sender->gid, xfer_to_nic_time+offset,\n+      sender, EXPRESS_MESH, (void**)&msg, (void**)&tmp_ptr);\n+  strcpy(msg->category, req->category);\n+  msg->final_dest_gid = req->final_dest_lp;\n+  msg->total_size = req->msg_size;\n+  msg->sender_lp = req->src_lp;\n+  msg->sender_mn_lp = sender->gid;\n+  msg->packet_size = packet_size;\n+  msg->travel_start_time = tw_now(sender);\n+  msg->remote_event_size_bytes = 0;\n+  msg->local_event_size_bytes = 0;\n+  msg->type = T_GENERATE;\n+  msg->dest_terminal_id = req->dest_mn_lp;\n+  msg->dest_terminal = codes_mapping_get_lp_relative_id(msg->dest_terminal_id, 0, 0);\n+  msg->message_id = req->msg_id;\n+  msg->is_pull = req->is_pull;\n+  msg->pull_size = req->pull_size;\n+  msg->magic = terminal_magic_num; \n+  msg->msg_start_time = req->msg_start_time;\n+\n+  if(is_last_pckt) /* Its the last packet so pass in remote and local event information*/\n+  {\n+    if(req->remote_event_size > 0)\n+    {\n+      msg->remote_event_size_bytes = req->remote_event_size;\n+      memcpy(tmp_ptr, remote_event, req->remote_event_size);\n+      tmp_ptr += req->remote_event_size;\n+    }\n+    if(req->self_event_size > 0)\n+    {\n+      msg->local_event_size_bytes = req->self_event_size;\n+      memcpy(tmp_ptr, self_event, req->self_event_size);\n+      tmp_ptr += req->self_event_size;\n+    }\n+  }\n+  tw_event_send(e_new);\n+  return xfer_to_nic_time;\n+}\n+\n+/* EM packet event reverse handler */\n+static void em_packet_event_rc(tw_lp *sender)\n+{\n+  codes_local_latency_reverse(sender);\n+  return;\n+}\n+\n+/* generates packet at the current EM compute node */\n+static void packet_generate(terminal_state * s, tw_bf * bf, em_message * msg, \n+    tw_lp * lp) {\n+  packet_gen++;\n+  s->packet_gen++;\n+\n+  tw_stime ts, nic_ts;\n+\n+  assert(lp->gid != msg->dest_terminal_id);\n+  const em_param *p = s->params;\n+\n+  int total_event_size;\n+  uint64_t num_chunks = msg->packet_size / p->chunk_size;\n+  if (msg->packet_size % s->params->chunk_size) \n+    num_chunks++;\n+\n+  if(!num_chunks)\n+    num_chunks = 1;\n+\n+  nic_ts = g_tw_lookahead + (msg->packet_size * s->params->cn_delay) + \n+    tw_rand_unif(lp->rng);\n+\n+  msg->packet_ID = lp->gid + g_tw_nlp * s->packet_counter;\n+  for(int i = 0; i < p->n_dims; i++) {\n+    msg->hops[i] = 0;\n+  }\n+  msg->my_N_hop = 0;\n+\n+  /* TODO: how do we get a better vc selection mechanism */\n+  int use_vc = 0;\n+  msg->saved_channel = use_vc;\n+\n+  for(uint64_t i = 0; i < num_chunks; i++)\n+  {\n+    message_list *cur_chunk = (message_list*)malloc(\n+        sizeof(message_list));\n+    init_message_list(cur_chunk, msg);\n+\n+    if(msg->remote_event_size_bytes + msg->local_event_size_bytes > 0) {\n+      cur_chunk->event_data = (char*)malloc(\n+          msg->remote_event_size_bytes + msg->local_event_size_bytes);\n+    }\n+\n+    void * m_data_src = model_net_method_get_edata(EXPRESS_MESH, msg);\n+    if (msg->remote_event_size_bytes){\n+      memcpy(cur_chunk->event_data, m_data_src, msg->remote_event_size_bytes);\n+    }\n+    if (msg->local_event_size_bytes){ \n+      m_data_src = (char*)m_data_src + msg->remote_event_size_bytes;\n+      memcpy((char*)cur_chunk->event_data + msg->remote_event_size_bytes, \n+          m_data_src, msg->local_event_size_bytes);\n+    }\n+\n+    cur_chunk->em_msg.chunk_id = i;\n+    cur_chunk->port = 0; cur_chunk->index = use_vc; \n+    append_to_message_list(s->terminal_msgs[0], s->terminal_msgs_tail[0],\n+        use_vc, cur_chunk);\n+    s->terminal_length += s->params->chunk_size;\n+  }\n+\n+  if(s->terminal_length < 2 * s->params->num_vcs * s->params->cn_vc_size) {\n+    model_net_method_idle_event(nic_ts, 0, lp);\n+  } else {\n+    bf->c11 = 1;\n+    s->issueIdle = 1;\n+    msg->saved_busy_time = s->last_buf_full;\n+    s->last_buf_full = tw_now(lp);\n+  }\n+\n+  if(s->in_send_loop == 0) {\n+    bf->c5 = 1;\n+    ts = codes_local_latency(lp);\n+    em_message *m;\n+    tw_event* e = model_net_method_event_new(lp->gid, ts, lp, EXPRESS_MESH, \n+        (void**)&m, NULL);\n+    m->type = T_SEND;\n+    m->magic = terminal_magic_num;\n+    s->in_send_loop = 1;\n+    tw_event_send(e);\n+  }\n+\n+  total_event_size = model_net_get_msg_sz(EXPRESS_MESH) + \n+    msg->remote_event_size_bytes + msg->local_event_size_bytes;\n+  mn_stats* stat;\n+  stat = model_net_find_stats(msg->category, s->em_stats_array);\n+  stat->send_count++;\n+  stat->send_bytes += msg->packet_size;\n+  stat->send_time += p->cn_delay * msg->packet_size;\n+  if(stat->max_event_size < total_event_size)\n+    stat->max_event_size = total_event_size;\n+\n+  return;\n+}\n+\n+static void packet_generate_rc(terminal_state * s, tw_bf * bf, em_message * msg, tw_lp * lp)\n+{\n+  s->packet_gen--;\n+  packet_gen--;\n+\n+  tw_rand_reverse_unif(lp->rng);\n+\n+  int num_chunks = msg->packet_size/s->params->chunk_size;\n+  if(msg->packet_size % s->params->chunk_size)\n+    num_chunks++;\n+\n+  if(!num_chunks)\n+    num_chunks = 1;\n+\n+  int i;\n+  for(i = 0; i < num_chunks; i++) {\n+    delete_message_list(return_tail(s->terminal_msgs[0], \n+          s->terminal_msgs_tail[0], msg->saved_channel));\n+    s->terminal_length -= s->params->chunk_size;\n+  }\n+  if(bf->c11) {\n+    s->issueIdle = 0;\n+    s->last_buf_full = msg->saved_busy_time;\n+  }\n+  if(bf->c5) {\n+    codes_local_latency_reverse(lp);\n+    s->in_send_loop = 0;\n+  }\n+  struct mn_stats* stat;\n+  stat = model_net_find_stats(msg->category, s->em_stats_array);\n+  stat->send_count--;\n+  stat->send_bytes -= msg->packet_size;\n+  stat->send_time -= s->params->cn_delay * msg->packet_size;\n+}\n+\n+\n+/* sends the packet from the current EM compute node to the attached router */\n+static void packet_send(terminal_state * s, tw_bf * bf, em_message * msg, \n+    tw_lp * lp) {\n+\n+  tw_stime ts;\n+  tw_event *e;\n+  em_message *m;\n+  tw_lpid router_id;\n+\n+  std::vector<VC_Entry> entries;\n+  \n+  for(int i = 0; i < s->params->num_vcs; i++) {\n+    if(s->terminal_msgs[0][i] != NULL &&\n+      s->vc_occupancy[0][i] + s->params->chunk_size <= s->params->cn_vc_size) {\n+      VC_Entry tmp;\n+      tmp.vc = i; tmp.entry = s->terminal_msgs[0][i];\n+      entries.push_back(tmp);\n+    }\n+  }\n+\n+  if(entries.size() == 0) {\n+    bf->c1 = 1;\n+    s->in_send_loop = 0;\n+\n+    msg->saved_busy_time = s->last_buf_full;\n+    s->last_buf_full = tw_now(lp);\n+    return;\n+  }\n+\n+  int pick = tw_rand_integer(lp->rng, 0, entries.size() - 1);\n+  message_list* cur_entry = entries[pick].entry;\n+  int use_vc = entries[pick].vc;\n+  msg->saved_channel = use_vc;\n+\n+  uint64_t num_chunks = cur_entry->em_msg.packet_size/s->params->chunk_size;\n+  if(cur_entry->em_msg.packet_size % s->params->chunk_size)\n+    num_chunks++;\n+\n+  if(!num_chunks)\n+    num_chunks = 1;\n+\n+  tw_stime delay;\n+  if((cur_entry->em_msg.packet_size % s->params->chunk_size) \n+      && (cur_entry->em_msg.chunk_id == num_chunks - 1))\n+    delay = (cur_entry->em_msg.packet_size % s->params->chunk_size) * \n+      s->params->cn_delay;\n+  else \n+    delay = s->params->chunk_size * s->params->cn_delay;\n+\n+  msg->saved_available_time = s->terminal_available_time;\n+  ts = g_tw_lookahead + delay + tw_rand_unif(lp->rng);\n+  s->terminal_available_time = maxd(s->terminal_available_time, tw_now(lp));\n+  s->terminal_available_time += ts;\n+  \n+  ts = s->terminal_available_time - tw_now(lp);\n+  void * remote_event;\n+  e = model_net_method_event_new(s->router_gid, ts, lp, EXPRESS_MESH_ROUTER, \n+      (void**)&m, &remote_event);\n+  memcpy(m, &cur_entry->em_msg, sizeof(em_message));\n+  if (m->remote_event_size_bytes){\n+    memcpy(remote_event, cur_entry->event_data, m->remote_event_size_bytes);\n+  }\n+\n+  m->type = R_ARRIVE;\n+  m->src_terminal_id = lp->gid;\n+  m->vc_index = 0;\n+  m->output_chan = use_vc;\n+  m->last_hop = TERMINAL;\n+  m->magic = router_magic_num;\n+  m->local_event_size_bytes = 0;\n+  tw_event_send(e);\n+\n+  if(cur_entry->em_msg.chunk_id == num_chunks - 1 && \n+      (cur_entry->em_msg.local_event_size_bytes > 0)) {\n+    bf->c2 = 1;\n+    tw_stime local_ts = codes_local_latency(lp); \n+    tw_event *e_new = tw_event_new(cur_entry->em_msg.sender_lp, local_ts, lp);\n+    void * m_new = tw_event_data(e_new);\n+    void *local_event = (char*)cur_entry->event_data + \n+      cur_entry->em_msg.remote_event_size_bytes;\n+    memcpy(m_new, local_event, cur_entry->em_msg.local_event_size_bytes);\n+    tw_event_send(e_new);\n+  }\n+  s->packet_counter++;\n+  s->vc_occupancy[0][use_vc] += s->params->chunk_size;\n+  cur_entry = return_head(s->terminal_msgs[0], s->terminal_msgs_tail[0], use_vc); \n+  rc_stack_push(lp, cur_entry, delete_message_list, s->st);\n+  s->terminal_length -= s->params->chunk_size;\n+\n+  em_message *m_new;\n+  ts += tw_rand_unif(lp->rng);\n+  e = model_net_method_event_new(lp->gid, ts, lp, EXPRESS_MESH, \n+      (void**)&m_new, NULL);\n+  m_new->type = T_SEND;\n+  m_new->magic = terminal_magic_num;\n+  tw_event_send(e);\n+\n+  if(s->issueIdle) {\n+    bf->c5 = 1;\n+    s->issueIdle = 0;\n+    ts += tw_rand_unif(lp->rng);\n+    model_net_method_idle_event(ts, 0, lp);\n+\n+    if(s->last_buf_full > 0.0)\n+    {\n+      bf->c6 = 1;\n+      msg->saved_total_time = s->busy_time;\n+      msg->saved_busy_time = s->last_buf_full;\n+      msg->saved_sample_time = s->busy_time_sample;\n+\n+      s->busy_time += (tw_now(lp) - s->last_buf_full);\n+      s->busy_time_sample += (tw_now(lp) - s->last_buf_full);\n+      s->last_buf_full = 0.0;\n+    }\n+  }\n+  return;\n+}\n+\n+static void packet_send_rc(terminal_state * s, tw_bf * bf, em_message * msg,\n+    tw_lp * lp)\n+{\n+  if(bf->c1) {\n+    s->in_send_loop = 1;\n+    s->last_buf_full = msg->saved_busy_time;\n+    return;\n+  }\n+\n+  tw_rand_reverse_unif(lp->rng);\n+  tw_rand_reverse_unif(lp->rng);\n+  s->terminal_available_time = msg->saved_available_time;\n+  if(bf->c2) {\n+    codes_local_latency_reverse(lp);\n+  }\n+\n+  int use_vc = msg->saved_channel;\n+\n+  s->packet_counter--;\n+  s->vc_occupancy[0][use_vc] -= s->params->chunk_size;\n+\n+  message_list* cur_entry = (message_list *)rc_stack_pop(s->st);\n+  cur_entry->port = 0; cur_entry->index = use_vc;\n+  prepend_to_message_list(s->terminal_msgs[0], s->terminal_msgs_tail[0], \n+      use_vc, cur_entry);\n+  s->terminal_length += s->params->chunk_size;\n+  \n+  tw_rand_reverse_unif(lp->rng);\n+  if(bf->c5)\n+  {\n+    tw_rand_reverse_unif(lp->rng);\n+    s->issueIdle = 1;\n+    if(bf->c6)\n+    {\n+      s->busy_time = msg->saved_total_time;\n+      s->last_buf_full = msg->saved_busy_time;\n+      s->busy_time_sample = msg->saved_sample_time;\n+    }\n+  }\n+  return;\n+}\n+\n+static void send_remote_event(terminal_state * s, em_message * msg, \n+  tw_lp * lp, tw_bf * bf, char * event_data, int remote_event_size)\n+{\n+  void * tmp_ptr = model_net_method_get_edata(EXPRESS_MESH, msg);\n+  //tw_stime ts = g_tw_lookahead + s->params->cn_delay * \n+  //    msg->remote_event_size_bytes + tw_rand_unif(lp->rng);;\n+  tw_stime ts = g_tw_lookahead + tw_rand_unif(lp->rng);\n+  if (msg->is_pull){\n+    bf->c4 = 1;\n+    struct codes_mctx mc_dst =\n+      codes_mctx_set_global_direct(msg->sender_mn_lp);\n+    struct codes_mctx mc_src =\n+      codes_mctx_set_global_direct(lp->gid);\n+    int net_id = model_net_get_id(LP_METHOD_NM_TERM);\n+\n+    model_net_set_msg_param(MN_MSG_PARAM_START_TIME, \n+        MN_MSG_PARAM_START_TIME_VAL, &(msg->msg_start_time));\n+\n+    msg->event_rc = model_net_event_mctx(net_id, &mc_src, &mc_dst, msg->category,\n+        msg->sender_lp, msg->pull_size, ts,\n+        remote_event_size, tmp_ptr, 0, NULL, lp);\n+  } else {\n+    tw_event * e = tw_event_new(msg->final_dest_gid, ts, lp);\n+    void * m_remote = tw_event_data(e);\n+    memcpy(m_remote, event_data, remote_event_size);\n+    tw_event_send(e); \n+  }\n+  return;\n+}\n+\n+/* packet arrives at the destination terminal */\n+static void packet_arrive(terminal_state * s, tw_bf * bf, em_message * msg, \n+    tw_lp * lp) {\n+\n+  assert(lp->gid == msg->dest_terminal_id);\n+\n+  //total chunks expected in this message\n+  uint64_t total_chunks = msg->total_size / s->params->chunk_size;\n+  if(msg->total_size % s->params->chunk_size)\n+    total_chunks++;\n+  if(!total_chunks)\n+    total_chunks = 1;\n+\n+  /* send credit back to router */\n+  tw_stime ts = g_tw_lookahead + s->params->credit_delay + tw_rand_unif(lp->rng);\n+  tw_event * buf_e;\n+  em_message * buf_msg;\n+  buf_e = model_net_method_event_new(msg->intm_lp_id, ts, lp,\n+      EXPRESS_MESH_ROUTER, (void**)&buf_msg, NULL);\n+  buf_msg->magic = router_magic_num;\n+  buf_msg->vc_index = msg->vc_index;\n+  buf_msg->output_chan = msg->output_chan;\n+  buf_msg->type = R_BUFFER;\n+  tw_event_send(buf_e);\n+\n+  //save stats\n+  /* Total overall finished chunks in simulation */\n+  N_finished_chunks++;\n+  /* Finished chunks on a LP basis */\n+  s->finished_chunks++;\n+  /* Finished chunks per sample */\n+  s->fin_chunks_sample++;\n+\n+  assert(lp->gid != msg->src_terminal_id);\n+\n+  // chunks part of this packet \n+  uint64_t num_chunks = msg->packet_size / s->params->chunk_size;\n+  if (msg->packet_size % s->params->chunk_size)\n+    num_chunks++;\n+  if(!num_chunks)\n+    num_chunks = 1;\n+\n+  if(msg->chunk_id == num_chunks - 1)\n+  {\n+    bf->c31 = 1;\n+    s->packet_fin++;\n+    packet_fin++;\n+  }\n+\n+  /* save the sample time */\n+  msg->saved_sample_time = s->fin_chunks_time;\n+  s->fin_chunks_time += (tw_now(lp) - msg->travel_start_time);\n+  /* save the total time per LP */\n+  msg->saved_avg_time = s->total_time;\n+  s->total_time += (tw_now(lp) - msg->travel_start_time); \n+  msg->saved_total_time = em_total_time;\n+  em_total_time += tw_now( lp ) - msg->travel_start_time;\n+  total_hops += msg->my_N_hop;\n+  s->total_hops += msg->my_N_hop;\n+  s->fin_hops_sample += msg->my_N_hop;\n+\n+  mn_stats* stat = model_net_find_stats(msg->category, s->em_stats_array);\n+  msg->saved_rcv_time = stat->recv_time;\n+  stat->recv_time += (tw_now(lp) - msg->travel_start_time);\n+\n+  /* Now retreieve the number of chunks completed from the hash and update\n+   * them */\n+ \n+  struct mn_hash_key key;\n+  key.message_id = msg->message_id; \n+  key.sender_id = msg->sender_lp;\n+  struct qhash_head *hash_link = NULL;\n+  struct mn_qhash_entry * tmp = NULL;\n+  hash_link = qhash_search(s->rank_tbl, &key);\n+  if(hash_link)\n+    tmp = qhash_entry(hash_link, struct mn_qhash_entry, hash_link);\n+\n+  /* If an entry does not exist then create one */\n+  if(!tmp)\n+  {\n+    bf->c5 = 1;\n+    struct mn_qhash_entry * d_entry = (struct mn_qhash_entry *)\n+        malloc(sizeof(struct mn_qhash_entry));\n+    d_entry->num_chunks = 0;\n+    d_entry->key = key;\n+    d_entry->remote_event_data = NULL;\n+    d_entry->remote_event_size = 0;\n+    qhash_add(s->rank_tbl, &key, &(d_entry->hash_link));\n+\n+    hash_link = &(d_entry->hash_link);\n+    tmp = d_entry;\n+  }\n+\n+  assert(tmp);\n+  tmp->num_chunks++;\n+\n+  if(msg->chunk_id == num_chunks - 1)\n+  {\n+    bf->c1 = 1;\n+    stat->recv_count++;\n+    stat->recv_bytes += msg->packet_size;\n+    N_finished_packets++;\n+    s->finished_packets++;\n+  }\n+\n+  /* if its the last chunk of the packet then handle the remote event data */\n+  if(msg->remote_event_size_bytes > 0 && !tmp->remote_event_data)\n+  {\n+    /* Retreive the remote event entry */\n+    void *m_data_src = model_net_method_get_edata(EXPRESS_MESH, msg);\n+    tmp->remote_event_data = (char*)malloc(msg->remote_event_size_bytes);\n+    assert(tmp->remote_event_data);\n+    tmp->remote_event_size = msg->remote_event_size_bytes; \n+    memcpy(tmp->remote_event_data, m_data_src, msg->remote_event_size_bytes);\n+  }\n+\n+  if (em_max_latency < tw_now( lp ) - msg->travel_start_time) {\n+    bf->c3 = 1;\n+    msg->saved_available_time = em_max_latency;\n+    em_max_latency = tw_now( lp ) - msg->travel_start_time;\n+  }\n+\n+  if(tmp->num_chunks >= total_chunks)\n+  {\n+    bf->c7 = 1;\n+\n+    N_finished_msgs++;\n+    total_msg_sz += msg->total_size;\n+    s->total_msg_size += msg->total_size;\n+    s->data_size_sample += msg->total_size;\n+    s->finished_msgs++;\n+\n+    if(tmp->remote_event_data && tmp->remote_event_size > 0) {\n+      bf->c8 = 1;\n+      send_remote_event(s, msg, lp, bf, tmp->remote_event_data, \n+          tmp->remote_event_size);\n+    }\n+\n+    /* Remove the hash entry */\n+    qhash_del(hash_link);\n+    rc_stack_push(lp, tmp, free_tmp, s->st);\n+  }\n+  return;\n+}\n+\n+static void packet_arrive_rc(terminal_state * s, tw_bf * bf, em_message * msg, tw_lp * lp)\n+{\n+  tw_rand_reverse_unif(lp->rng);\n+  N_finished_chunks--;\n+  s->finished_chunks--;\n+  s->fin_chunks_sample--;\n+  if(bf->c31)\n+  {\n+    s->packet_fin--;\n+    packet_fin--;\n+  }\n+\n+  s->fin_chunks_time = msg->saved_sample_time;\n+  s->total_time = msg->saved_avg_time;\n+  em_total_time  = msg->saved_total_time;\n+  total_hops -= msg->my_N_hop;\n+  s->total_hops -= msg->my_N_hop;\n+  s->fin_hops_sample -= msg->my_N_hop;\n+\n+  mn_stats* stat;\n+  stat = model_net_find_stats(msg->category, s->em_stats_array);\n+  stat->recv_time = msg->saved_rcv_time;\n+\n+  struct qhash_head * hash_link = NULL;\n+  struct mn_qhash_entry * tmp = NULL; \n+\n+  struct mn_hash_key key;\n+  key.message_id = msg->message_id;\n+  key.sender_id = msg->sender_lp;\n+\n+  hash_link = qhash_search(s->rank_tbl, &key);\n+  if(hash_link)\n+    tmp = qhash_entry(hash_link, struct mn_qhash_entry, hash_link);\n+\n+  if(bf->c1)\n+  {\n+    stat->recv_count--;\n+    stat->recv_bytes -= msg->packet_size;\n+    N_finished_packets--;\n+    s->finished_packets--;\n+  }\n+\n+  if(bf->c3)\n+    em_max_latency = msg->saved_available_time;\n+\n+  if(bf->c7)\n+  {\n+    N_finished_msgs--;\n+    total_msg_sz -= msg->total_size;\n+    s->total_msg_size -= msg->total_size;\n+    s->data_size_sample -= msg->total_size;\n+    s->finished_msgs--;\n+   \n+    if(bf->c8) \n+      tw_rand_reverse_unif(lp->rng);\n+\n+    struct mn_qhash_entry * d_entry_pop = (struct mn_qhash_entry * )\n+        rc_stack_pop(s->st);\n+    qhash_add(s->rank_tbl, &key, &(d_entry_pop->hash_link));\n+\n+    hash_link = &(d_entry_pop->hash_link);\n+    tmp = d_entry_pop; \n+\n+    if(bf->c4)\n+      model_net_event_rc2(lp, &msg->event_rc);\n+  }\n+\n+  assert(tmp);\n+  tmp->num_chunks--;\n+\n+  if(bf->c5)\n+  {\n+    qhash_del(hash_link);\n+    free_tmp(tmp);\t\n+  }\n+  return;\n+}\n+\n+/* update the compute node-router channel buffer */\n+static void \n+terminal_buf_update(terminal_state * s, \n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  s->vc_occupancy[0][msg->output_chan] -= s->params->chunk_size;\n+\n+  if(s->in_send_loop == 0) {\n+    int do_send = 0;\n+    for(int i = 0; i < s->params->num_vcs; i++) {\n+      if(s->terminal_msgs[0][i] != NULL) {\n+        do_send = 1;\n+        break;\n+      }\n+    }\n+    if(do_send) {\n+      em_message *m;\n+      bf->c1 = 1;\n+      tw_stime ts = codes_local_latency(lp);\n+      tw_event* e = model_net_method_event_new(lp->gid, ts, lp, EXPRESS_MESH, \n+          (void**)&m, NULL);\n+      m->type = T_SEND;\n+      m->magic = terminal_magic_num;\n+      s->in_send_loop = 1;\n+      tw_event_send(e);\n+    }\n+  }\n+  return;\n+}\n+\n+static void terminal_buf_update_rc(terminal_state * s,\n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  s->vc_occupancy[0][msg->output_chan] += s->params->chunk_size;\n+  if(bf->c1) {\n+    codes_local_latency_reverse(lp);\n+    s->in_send_loop = 0;\n+  }\n+  return;\n+}\n+\n+static void terminal_event( terminal_state * s, \n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp )\n+{\n+  s->fwd_events++;\n+  assert(msg->magic == terminal_magic_num);\n+  rc_stack_gc(lp, s->st);\n+  switch(msg->type)\n+  {\n+    case T_GENERATE:\n+      packet_generate(s,bf,msg,lp);\n+      break;\n+\n+    case T_ARRIVE:\n+      packet_arrive(s,bf,msg,lp);\n+      break;\n+\n+    case T_SEND:\n+      packet_send(s,bf,msg,lp);\n+      break;\n+\n+    case T_BUFFER:\n+      terminal_buf_update(s, bf, msg, lp);\n+      break;\n+\n+    default:\n+      printf(\"\\n LP %d Terminal message type not supported %d \", (int)lp->gid, msg->type);\n+      tw_error(TW_LOC, \"Msg type not supported\");\n+  }\n+}\n+\n+/* Reverse computation handler for a terminal event */\n+static void terminal_event_rc (terminal_state * s, \n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp) \n+{\n+  s->rev_events++;\n+  switch(msg->type)\n+  {\n+    case T_GENERATE:\n+      packet_generate_rc(s, bf, msg, lp); \n+      break;\n+\n+    case T_SEND:\n+      packet_send_rc(s, bf, msg, lp);\n+      break;\n+\n+    case T_ARRIVE:\n+      packet_arrive_rc(s, bf, msg, lp);\n+      break;\n+\n+    case T_BUFFER:\n+      terminal_buf_update_rc(s, bf, msg, lp); \n+      break;\n+\n+  }\n+}\n+\n+static void \n+terminal_final( terminal_state * s, tw_lp * lp )\n+{\n+  model_net_print_stats(lp->gid, s->em_stats_array);\n+\n+  int written = 0;\n+  if(!s->terminal_id)\n+    written = sprintf(s->output_buf, \"# Format <LP id> <Terminal ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Avg hops> <Busy Time>\");\n+\n+  written += sprintf(s->output_buf + written, \"\\n %llu %u %llu %lf %ld %lf %lf\",\n+      LLU(lp->gid), s->terminal_id, s->total_msg_size, s->total_time, \n+      s->finished_packets, (double)s->total_hops/s->finished_chunks,\n+      s->busy_time);\n+\n+  lp_io_write(lp->gid, (char*)\"em-msg-stats\", written, s->output_buf); \n+\n+  for(int i = 0; i < s->params->num_vcs; i++) {\n+    if(s->terminal_msgs[0][i] != NULL) \n+      printf(\"[%llu] leftover terminal messages \\n\", LLU(lp->gid));\n+  }\n+\n+  qhash_finalize(s->rank_tbl);\n+  rc_stack_destroy(s->st);\n+  free(s->vc_occupancy[0]);\n+  free(s->vc_occupancy);\n+  free(s->terminal_msgs[0]);\n+  free(s->terminal_msgs_tail[0]);\n+  free(s->terminal_msgs);\n+  free(s->terminal_msgs_tail);\n+}\n+\n+struct NextHop {\n+  int dim, port;\n+  NextHop(int _dim, int _port) {\n+    dim = _dim;\n+    port = _port;\n+  }\n+};\n+\n+/* get the next stop for the current packet */\n+static void\n+get_next_stop(router_state * s, \n+    em_message * msg, \n+    tw_bf *bf,\n+    int *port,\n+    int *vc,\n+    int *src_dim,\n+    int *dst_dim,\n+    int *static_port) \n+{\n+  *static_port = -1;\n+  *src_dim = -2;\n+  if(msg->last_hop == TERMINAL) {\n+    *src_dim = -1;\n+  } else {\n+    for(int i = s->params->n_dims - 1; i >= 0; i--) {\n+      if(msg->vc_index >= s->params->offset_per_dim[i]) {\n+        *src_dim = i;\n+        break;\n+      }\n+    }\n+  }\n+  assert(*src_dim > -2);\n+\n+  int dest[s->params->n_dims];\n+  to_dim_id(msg->dest_terminal/s->params->num_cn, s->params->n_dims, \n+    s->params->dim_length, dest);\n+\n+  std::vector<NextHop> port_options;\n+  bool at_dest = true;\n+  int first_dim = -1;\n+  for(int i = 0; i < s->params->n_dims; i++)\n+  {\n+    if(s->dim_position[i] != dest[i]) {\n+      at_dest = false;\n+      *port = s->params->offset_per_dim[i];\n+      if(first_dim  == -1) {\n+        first_dim = i;\n+      }\n+\n+      int first_dim_con;\n+      if(s->dim_position[i] == 0) {\n+        first_dim_con = -1;\n+      } else {\n+        first_dim_con = (s->dim_position[i] - 1) % s->params->gap;\n+      }\n+\n+      if(dest[i] == s->dim_position[i] - 1) {\n+        *port += (s->dim_position[i] - 1 - first_dim_con) / s->params->gap;\n+        port_options.push_back(NextHop(i, *port));\n+      } else if(dest[i] == s->dim_position[i] + 1) {\n+        *port += 1 + (s->dim_position[i] - 1 - first_dim_con) / s->params->gap;\n+        *port -= (s->dim_position[i] == 0 ? 1 : 0);\n+        port_options.push_back(NextHop(i, *port));\n+      } else {\n+        if(dest[i] < s->dim_position[i]) {\n+          if((s->dim_position[i] - 1 - dest[i]) % s->params->gap == 0) {\n+            *port += (dest[i] - first_dim_con) / s->params->gap;\n+            port_options.push_back(NextHop(i, *port));\n+          } else {\n+            int long_hop;\n+            if(dest[i] < first_dim_con) {\n+              long_hop = *port;\n+            } else {\n+              long_hop = *port + (dest[i] - first_dim_con) / s->params->gap + 1;\n+            }\n+            //int long_hop = *port + (dest[i] - first_dim_con) / s->params->gap + 1;\n+            int short_hop = *port + (s->dim_position[i] - 1 - first_dim_con) / s->params->gap;\n+            port_options.push_back(NextHop(i, long_hop));\n+            port_options.push_back(NextHop(i, short_hop));\n+          }\n+        } else if(dest[i] > s->dim_position[i]) {\n+          if((dest[i] - s->dim_position[i] - 1) % s->params->gap == 0) {\n+            *port += (s->dim_position[i] - 1 - first_dim_con) / s->params->gap \n+              + 1 + (dest[i] - s->dim_position[i] - 1) / s->params->gap;\n+            *port -= (s->dim_position[i] == 0 ? 1 : 0);\n+            port_options.push_back(NextHop(i, *port));\n+          } else {\n+            int long_hop = *port + (s->dim_position[i] - 1 - first_dim_con) / s->params->gap \n+              + 1 + (dest[i] - s->dim_position[i] - 1) / s->params->gap;\n+            int short_hop = *port + 1 + (s->dim_position[i] - 1 - first_dim_con) / s->params->gap;\n+            short_hop -= (s->dim_position[i] == 0 ? 1 : 0);\n+            long_hop -= (s->dim_position[i] == 0 ? 1 : 0);\n+            port_options.push_back(NextHop(i, long_hop));\n+            port_options.push_back(NextHop(i, short_hop));\n+          }\n+        } else {\n+          tw_error(TW_LOC, \"Impossible condition in get_next_stop\");\n+        }\n+      }\n+      if(s->params->routing == STATIC) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  int try_vcs = s->params->num_vcs;\n+  if(at_dest) {\n+    *port = (msg->dest_terminal % s->params->num_cn);\n+    port_options.push_back(NextHop(-1, *port));\n+    try_vcs = 1;\n+    assert(port_options.size() == 1);\n+  }\n+  if(s->params->routing == STATIC || at_dest) {\n+    *vc = 0;\n+    *port = port_options[0].port;\n+    *dst_dim = port_options[0].dim;\n+    int vc_s = s->vc_occupancy[*port][*vc] + s->queued_count[*port];\n+    for(int i = 0; i < port_options.size(); i++) {\n+      for(int j = 0; j < try_vcs; j++) {\n+        if(s->vc_occupancy[port_options[i].port][j] + \n+           s->queued_count[port_options[i].port] < vc_s) {\n+          vc_s = s->vc_occupancy[port_options[i].port][j] + \n+                 s->queued_count[port_options[i].port];\n+          *port = port_options[i].port;\n+          *dst_dim = port_options[i].dim;\n+          *vc = j;\n+        }\n+      }\n+    }\n+  } else {\n+    *vc = 1; //dynamic VC\n+    *port = port_options[0].port;\n+    *dst_dim = port_options[0].dim;\n+    int vc_s = s->vc_occupancy[*port][*vc] + s->queued_count[*port];\n+    for(int i = 0; i < port_options.size(); i++) {\n+      for(int j = 1; j < try_vcs; j++) {\n+        if(s->vc_occupancy[port_options[i].port][j] + \n+           s->queued_count[port_options[i].port] < vc_s) {\n+          vc_s = s->vc_occupancy[port_options[i].port][j] + \n+                 s->queued_count[port_options[i].port];\n+          *port = port_options[i].port;\n+          *dst_dim = port_options[i].dim;\n+          *vc = j;\n+        }\n+      }\n+    }\n+    //if going to queued list, find the first dim port also\n+    if((s->vc_occupancy[*port][*vc] + s->params->chunk_size > s->params->vc_size)) {\n+      int start_vc = 1;\n+      int end_vc = s->params->num_vcs;\n+      *static_port = port_options[0].port;\n+      int vc_s = s->vc_occupancy[*static_port][start_vc] + s->queued_count[*static_port];\n+      for(int i = 0; (i < port_options.size()) && \n+                     (port_options[i].dim == first_dim); i++) {\n+        for(int j = start_vc; j < end_vc; j++) {\n+          if(s->vc_occupancy[port_options[i].port][j] + \n+              s->queued_count[port_options[i].port] < vc_s) {\n+            vc_s = s->vc_occupancy[port_options[i].port][j] + \n+              s->queued_count[port_options[i].port];\n+            *static_port = port_options[i].port;\n+          }\n+        }\n+      }\n+    }\n+  }\n+#if DEBUG\n+  printf(\"[%lld-%d] Me: %d %d %d: Dest %d %d %d Found %d %d\\n\", msg->packet_ID, s->params->n_dims,\n+      s->dim_position[0], s->dim_position[1], s->dim_position[2],\n+      dest[0], dest[1], dest[2], *dst_dim, *port);\n+#endif\n+}\n+\n+/* get the next stop for the current packet */\n+static void\n+get_next_stop_rc(router_state * s, \n+    em_message * msg, \n+    tw_bf *bf)\n+{\n+}\n+\n+/*When a packet is sent from the current router and a buffer slot becomes \n+ * available, a credit is sent back to schedule another packet event*/\n+static void router_credit_send(router_state * s, em_message * msg, \n+    tw_lp * lp) {\n+  tw_event * buf_e;\n+  tw_stime ts;\n+  em_message * buf_msg;\n+\n+  int dest = 0,  type = R_BUFFER;\n+  int is_terminal = 0;\n+\n+  const em_param *p = s->params;\n+\n+  // Notify sender terminal about available buffer space\n+  if(msg->last_hop == TERMINAL) {\n+    dest = msg->src_terminal_id;\n+    type = T_BUFFER;\n+    is_terminal = 1;\n+  } else {\n+    dest = msg->intm_lp_id;\n+  } \n+\n+  ts = g_tw_lookahead + p->credit_delay +  tw_rand_unif(lp->rng);\n+\n+  if (is_terminal) {\n+    buf_e = model_net_method_event_new(dest, ts, lp, EXPRESS_MESH, \n+        (void**)&buf_msg, NULL);\n+    buf_msg->magic = terminal_magic_num;\n+  } else {\n+    buf_e = model_net_method_event_new(dest, ts, lp, EXPRESS_MESH_ROUTER,\n+        (void**)&buf_msg, NULL);\n+    buf_msg->magic = router_magic_num;\n+  }\n+\n+  buf_msg->vc_index = msg->vc_index;\n+  buf_msg->output_chan = msg->output_chan;\n+  buf_msg->type = type;\n+  tw_event_send(buf_e);\n+  return;\n+}\n+\n+/* Packet arrives at the router and a credit is sent back to the sending terminal/router */\n+static void \n+router_packet_receive( router_state * s, \n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp )\n+{\n+  tw_stime ts;\n+  int next_port, next_vc, src_dim, next_dim, static_port;\n+\n+  get_next_stop(s, msg, bf, &next_port, &next_vc, &src_dim, &next_dim, &static_port);\n+  if(s->params->routing != STATIC && next_dim != -1) {\n+    assert(next_vc != 0);\n+  }\n+\n+  message_list * cur_chunk = (message_list*)malloc(sizeof(message_list));\n+  init_message_list(cur_chunk, msg);\n+\n+  if(msg->remote_event_size_bytes > 0) {\n+    void *m_data_src = model_net_method_get_edata(EXPRESS_MESH_ROUTER, msg);\n+    cur_chunk->event_data = (char*)malloc(msg->remote_event_size_bytes);\n+    memcpy(cur_chunk->event_data, m_data_src, msg->remote_event_size_bytes);\n+  }\n+  \n+  int max_vc_size = s->params->cn_vc_size;\n+  if(next_port >= s->params->num_cn) {\n+    max_vc_size = s->params->vc_size;\n+  } \n+\n+  cur_chunk->em_msg.my_N_hop++;\n+  assert(cur_chunk->em_msg.my_N_hop < s->params->n_dims * s->params->gap + 2);\n+\n+  int multfactor = 1;\n+  if(s->params->routing == STATIC && next_dim != -1 && src_dim != next_dim) {\n+    multfactor = MULT_FACTOR;\n+  }\n+\n+  if(s->vc_occupancy[next_port][next_vc] + multfactor * s->params->chunk_size \n+      <= max_vc_size) {\n+    bf->c2 = 1;\n+    router_credit_send(s, msg, lp);\n+    cur_chunk->port = next_port; cur_chunk->index = next_vc; \n+    append_to_message_list(s->pending_msgs[next_port], \n+        s->pending_msgs_tail[next_port], next_vc, cur_chunk);\n+    s->vc_occupancy[next_port][next_vc] += s->params->chunk_size;\n+    if(s->in_send_loop[next_port] == 0) {\n+      bf->c3 = 1;\n+      em_message *m;\n+      ts = codes_local_latency(lp); \n+      tw_event *e = model_net_method_event_new(lp->gid, ts, lp,\n+          EXPRESS_MESH_ROUTER, (void**)&m, NULL);\n+      m->type = R_SEND;\n+      m->magic = router_magic_num;\n+      m->vc_index = next_port;\n+      tw_event_send(e);\n+      s->in_send_loop[next_port] = 1;\n+    }\n+  } else {\n+    bf->c4 = 1;\n+    if(multfactor == 1) {\n+      cur_chunk->em_msg.dim_change = 0;\n+    } else {\n+      cur_chunk->em_msg.dim_change = 1;\n+    }\n+    cur_chunk->port = next_port; cur_chunk->index = next_vc; \n+    append_to_message_list(s->queued_msgs[next_port], \n+        s->queued_msgs_tail[next_port], next_vc, cur_chunk);\n+    s->queued_count[next_port] += s->params->chunk_size;\n+    msg->saved_busy_time = s->last_buf_full[next_port];\n+    s->last_buf_full[next_port] = tw_now(lp);\n+    if(s->params->routing != STATIC && next_dim != -1) {\n+      assert(static_port >= s->params->num_cn);\n+      assert(next_vc != 0);\n+      bf->c6 = 1;\n+      cur_chunk->in_alt_q = 1;\n+      cur_chunk->altq_port = static_port;\n+      altq_append_to_message_list(s->queued_msgs[static_port], \n+          s->queued_msgs_tail[static_port], 0, cur_chunk);\n+      bool triggerSend = (s->vc_occupancy[static_port][0] + MULT_FACTOR * s->params->chunk_size <= s->params->vc_size);\n+      if(triggerSend && s->in_send_loop[static_port] == 0) {\n+        bf->c5 = 1;\n+        em_message *m;\n+        ts = codes_local_latency(lp); \n+        tw_event *e = model_net_method_event_new(lp->gid, ts, lp,\n+            EXPRESS_MESH_ROUTER, (void**)&m, NULL);\n+        m->type = R_SEND;\n+        m->magic = router_magic_num;\n+        m->vc_index = static_port;\n+        tw_event_send(e);\n+        s->in_send_loop[static_port] = 1;\n+      }\n+    }\n+  }\n+\n+  msg->saved_vc = next_port;\n+  msg->saved_channel = next_vc;\n+  return;\n+}\n+\n+static void router_packet_receive_rc(router_state * s,\n+    tw_bf * bf,\n+    em_message * msg,\n+    tw_lp * lp)\n+{\n+  get_next_stop_rc(s, msg, bf);\n+  int next_port = msg->saved_vc;\n+  int next_vc = msg->saved_channel;\n+\n+  if(bf->c2) {\n+    tw_rand_reverse_unif(lp->rng);\n+    message_list * tail = return_tail(s->pending_msgs[next_port], \n+      s->pending_msgs_tail[next_port], next_vc);\n+    delete_message_list(tail);\n+    s->vc_occupancy[next_port][next_vc] -= s->params->chunk_size;\n+    if(bf->c3) {\n+      codes_local_latency_reverse(lp);\n+      s->in_send_loop[next_port] = 0;\n+    }\n+  }\n+  if(bf->c4) {\n+    message_list *tail = return_tail(s->queued_msgs[next_port], \n+          s->queued_msgs_tail[next_port], next_vc);\n+    s->queued_count[next_port] -= s->params->chunk_size; \n+    s->last_buf_full[next_port] = msg->saved_busy_time;\n+    if(bf->c6) {\n+      assert(tail->in_alt_q == 1);\n+      int static_port = tail->altq_port;\n+      message_list *stail = altq_return_tail(s->queued_msgs[static_port], \n+        s->queued_msgs_tail[static_port], 0);\n+      assert(stail == tail);\n+      if(bf->c5) {\n+        codes_local_latency_reverse(lp);\n+        s->in_send_loop[static_port] = 0;\n+      }\n+    }\n+    delete_message_list(tail);\n+  }\n+}\n+\n+/* routes the current packet to the next stop */\n+static void \n+router_packet_send( router_state * s, \n+    tw_bf * bf, \n+    em_message * msg, tw_lp * lp)\n+{\n+  tw_stime ts;\n+  tw_event *e;\n+  em_message *m;\n+  int output_port = msg->vc_index;\n+  \n+  std::vector<VC_Entry> entries;\n+  \n+  for(int i = 0; i < s->params->num_vcs; i++) {\n+    if(s->pending_msgs[output_port][i] != NULL) {\n+      VC_Entry tmp;\n+      tmp.vc = i; tmp.entry = s->pending_msgs[output_port][i];\n+      entries.push_back(tmp);\n+    }\n+  }\n+\n+  if(entries.size() == 0) {\n+    if((output_port >= s->params->num_cn) && (s->params->routing != STATIC) &&\n+       (s->vc_occupancy[output_port][0] + MULT_FACTOR * s->params->chunk_size <= s->params->vc_size)) {\n+      if(s->queued_msgs[output_port][0] != NULL) {\n+        bf->c21 = 1;\n+        message_list *head = altq_return_head(s->queued_msgs[output_port],\n+            s->queued_msgs_tail[output_port], 0);\n+        head->in_alt_q = 0;\n+        router_credit_send(s, &head->em_msg, lp); \n+        delete_from_message_list(s->queued_msgs, s->queued_msgs_tail, head);\n+        s->queued_count[head->port] -= s->params->chunk_size; \n+        msg->saved_vc = head->port;\n+        msg->saved_channel = head->index;\n+        s->vc_occupancy[output_port][0] += s->params->chunk_size;\n+        VC_Entry tmp;\n+        tmp.vc = 0; tmp.entry = head;\n+        entries.push_back(tmp);\n+      }\n+    } \n+    if(entries.size() == 0) {\n+      bf->c1 = 1;\n+      s->in_send_loop[output_port] = 0;\n+      return;\n+    }\n+  }\n+  \n+  int pick = tw_rand_integer(lp->rng, 0, entries.size() - 1);\n+  message_list* cur_entry = entries[pick].entry;\n+  int use_vc = entries[pick].vc;\n+  msg->output_chan = use_vc;\n+\n+  int to_terminal = 1;\n+  double delay = s->params->cn_delay;\n+\n+  if(output_port >= s->params->num_cn) {\n+    to_terminal = 0;\n+    delay = s->params->link_delay;\n+  } \n+\n+  uint64_t num_chunks = cur_entry->em_msg.packet_size / s->params->chunk_size;\n+  if(msg->packet_size % s->params->chunk_size)\n+    num_chunks++;\n+  if(!num_chunks)\n+    num_chunks = 1;\n+\n+  double bytetime;\n+  if((cur_entry->em_msg.packet_size % s->params->chunk_size) \n+      && (cur_entry->em_msg.chunk_id == num_chunks - 1))\n+    bytetime = delay * (cur_entry->em_msg.packet_size % s->params->chunk_size); \n+  else \n+    bytetime = delay * s->params->chunk_size;\n+\n+  ts = g_tw_lookahead + tw_rand_unif(lp->rng) + bytetime + s->params->router_delay;\n+\n+  msg->saved_available_time = s->next_output_available_time[output_port];\n+  s->next_output_available_time[output_port] = \n+    maxd(s->next_output_available_time[output_port], tw_now(lp));\n+  s->next_output_available_time[output_port] += ts;\n+\n+  ts = s->next_output_available_time[output_port] - tw_now(lp);\n+  \n+  // dest can be a router or a terminal, so we must check\n+  void * m_data;\n+  if (to_terminal) {\n+    assert(s->link_connections[output_port] == cur_entry->em_msg.dest_terminal_id);\n+    e = model_net_method_event_new(s->link_connections[output_port],\n+        ts, lp, EXPRESS_MESH, (void**)&m, &m_data);\n+  } else {\n+    e = model_net_method_event_new(s->link_connections[output_port],\n+        ts, lp, EXPRESS_MESH_ROUTER, (void**)&m, &m_data);\n+  }\n+  memcpy(m, &cur_entry->em_msg, sizeof(em_message));\n+  if (m->remote_event_size_bytes){\n+    memcpy(m_data, cur_entry->event_data, m->remote_event_size_bytes);\n+  }\n+\n+  m->last_hop = ROUTER;\n+  m->intm_lp_id = lp->gid;\n+  m->vc_index = output_port;\n+  m->output_chan = use_vc;\n+\n+  if((cur_entry->em_msg.packet_size % s->params->chunk_size) \n+      && (cur_entry->em_msg.chunk_id == num_chunks - 1)) {\n+    bf->c11 = 1;\n+    s->link_traffic[output_port] +=  (cur_entry->em_msg.packet_size %\n+        s->params->chunk_size); \n+    s->link_traffic_sample[output_port] += (cur_entry->em_msg.packet_size % \n+        s->params->chunk_size);\n+  } else {\n+    bf->c12 = 1;\n+    s->link_traffic[output_port] += s->params->chunk_size;\n+    s->link_traffic_sample[output_port] += s->params->chunk_size;\n+  }\n+\n+  /* Determine the event type. If the packet has arrived at the final \n+   * destination router then it should arrive at the destination terminal \n+   * next.*/\n+  if(to_terminal) {\n+    m->type = T_ARRIVE;\n+    m->magic = terminal_magic_num;\n+  } else {\n+    /* The packet has to be sent to another router */\n+    m->type = R_ARRIVE;\n+    m->magic = router_magic_num;\n+  }\n+  tw_event_send(e);\n+\n+  if(!bf->c21) {\n+    cur_entry = return_head(s->pending_msgs[output_port], \n+        s->pending_msgs_tail[output_port], use_vc);\n+  }\n+  rc_stack_push(lp, cur_entry, delete_message_list, s->st);\n+  \n+  s->next_output_available_time[output_port] -= s->params->router_delay;\n+  ts -= s->params->router_delay;\n+\n+  em_message *m_new;\n+  ts = ts +  g_tw_lookahead * tw_rand_unif(lp->rng);\n+  e = model_net_method_event_new(lp->gid, ts, lp, EXPRESS_MESH_ROUTER,\n+      (void**)&m_new, NULL);\n+  m_new->type = R_SEND;\n+  m_new->magic = router_magic_num;\n+  m_new->vc_index = output_port;\n+  tw_event_send(e);\n+  return;\n+}\n+\n+static void router_packet_send_rc(router_state * s, \n+    tw_bf * bf, \n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  int output_port = msg->vc_index;\n+  int use_vc = msg->output_chan;\n+\n+  if(bf->c1) {\n+    s->in_send_loop[output_port] = 1;\n+    return;  \n+  }\n+\n+  tw_rand_reverse_unif(lp->rng);\n+  tw_rand_reverse_unif(lp->rng);\n+\n+  s->next_output_available_time[output_port] = msg->saved_available_time;\n+  message_list * cur_entry = (message_list *)rc_stack_pop(s->st);\n+  assert(cur_entry);\n+\n+  if(bf->c11)\n+  {\n+    s->link_traffic[output_port] -= cur_entry->em_msg.packet_size % s->params->chunk_size;\n+    s->link_traffic_sample[output_port] -= cur_entry->em_msg.packet_size % s->params->chunk_size; \n+  }\n+  if(bf->c12)\n+  {\n+    s->link_traffic[output_port] -= s->params->chunk_size;\n+    s->link_traffic_sample[output_port] -= s->params->chunk_size;\n+  }\n+\n+  if(bf->c21) {\n+    tw_rand_reverse_unif(lp->rng);\n+    cur_entry->port = msg->saved_vc; cur_entry->index = msg->saved_channel;\n+    cur_entry->in_alt_q = 1;\n+    altq_prepend_to_message_list(s->queued_msgs[output_port],\n+        s->queued_msgs_tail[output_port], 0, cur_entry);\n+    add_to_message_list(s->queued_msgs, s->queued_msgs_tail, cur_entry);\n+    s->vc_occupancy[output_port][0] -= s->params->chunk_size;\n+    s->queued_count[msg->saved_vc] += s->params->chunk_size; \n+  } else {\n+    cur_entry->port = output_port; cur_entry->index = use_vc;\n+    prepend_to_message_list(s->pending_msgs[output_port],\n+        s->pending_msgs_tail[output_port], use_vc, cur_entry);\n+  }\n+\n+  tw_rand_reverse_unif(lp->rng);\n+}\n+\n+/* Update the buffer space associated with this router LP */\n+static void router_buf_update(router_state * s, tw_bf * bf, em_message * msg, tw_lp * lp)\n+{\n+  int indx = msg->vc_index;\n+  int output_chan = msg->output_chan;\n+  s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n+\n+  if(s->last_buf_full[indx])\n+  {\n+    bf->c3 = 1;\n+    msg->saved_rcv_time = s->busy_time[indx];\n+    msg->saved_busy_time = s->last_buf_full[indx];\n+    msg->saved_sample_time = s->busy_time_sample[indx];\n+    s->busy_time[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+    s->busy_time_sample[indx] += (tw_now(lp) - s->last_buf_full[indx]);\n+    s->last_buf_full[indx] = 0.0;\n+  }\n+\n+  int max_vc_size = s->params->vc_size;\n+  if(indx < s->params->num_cn) {\n+    max_vc_size = s->params->cn_vc_size;\n+  }\n+\n+  if((s->params->routing == STATIC || output_chan != 0 || indx < s->params->num_cn) \n+      && s->queued_msgs[indx][output_chan] != NULL) {\n+    if(!s->queued_msgs[indx][output_chan]->em_msg.dim_change ||\n+      (s->vc_occupancy[indx][output_chan] + MULT_FACTOR * s->params->chunk_size \n+      <= max_vc_size)) {\n+      bf->c1 = 1;\n+      message_list *head = return_head(s->queued_msgs[indx],\n+          s->queued_msgs_tail[indx], output_chan);\n+      router_credit_send(s, &head->em_msg, lp); \n+      if(head->in_alt_q) {\n+        bf->c21 = 1;\n+        altq_delete_from_message_list(s->queued_msgs, s->queued_msgs_tail, head);\n+        head->in_alt_q = 0;\n+      }\n+      head->port = indx; head->index = output_chan;\n+      append_to_message_list(s->pending_msgs[indx], \n+          s->pending_msgs_tail[indx], output_chan, head);\n+      s->vc_occupancy[indx][output_chan] += s->params->chunk_size;\n+      s->queued_count[indx] -= s->params->chunk_size; \n+    }\n+  }\n+\n+  if(s->in_send_loop[indx] == 0 && ((s->pending_msgs[indx][output_chan] != NULL) || \n+      ((s->vc_occupancy[indx][0] + MULT_FACTOR * s->params->chunk_size <= s->params->vc_size)\n+        && (s->queued_msgs[indx][0] != NULL)))) {\n+    bf->c2 = 1;\n+    em_message *m;\n+    tw_stime ts = codes_local_latency(lp);\n+    tw_event *e = model_net_method_event_new(lp->gid, ts, lp, EXPRESS_MESH_ROUTER,\n+        (void**)&m, NULL);\n+    m->type = R_SEND;\n+    m->vc_index = indx;\n+    m->magic = router_magic_num;\n+    s->in_send_loop[indx] = 1;\n+    tw_event_send(e);\n+  }\n+\n+  return;\n+}\n+\n+static void router_buf_update_rc(router_state * s,\n+    tw_bf * bf,\n+    em_message * msg,\n+    tw_lp * lp)\n+{\n+  int indx = msg->vc_index;\n+  int output_chan = msg->output_chan;\n+  s->vc_occupancy[indx][output_chan] += s->params->chunk_size;\n+  if(bf->c3)\n+  {\n+    s->busy_time[indx] = msg->saved_rcv_time;\n+    s->busy_time_sample[indx] = msg->saved_sample_time;\n+    s->last_buf_full[indx] = msg->saved_busy_time;\n+  }\n+  if(bf->c1) {\n+    message_list* head = return_tail(s->pending_msgs[indx],\n+        s->pending_msgs_tail[indx], output_chan);\n+    tw_rand_reverse_unif(lp->rng);\n+    if(bf->c21) {\n+      head->in_alt_q = 1;\n+      altq_add_to_message_list(s->queued_msgs, s->queued_msgs_tail, head);\n+    }\n+    head->port = indx; head->index = output_chan;\n+    prepend_to_message_list(s->queued_msgs[indx], \n+        s->queued_msgs_tail[indx], output_chan, head);\n+    s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n+    s->queued_count[indx] += s->params->chunk_size;\n+  }\n+  if(bf->c2) {\n+    codes_local_latency_reverse(lp);\n+    s->in_send_loop[indx] = 0;\n+  }\n+}\n+\n+static void router_event(router_state * s, tw_bf * bf, em_message * msg, \n+    tw_lp * lp) {\n+  s->fwd_events++;\n+  rc_stack_gc(lp, s->st);\n+  assert(msg->magic == router_magic_num);\n+  switch(msg->type)\n+  {\n+    case R_SEND: \n+      router_packet_send(s, bf, msg, lp);\n+      break;\n+\n+    case R_ARRIVE: \n+      router_packet_receive(s, bf, msg, lp);\n+      break;\n+\n+    case R_BUFFER:\n+      router_buf_update(s, bf, msg, lp);\n+      break;\n+\n+    default:\n+      printf(\"\\n (%lf) [Router %d] Router Message type not supported %d dest \" \n+          \"terminal id %d packet ID %d \", tw_now(lp), (int)lp->gid, msg->type, \n+          (int)msg->dest_terminal_id, (int)msg->packet_ID);\n+      tw_error(TW_LOC, \"Msg type not supported\");\n+      break;\n+  }\t   \n+}\n+\n+/* Reverse computation handler for a router event */\n+static void router_rc_event_handler(router_state * s, tw_bf * bf, \n+    em_message * msg, tw_lp * lp) {\n+  s->rev_events++;\n+\n+  switch(msg->type) {\n+    case R_SEND: \n+      router_packet_send_rc(s, bf, msg, lp);\n+      break;\n+    case R_ARRIVE: \n+      router_packet_receive_rc(s, bf, msg, lp);\n+      break;\n+\n+    case R_BUFFER: \n+      router_buf_update_rc(s, bf, msg, lp);\n+      break;\n+  }\n+}\n+\n+static void router_final(router_state * s,\n+    tw_lp * lp)\n+{\n+  int i, j;\n+  for(i = 0; i < s->params->radix; i++) {\n+    for(j = 0; j < s->params->num_vcs; j++) {\n+      if(s->queued_msgs[i][j] != NULL) {\n+        printf(\"[%llu] leftover queued messages %d %d %d\\n\", LLU(lp->gid), i, j,\n+            s->vc_occupancy[i][j]);\n+      }\n+      if(s->pending_msgs[i][j] != NULL) {\n+        printf(\"[%llu] lefover pending messages %d %d\\n\", LLU(lp->gid), i, j);\n+      }\n+    }\n+  }\n+\n+  rc_stack_destroy(s->st);\n+\n+  const em_param *p = s->params;\n+  int written = 0;\n+  if(!s->router_id)\n+  {\n+    written = sprintf(s->output_buf, \"# Format <LP ID> <Router ID> <Busy time per router port(s)>\");\n+  }\n+  written += sprintf(s->output_buf + written, \"\\n %llu %d \", \n+      LLU(lp->gid),\n+      s->router_id);\n+  for(int d = 0; d < p->radix; d++) \n+    written += sprintf(s->output_buf + written, \" %lf\", s->busy_time[d]);\n+\n+  lp_io_write(lp->gid, (char*)\"em-router-stats\", written, s->output_buf);\n+\n+  written = 0;\n+  if(!s->router_id)\n+  {\n+    written = sprintf(s->output_buf2, \"# Format <LP ID> <Router ID> <Link traffic per router port(s)>\");\n+  }\n+  written += sprintf(s->output_buf2 + written, \"\\n %llu %d \",\n+      LLU(lp->gid),\n+      s->router_id);\n+\n+  for(int d = 0; d < p->radix; d++) \n+    written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n+\n+  assert(written < 4096);\n+  lp_io_write(lp->gid, (char*)\"em-router-traffic\", written, s->output_buf2);\n+}\n+\n+static void em_rsample_init(router_state * s,\n+    tw_lp * lp)\n+{\n+  (void)lp;\n+  int i = 0;\n+  const em_param * p = s->params;\n+\n+  assert(p->radix);\n+\n+  s->max_arr_size = MAX_STATS;\n+  s->rsamples = (struct em_router_sample *)malloc(MAX_STATS * sizeof(struct em_router_sample)); \n+  for(; i < s->max_arr_size; i++)\n+  {\n+    s->rsamples[i].busy_time = (tw_stime *)malloc(sizeof(tw_stime) * p->radix); \n+    s->rsamples[i].link_traffic_sample = (int64_t *)malloc(sizeof(int64_t) * p->radix);\n+  }\n+}\n+\n+void em_rsample_rc_fn(router_state * s,\n+    tw_bf * bf,\n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  (void)bf;\n+  (void)lp;\n+  (void)msg;\n+\n+  s->op_arr_size--;\n+  int cur_indx = s->op_arr_size;\n+  struct em_router_sample stat = s->rsamples[cur_indx];\n+\n+  const em_param * p = s->params;\n+  int i =0;\n+\n+  for(; i < p->radix; i++)\n+  {\n+    s->busy_time_sample[i] = stat.busy_time[i];\n+    s->link_traffic_sample[i] = stat.link_traffic_sample[i];\n+  }\n+\n+  for( i = 0; i < p->radix; i++)\n+  {\n+    stat.busy_time[i] = 0;\n+    stat.link_traffic_sample[i] = 0;\n+  }\n+  s->fwd_events = stat.fwd_events;\n+  s->rev_events = stat.rev_events;\n+}\n+\n+static void em_rsample_fn(router_state * s,\n+    tw_bf * bf,\n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  (void)bf;\n+  (void)lp;\n+  (void)msg;\n+\n+  const em_param * p = s->params; \n+\n+  if(s->op_arr_size >= s->max_arr_size) \n+  {\n+    struct em_router_sample * tmp = (struct em_router_sample *)malloc((MAX_STATS + s->max_arr_size) * sizeof(struct em_router_sample));\n+    memcpy(tmp, s->rsamples, s->op_arr_size * sizeof(struct em_router_sample));\n+    free(s->rsamples);\n+    s->rsamples = tmp;\n+    s->max_arr_size += MAX_STATS;\n+  }\n+\n+  int i = 0;\n+  int cur_indx = s->op_arr_size; \n+\n+  s->rsamples[cur_indx].router_id = s->router_id;\n+  s->rsamples[cur_indx].end_time = tw_now(lp);\n+  s->rsamples[cur_indx].fwd_events = s->fwd_events;\n+  s->rsamples[cur_indx].rev_events = s->rev_events;\n+\n+  for(; i < p->radix; i++)\n+  {\n+    s->rsamples[cur_indx].busy_time[i] = s->busy_time_sample[i]; \n+    s->rsamples[cur_indx].link_traffic_sample[i] = s->link_traffic_sample[i]; \n+  }\n+\n+  s->op_arr_size++;\n+\n+  /* clear up the current router stats */\n+  s->fwd_events = 0;\n+  s->rev_events = 0;\n+\n+  for( i = 0; i < p->radix; i++)\n+  {\n+    s->busy_time_sample[i] = 0;\n+    s->link_traffic_sample[i] = 0;\n+  }\n+}\n+\n+static void em_rsample_fin(router_state * s,\n+    tw_lp * lp)\n+{\n+  (void)lp;\n+  const em_param * p = s->params;\n+\n+  if(!g_tw_mynode)\n+  {\n+\n+    /* write metadata file */\n+    char meta_fname[64];\n+    sprintf(meta_fname, \"em-router-sampling.meta\");\n+\n+    FILE * fp = fopen(meta_fname, \"w\");\n+    fprintf(fp, \"Router sample struct format: \\nrouter_id (tw_lpid) \\nbusy time for each of the %d links (double) \\n\"\n+        \"link traffic for each of the %d links (int64_t) \\nsample end time (double) forward events per sample \\nreverse events per sample \",\n+        p->radix, p->radix);\n+    fprintf(fp, \"\\n\\nOrdering of links \\n%d local (router-router same group) channels \\n%d global (router-router remote group)\"\n+        \" channels \\n%d terminal channels\", p->radix/2, p->radix/4, p->radix/4);\n+    fclose(fp);\n+  }\n+  char rt_fn[MAX_NAME_LENGTH];\n+  if(strcmp(em_rtr_sample_file, \"\") == 0)\n+    sprintf(rt_fn, \"em-router-sampling-%ld.bin\", g_tw_mynode); \n+  else\n+    sprintf(rt_fn, \"%s-%ld.bin\", em_rtr_sample_file, g_tw_mynode);\n+\n+  int i = 0;\n+\n+  int size_sample = sizeof(tw_lpid) + p->radix * (sizeof(int64_t) + sizeof(tw_stime)) + sizeof(tw_stime) + 2 * sizeof(long);\n+  FILE * fp = fopen(rt_fn, \"a\");\n+  fseek(fp, sample_rtr_bytes_written, SEEK_SET);\n+\n+  for(; i < s->op_arr_size; i++)\n+  {\n+    fwrite((void*)&(s->rsamples[i].router_id), sizeof(tw_lpid), 1, fp);\n+    fwrite(s->rsamples[i].busy_time, sizeof(tw_stime), p->radix, fp);\n+    fwrite(s->rsamples[i].link_traffic_sample, sizeof(int64_t), p->radix, fp);\n+    fwrite((void*)&(s->rsamples[i].end_time), sizeof(tw_stime), 1, fp);\n+    fwrite((void*)&(s->rsamples[i].fwd_events), sizeof(long), 1, fp);\n+    fwrite((void*)&(s->rsamples[i].rev_events), sizeof(long), 1, fp);\n+  }\n+  sample_rtr_bytes_written += (s->op_arr_size * size_sample);\n+  fclose(fp);\n+}\n+\n+static void em_sample_init(terminal_state * s,\n+    tw_lp * lp)\n+{\n+  (void)lp;\n+  s->fin_chunks_sample = 0;\n+  s->data_size_sample = 0;\n+  s->fin_hops_sample = 0;\n+  s->fin_chunks_time = 0;\n+  s->busy_time_sample = 0;\n+\n+  s->op_arr_size = 0;\n+  s->max_arr_size = MAX_STATS;\n+\n+  s->sample_stat = (struct em_cn_sample *)malloc(MAX_STATS * sizeof(struct em_cn_sample));\n+}\n+\n+void em_sample_rc_fn(terminal_state * s,\n+    tw_bf * bf,\n+    em_message * msg, \n+    tw_lp * lp)\n+{\n+  (void)lp;\n+  (void)bf;\n+  (void)msg;\n+\n+  s->op_arr_size--;\n+  int cur_indx = s->op_arr_size;\n+  struct em_cn_sample stat = s->sample_stat[cur_indx];\n+  s->busy_time_sample = stat.busy_time_sample;\n+  s->fin_chunks_time = stat.fin_chunks_time;\n+  s->fin_hops_sample = stat.fin_hops_sample;\n+  s->data_size_sample = stat.data_size_sample;\n+  s->fin_chunks_sample = stat.fin_chunks_sample;\n+  s->fwd_events = stat.fwd_events;\n+  s->rev_events = stat.rev_events;\n+\n+  stat.busy_time_sample = 0;\n+  stat.fin_chunks_time = 0;\n+  stat.fin_hops_sample = 0;\n+  stat.data_size_sample = 0;\n+  stat.fin_chunks_sample = 0;\n+  stat.end_time = 0;\n+  stat.terminal_id = 0;\n+  stat.fwd_events = 0;\n+  stat.rev_events = 0;\n+}\n+\n+static void em_sample_fn(terminal_state * s,\n+    tw_bf * bf,\n+    em_message * msg,\n+    tw_lp * lp)\n+{\n+  (void)lp;\n+  (void)msg;\n+  (void)bf;\n+\n+  if(s->op_arr_size >= s->max_arr_size)\n+  {\n+    /* In the worst case, copy array to a new memory location, its very\n+     * expensive operation though */\n+    struct em_cn_sample * tmp = (struct em_cn_sample *)malloc((MAX_STATS + s->max_arr_size) * sizeof(struct em_cn_sample));\n+    memcpy(tmp, s->sample_stat, s->op_arr_size * sizeof(struct em_cn_sample));\n+    free(s->sample_stat);\n+    s->sample_stat = tmp;\n+    s->max_arr_size += MAX_STATS;\n+  }\n+\n+  int cur_indx = s->op_arr_size;\n+\n+  s->sample_stat[cur_indx].terminal_id = s->terminal_id;\n+  s->sample_stat[cur_indx].fin_chunks_sample = s->fin_chunks_sample;\n+  s->sample_stat[cur_indx].data_size_sample = s->data_size_sample;\n+  s->sample_stat[cur_indx].fin_hops_sample = s->fin_hops_sample;\n+  s->sample_stat[cur_indx].fin_chunks_time = s->fin_chunks_time;\n+  s->sample_stat[cur_indx].busy_time_sample = s->busy_time_sample;\n+  s->sample_stat[cur_indx].end_time = tw_now(lp);\n+  s->sample_stat[cur_indx].fwd_events = s->fwd_events;\n+  s->sample_stat[cur_indx].rev_events = s->rev_events;\n+\n+  s->op_arr_size++;\n+  s->fin_chunks_sample = 0;\n+  s->data_size_sample = 0;\n+  s->fin_hops_sample = 0;\n+  s->fwd_events = 0;\n+  s->rev_events = 0;\n+  s->fin_chunks_time = 0;\n+  s->busy_time_sample = 0;\n+}\n+\n+static void em_sample_fin(terminal_state * s,\n+    tw_lp * lp)\n+{\n+  (void)lp;\n+\n+  if(!g_tw_mynode)\n+  {\n+\n+    /* write metadata file */\n+    char meta_fname[64];\n+    sprintf(meta_fname, \"em-cn-sampling.meta\");\n+\n+    FILE * fp = fopen(meta_fname, \"w\");\n+    fprintf(fp, \"Compute node sample format\\nterminal_id (tw_lpid) \\nfinished chunks (long)\"\n+        \"\\ndata size per sample (long) \\nfinished hops (double) \\ntime to finish chunks (double)\"\n+        \"\\nbusy time (double)\\nsample end time(double) \\nforward events (long) \\nreverse events (long)\");\n+    fclose(fp);\n+  }\n+  char rt_fn[MAX_NAME_LENGTH];\n+  if(strncmp(em_cn_sample_file, \"\", 10) == 0)\n+    sprintf(rt_fn, \"em-cn-sampling-%ld.bin\", g_tw_mynode); \n+  else\n+    sprintf(rt_fn, \"%s-%ld.bin\", em_cn_sample_file, g_tw_mynode);\n+\n+  FILE * fp = fopen(rt_fn, \"a\");\n+  fseek(fp, sample_bytes_written, SEEK_SET);\n+  fwrite(s->sample_stat, sizeof(struct em_cn_sample), s->op_arr_size, fp);\n+  fclose(fp);\n+\n+  sample_bytes_written += (s->op_arr_size * sizeof(struct em_cn_sample));\n+}\n+\n+\n+/* EM compute node and router LP types */\n+tw_lptype em_lps[] =\n+{\n+  // Terminal handling functions\n+  {\n+    (init_f)terminal_init,\n+    (pre_run_f) NULL,\n+    (event_f) terminal_event,\n+    (revent_f) terminal_event_rc,\n+    (commit_f) NULL,\n+    (final_f) terminal_final,\n+    (map_f) codes_mapping,\n+    sizeof(terminal_state)\n+  },\n+  {\n+    (init_f) router_setup,\n+    (pre_run_f) NULL,\n+    (event_f) router_event,\n+    (revent_f) router_rc_event_handler,\n+    (commit_f) NULL,\n+    (final_f) router_final,\n+    (map_f) codes_mapping,\n+    sizeof(router_state),\n+  },\n+  {NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0},\n+};\n+\n+/* returns the EM lp type for lp registration */\n+static const tw_lptype* em_get_cn_lp_type(void)\n+{\n+  return(&em_lps[0]);\n+}\n+static const tw_lptype* router_get_lp_type(void)\n+{\n+  return (&em_lps[1]);\n+}\n+\n+static void em_register(tw_lptype *base_type) {\n+  lp_type_register(LP_CONFIG_NM_TERM, base_type);\n+}\n+\n+static void router_register(tw_lptype *base_type) {\n+  lp_type_register(LP_CONFIG_NM_ROUT, base_type);\n+}\n+\n+extern \"C\" {\n+struct model_net_method express_mesh_method  = \n+{\n+  0,\n+  em_configure,\n+  em_register,\n+  em_packet_event,\n+  em_packet_event_rc,\n+  NULL,\n+  NULL,\n+  em_get_cn_lp_type,\n+  em_get_msg_sz,\n+  em_report_stats,\n+  NULL,\n+  NULL,\n+  NULL,//(event_f)em_sample_fn,  \n+  NULL,//(revent_f)em_sample_rc_fn, \n+  (init_f)em_sample_init,\n+  NULL//(final_f)em_sample_fin,  \n+};\n+\n+struct model_net_method express_mesh_router_method =\n+{\n+  0,\n+  NULL,\n+  router_register,\n+  NULL,\n+  NULL,\n+  NULL,\n+  NULL,\n+  router_get_lp_type,\n+  em_get_msg_sz,\n+  NULL,\n+  NULL,\n+  NULL,\n+  NULL,//(event_f)em_rsample_fn,  \n+  NULL,//(revent_f)em_rsample_rc_fn, \n+  (init_f)em_rsample_init,\n+  NULL//(final_f)em_rsample_fin,  \n+};\n+\n+}\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 12,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/fattree.c",
                        "old_path": "src/networks/model-net/fattree.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/fattree.c\n+++ b/src/networks/model-net/fattree.c\n@@ -87,9 +87,15 @@ static int mapping_grp_id, mapping_type_id, mapping_rep_id, mapping_offset;\n \n enum ROUTING_ALGO\n {\n-    STATIC=0,\n+    STATIC=1,\n     ADAPTIVE,\n };\n+\n+enum RAIL_SELECTION_ALGO\n+{\n+    RAIL_DEDICATED=1,\n+    RAIL_ADAPTIVE,\n+};\n static char routing_folder[MAX_NAME_LENGTH];\n static char dot_file_p[MAX_NAME_LENGTH];\n \n@@ -141,14 +147,20 @@ struct fattree_param\n   int chunk_size; /* full-sized packets are broken into smaller chunks.*/\n   int packet_size;\n   int num_terminals;\n-  int l1_set_size;\n-  int l1_term_size;\n+  int l1_set_size, l0_set_size;\n+  int l1_term_size, l0_term_size;\n+  int cn_per_switch;\n+  double tapering_ratio;\n   double cn_delay;\n   double head_delay;\n   double credit_delay;\n   double router_delay;\n   double soft_delay;\n   int routing;\n+  int rail_select;\n+  int rail_size_limit;\n+  int num_rails;\n+  int ports_per_nic;\n };\n \n struct ftree_hash_key\n@@ -180,20 +192,20 @@ struct ft_terminal_state\n   // Fattree specific parameters\n   unsigned int terminal_id;\n   unsigned int switch_id;\n-  tw_lpid switch_lp;\n+  unsigned int rail_id;\n+  tw_lpid *switch_lp;\n \n   // Each terminal will have an input and output channel with the switch\n-  int vc_occupancy; // NUM_VC\n-  tw_stime terminal_available_time;\n-  tw_stime next_credit_available_time;\n+  int *vc_occupancy; // NUM_VC\n+  tw_stime* terminal_available_time;\n \n   struct mn_stats fattree_stats_array[CATEGORY_MAX];\n \n   fattree_message_list **terminal_msgs;\n   fattree_message_list **terminal_msgs_tail;\n-  int terminal_length;\n-  int in_send_loop;\n-  int issueIdle;\n+  int *terminal_length;\n+  int *in_send_loop;\n+  int *issueIdle;\n \n    struct rc_stack * st;\n \n@@ -210,8 +222,8 @@ struct ft_terminal_state\n   long finished_chunks;\n   long finished_packets;\n \n-  tw_stime last_buf_full;\n-  tw_stime busy_time;\n+  tw_stime *last_buf_full;\n+  tw_stime *busy_time;\n   char output_buf[4096];\n   char output_buf3[4096];\n \n@@ -246,6 +258,7 @@ struct switch_state\n {\n   unsigned int switch_id;\n   int switch_level;\n+  unsigned int rail_id;\n   int radix;\n   int num_cons;\n   int num_lcons;\n@@ -257,7 +270,6 @@ struct switch_state\n   int unused;\n \n   tw_stime* next_output_available_time;\n-  tw_stime* next_credit_available_time;\n   tw_stime* last_buf_full;\n \n   tw_stime* busy_time;\n@@ -558,17 +570,18 @@ static void dot_write_open_file(FILE **fout)\n }*/\n \n /* sw IDs aren't unique, but level+ID info is */\n-static void dot_write_switch_info(switch_state *s, int sw_gid, FILE *fout)\n+static void dot_write_switch_info(switch_state *s, FILE *fout)\n {\n   if(!s || s->unused || !(s->params) || !fout) return;\n   if(!dump_topo) return;\n+  if(s->rail_id) return;\n \n   const char *root_attr = \",root_switch\", *empty_attr = \"\";\n   uint64_t switch_guid = get_switch_guid(s);\n   fattree_param *p = s->params;\n \n   fprintf(fout, \"\\t\\\"S_%d_%d\\\" [comment=\\\"0x%016\"PRIx64\",radix=%d%s\\\"];\\n\",\n-      s->switch_level, sw_gid, switch_guid, s->radix,\n+      s->switch_level, s->switch_id, switch_guid, s->radix,\n       (p->num_levels == s->switch_level + 1) ? root_attr : empty_attr);\n }\n \n@@ -577,6 +590,7 @@ static void dot_write_term_info(ft_terminal_state *t, FILE *fout)\n {\n   uint64_t term_guid = t->terminal_id;\n   if(!dump_topo) return;\n+  if(t->rail_id) return;\n \n   if(!t || !fout) return;\n   /* need to shift the term guid, because opensm doesn't like guid=0...0 */\n@@ -678,6 +692,7 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n   p->ft_type = 1;\n   configuration_get_value_int(&config, \"PARAMS\", \"ft_type\", anno,\n       &p->ft_type);\n+  if(!g_tw_mynode) printf(\"FT type is %d\\n\", p->ft_type);\n \n   configuration_get_value_int(&config, \"PARAMS\", \"num_levels\", anno,\n       &p->num_levels);\n@@ -687,6 +702,14 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n   if(p->num_levels > 3) {\n     tw_error(TW_LOC, \"Too many num_levels, only upto 3 supported Aborting\\n\");\n   }\n+  if(!g_tw_mynode) printf(\"FT num levels is %d\\n\", p->num_levels);\n+  \n+  p->tapering_ratio = 1;\n+  configuration_get_value_double(&config, \"PARAMS\", \"tapering\", anno,\n+      &p->tapering_ratio);\n+  if(!g_tw_mynode) printf(\"FT tapering is %lf\\n\", p->tapering_ratio);\n+\n+  p->tapering_ratio += 1;\n \n   p->num_switches = (int *) malloc (p->num_levels * sizeof(int));\n   p->switch_radix = (int*) malloc (p->num_levels * sizeof(int));\n@@ -732,91 +755,107 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n     token = strtok(NULL,\",\");\n   }\n \n+  if(fmod(p->switch_radix[0],  p->tapering_ratio)) {\n+    tw_error(TW_LOC, \"Tapering ratio does not fit the given radix; tapering + 1 should\"\n+    \" evenly divide the L0 switch radix\\n\");\n+  }\n+\n   p->Ns = p->switch_radix[0]/2;\n-  int num_terminals = p->num_switches[0]*p->switch_radix[0]/2;\n+  if(p->num_switches[0] % p->Ns) {\n+    if(!g_tw_mynode) printf(\"Number of switches has to be a multiple of switch radix/2 (%d);\" \n+        \"next largest value is %d\\n\", p->Ns, (p->num_switches[0]/p->Ns + 1)*p->Ns);\n+    tw_error(TW_LOC, \"Incorrect number of switches\");\n+  }\n+\n+  int num_terminals = p->num_switches[0] * (p->tapering_ratio - 1)*(p->switch_radix[0]/p->tapering_ratio);\n+  p->num_terminals = num_terminals;\n+    \n+  p->l0_set_size = p->switch_radix[0]/2;\n+  p->l0_term_size = (p->tapering_ratio - 1)*(p->switch_radix[0]/p->tapering_ratio);\n \n   if(p->num_levels == 2) {\n-    p->num_switches[1] = p->num_switches[0]/2;\n+    p->num_switches[1] = p->num_switches[0]/p->tapering_ratio/2;\n     p->switch_radix[1] = p->switch_radix[0];\n-    p->l1_set_size = p->switch_radix[0]/4;\n-    p->l1_term_size = (p->l1_set_size * p->switch_radix[0]);\n-\n+    p->l1_set_size =  p->num_switches[1];\n+    p->l1_term_size = num_terminals;\n   } else {\n-\tif(p->ft_type == 0){\n-      p->Np = ceil((num_terminals)/(double)(p->Ns*p->Ns));\n-      p->num_switches[1] = p->num_switches[0];\n-      p->num_switches[2] = ceil((p->Ns*p->Ns) / floor(p->switch_radix[0]/p->Np));\n-      p->switch_radix[1] = p->switch_radix[2] = p->switch_radix[0];\n-      p->link_repetitions = floor(p->switch_radix[2] / p->Np);\n-      printf(\"Np:%d Ns:%d\\n\",p->Np,p->Ns);\n-\t}else{\n-\t  p->num_switches[1] = p->num_switches[0];\n-      p->num_switches[2] = p->num_switches[0]/2;\n-      p->switch_radix[1] = p->switch_radix[2] = p->switch_radix[0];\n-\t}\n-\tp->l1_set_size = p->switch_radix[0]/2;\n-    p->l1_term_size = (p->l1_set_size * (p->switch_radix[0] / 2));\n+    p->switch_radix[1] = p->switch_radix[2] = p->switch_radix[0];\n+\t  p->l1_set_size = p->switch_radix[0]/p->tapering_ratio;\n+    p->l1_term_size = p->l0_set_size * p->l0_term_size;\n+    p->Np = p->num_switches[0]/p->l0_set_size;\n+    p->num_switches[1] =  p->Np * p->l1_set_size;\n+    p->link_repetitions = p->switch_radix[0]/p->Np;\n+    if(p->l1_set_size % p->link_repetitions) {\n+      while(p->l1_set_size % p->link_repetitions) {\n+        p->link_repetitions--;\n+      }\n+    } \n+    int halfPods = p->l1_set_size/p->link_repetitions;\n+    p->num_switches[2] = halfPods * p->Ns;\n+    if(!g_tw_mynode) printf(\"Pods %d; L2 pods %d; Link repetition:%d; l1_set_size %d\\n\", \n+        p->Np, halfPods, p->link_repetitions, p->l1_set_size);\n+  }\n+\n+  if(p->ft_type == 1 && p->num_levels == 3) {\n+    if(p->Np != p->switch_radix[0] && p->Np !=  p->switch_radix[0]/2) {\n+      if(!g_tw_mynode) {\n+        printf(\"ft_type 1 should be used for a system with %d or %d pods, which \"\n+        \"needs %d or %d L0 switches, respectively\\n\",  p->switch_radix[0], \n+         p->switch_radix[0]/2,  p->switch_radix[0] *  p->switch_radix[0]/2,\n+          p->switch_radix[0]/2 *  p->switch_radix[0]/2);\n+      }\n+      tw_error(TW_LOC, \"Incorrect number of switches for ft_type 1\");\n+    }\n   }\n \n-#if FATTREE_CONNECTIONS\n-  for(int jj=0;jj<3;jj++)\n+  for(int jj=0;jj<3 && !g_tw_mynode;jj++)\n   {\n     printf(\"num_switches[%d]=%d\\n\",jj,p->num_switches[jj]);\n-    printf(\"switch_radix[%d]=%d\\n\",jj,p->switch_radix[jj]);\n-  }\n-#endif\n-\n-  i = 1;\n-  for(i = 1; i < p->num_levels - 1; i++) {\n-    if(p->num_switches[i - 1] * p->switch_radix[i - 1] >\n-       p->num_switches[i] * p->switch_radix[i]) {\n-      tw_error(TW_LOC, \"Not enough switches/radix at level %d for full \"\n-          \"bisection bandwidth\\n\", i);\n-    }\n   }\n \n-  if(p->num_switches[i - 1] * p->switch_radix[i - 1] > 2 * p->num_switches[i] *\n-      p->switch_radix[i]) {\n-    tw_error(TW_LOC, \"Not enough switches/radix at level %d (top) for full \"\n-        \"bisection bandwidth\\n\", i);\n-  }\n-\n-  configuration_get_value_int(&config, \"PARAMS\", \"packet_size\", anno,\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"packet_size\", anno,\n       &p->packet_size);\n-  if(!p->packet_size) {\n+  if(rc) {\n     p->packet_size = 512;\n-    fprintf(stderr, \"Packet size is not specified, setting to %d\\n\",\n-        p->packet_size);\n+  }\n+  if(!g_tw_mynode) printf(\"FT packet size is %d\\n\", p->packet_size);\n+\n+  p->num_rails = 1;\n+  configuration_get_value_int(&config, \"PARAMS\", \"num_rails\", anno, &p->num_rails);\n+  if(!g_tw_mynode) printf(\"FT num rails is %d\\n\", p->num_rails);\n+  \n+  if(p->ft_type == 2) {\n+    p->ports_per_nic = p->num_rails;\n+  } else {\n+    p->ports_per_nic = 1;\n   }\n \n   p->router_delay = 50;\n   configuration_get_value_double(&config, \"PARAMS\", \"router_delay\", anno,\n       &p->router_delay);\n+  if(!g_tw_mynode) printf(\"FT router delay is %.1lf\\n\", p->router_delay);\n \n   p->soft_delay = 1000;\n   configuration_get_value_double(&config, \"PARAMS\", \"soft_delay\", anno,\n       &p->soft_delay);\n \n-  configuration_get_value_int(&config, \"PARAMS\", \"vc_size\", anno, &p->vc_size);\n-  if(!p->vc_size) {\n-    p->vc_size = 8*p->packet_size;\n-    fprintf(stderr, \"Buffer size of global channels not specified, setting to \"\n-        \"%d\\n\", p->vc_size);\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"vc_size\", anno, &p->vc_size);\n+  if(rc) {\n+    p->vc_size = 8 * p->packet_size;\n   }\n+  if(!g_tw_mynode) printf(\"FT buffer size links is %d\\n\", p->vc_size);\n \n-  configuration_get_value_int(&config, \"PARAMS\", \"cn_vc_size\", anno,\n+  rc = configuration_get_value_int(&config, \"PARAMS\", \"cn_vc_size\", anno,\n       &p->cn_vc_size);\n-  if(!p->cn_vc_size) {\n-    p->cn_vc_size = 8*p->packet_size;\n-    fprintf(stderr, \"Buffer size of compute node channels not specified, \"\n-        \"setting to %d\\n\", p->cn_vc_size);\n+  if(rc) {\n+    p->cn_vc_size = 8 * p->packet_size;\n   }\n+  if(!g_tw_mynode) printf(\"FT buffer size injection is %d\\n\", p->cn_vc_size);\n \n   rc = configuration_get_value_int(&config, \"PARAMS\", \"chunk_size\", anno, &p->chunk_size);\n-    if(rc) {\n-        p->chunk_size = 512;\n-        fprintf(stderr, \"Chunk size for packets is specified, setting to %d\\n\", p->chunk_size);\n-    }\n+  if(rc) {\n+    p->chunk_size = 512;\n+  }\n \n   char routing_str[MAX_NAME_LENGTH];\n   configuration_get_value(&config, \"PARAMS\", \"routing\", anno, routing_str,\n@@ -827,10 +866,26 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n     p->routing = ADAPTIVE;\n   else\n   {\n-    fprintf(stderr, \n-        \"No routing protocol specified, setting to adaptive routing\\n\");\n     p->routing = ADAPTIVE;\n   }\n+  if(!g_tw_mynode) printf(\"FT routing is %d\\n\", p->routing);\n+  \n+  char rail_select_str[MAX_NAME_LENGTH];\n+  configuration_get_value(&config, \"PARAMS\", \"rail_select\", anno, rail_select_str,\n+      MAX_NAME_LENGTH);\n+  if(strcmp(rail_select_str, \"dedicated\") == 0)\n+    p->rail_select = RAIL_DEDICATED;\n+  else if(strcmp(rail_select_str, \"adaptive\")==0)\n+    p->rail_select = RAIL_ADAPTIVE;\n+  else {\n+    p->rail_select = RAIL_DEDICATED;\n+  }\n+  if(!g_tw_mynode) printf(\"FT rail selection is %d\\n\", p->rail_select);\n+\n+  p->rail_size_limit = 32768;\n+  configuration_get_value_int(&config, \"PARAMS\", \"rail_select_limit\", anno,\n+      &p->rail_size_limit);\n+  if(!g_tw_mynode) printf(\"FT rail select limit  is %d\\n\", p->rail_size_limit);\n   \n   configuration_get_value_int(&config, \"PARAMS\", \"dump_topo\", anno,\n       &dump_topo);\n@@ -855,21 +910,20 @@ static void fattree_read_config(const char * anno, fattree_param *p){\n     }\n   }\n   \n-  configuration_get_value_double(&config, \"PARAMS\", \"link_bandwidth\", anno,\n+  rc = configuration_get_value_double(&config, \"PARAMS\", \"link_bandwidth\", anno,\n       &p->link_bandwidth);\n-  if(!p->link_bandwidth) {\n+  if(rc) {\n     p->link_bandwidth = 5;\n-    fprintf(stderr, \"Bandwidth of links is specified, setting to %lf\\n\",\n-        p->link_bandwidth);\n   }\n \n-  configuration_get_value_double(&config, \"PARAMS\", \"cn_bandwidth\", anno,\n+  rc = configuration_get_value_double(&config, \"PARAMS\", \"cn_bandwidth\", anno,\n       &p->cn_bandwidth);\n   if(!p->cn_bandwidth) {\n     p->cn_bandwidth = 5;\n-    fprintf(stderr, \"Bandwidth of compute node channels not specified, \"\n-        \"setting to %lf\\n\", p->cn_bandwidth);\n   }\n+  \n+  if(!g_tw_mynode) printf(\"FT bandwidths link %.1lf node %.1lf\\n\", \n+      p->link_bandwidth, p->cn_bandwidth);\n \n #if FATTREE_DEBUG\n   printf(\"l1_set_size:%d l1_term_size:%d\\n\",p->l1_set_size,p->l1_term_size);\n@@ -927,61 +981,83 @@ void ft_terminal_init( ft_terminal_state * s, tw_lp * lp )\n    int num_lps = codes_mapping_get_lp_count(lp_group_name, 1, LP_CONFIG_NM,\n            s->anno, 0);\n \n-   if(num_lps != (s->params->switch_radix[0]/2)) {\n-     tw_error(TW_LOC, \"Number of NICs per repetition has to be equal to \"\n-         \"half the radix of leaf level switches %d vs %d\\n\", num_lps,\n-          s->params->switch_radix[0]/2);\n+   if(s->params->ft_type != 2) {\n+    num_lps /= s->params->num_rails;\n    }\n-   s->terminal_id = (mapping_rep_id * num_lps) + mapping_offset;\n-   s->switch_id = s->terminal_id / (s->params->switch_radix[0] / 2);\n-   codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-           s->switch_id, 0, &s->switch_lp);\n-   s->terminal_available_time = 0.0;\n-   s->packet_counter = 0;\n+\n+   if(num_lps != s->params->l0_term_size) {\n+     tw_error(TW_LOC, \"Number of NICs per repetition per rail has to be equal to \"\n+         \"%d, not the given value of %d\\n\", s->params->l0_term_size, num_lps);\n+   }\n+  \n+   if(s->params->ft_type != 2) {\n+    s->terminal_id = (mapping_rep_id * num_lps) + (mapping_offset/s->params->num_rails);\n+    s->rail_id = (mapping_offset % s->params->num_rails);\n+   } else {\n+    s->terminal_id = (mapping_rep_id * num_lps) + mapping_offset;\n+    s->rail_id = 0;\n+   }\n+   s->switch_id = s->terminal_id / s->params->l0_term_size;\n+   s->switch_lp = (tw_lpid*)malloc(s->params->ports_per_nic * sizeof(tw_lpid));\n+   if(s->params->ft_type != 2) {\n+     codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n+         s->switch_id, 0 + s->params->num_levels * s->rail_id, &s->switch_lp[0]);\n+   } else {\n+     for(int i = 0; i < s->params->ports_per_nic; i++) {\n+       codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n+           s->switch_id, 0 + s->params->num_levels * i, &s->switch_lp[i]);\n+     }\n+   }\n+   s->terminal_available_time = (tw_stime*) malloc(s->params->ports_per_nic * sizeof(tw_stime));\n+   s->vc_occupancy = (int*) malloc(s->params->ports_per_nic * sizeof(int));\n+   s->terminal_length = (int*) malloc(s->params->ports_per_nic * sizeof(int));\n+   s->in_send_loop = (int*) malloc(s->params->ports_per_nic * sizeof(int));\n+   s->issueIdle = (int*) malloc(s->params->ports_per_nic * sizeof(int));\n    s->terminal_msgs =\n-     (fattree_message_list**)malloc(1*sizeof(fattree_message_list*));\n+     (fattree_message_list**)malloc(s->params->ports_per_nic*sizeof(fattree_message_list*));\n    s->terminal_msgs_tail =\n-     (fattree_message_list**)malloc(1*sizeof(fattree_message_list*));\n-\n+     (fattree_message_list**)malloc(s->params->ports_per_nic*sizeof(fattree_message_list*));\n+   s->last_buf_full = (tw_stime*) malloc(s->params->ports_per_nic * sizeof(tw_stime));\n+   s->busy_time = (tw_stime*) malloc(s->params->ports_per_nic * sizeof(tw_stime));\n+   for(int i = 0; i < s->params->ports_per_nic; i++) {\n+     s->terminal_available_time[i] = 0.0;\n+     s->vc_occupancy[i] = 0;\n+     s->terminal_msgs[i] = NULL;\n+     s->terminal_msgs_tail[i] = NULL;\n+     s->terminal_length[i] = 0;\n+     s->in_send_loop[i] = 0;\n+     s->issueIdle[i] = 0;\n+     s->last_buf_full[i] = 0;\n+     s->busy_time[i] = 0;\n+   }\n+   s->packet_counter = 0;\n    s->finished_msgs = 0;\n    s->finished_chunks = 0;\n    s->finished_packets = 0;\n    s->total_time = 0.0;\n    s->total_msg_size = 0;\n \n-   s->last_buf_full = 0;\n-   s->busy_time = 0;\n-\n-#if FATTREE_HELLO\n-   printf(\"I am terminal %d (%llu), connected to switch %d\\n\", s->terminal_id,\n-       LLU(lp->gid), s->switch_id);\n+#if FATTREE_DEBUG\n+   printf(\"I am terminal %d (%llu), connected to switch %d in rail id %d\\n\", s->terminal_id,\n+       LLU(lp->gid), s->switch_id, s->rail_id);\n #endif\n \n    rc_stack_create(&s->st);\n \n-   s->vc_occupancy = 0;\n-   s->terminal_msgs[0] = NULL;\n-   s->terminal_msgs_tail[0] = NULL;\n-   s->terminal_length = 0;\n-   s->in_send_loop = 0;\n-   s->issueIdle = 0;\n-\n    s->rank_tbl = NULL;\n    //if(!s->rank_tbl)\n    //  tw_error(TW_LOC, \"\\n Hash table not initialized! \");\n \n-   s->params->num_terminals = codes_mapping_get_lp_count(lp_group_name, 0,\n-      LP_CONFIG_NM, s->anno, 0);\n    /* dump partial topology into DOT format\n     * skip term2sw link part, because we are missing the remote switch port\n     * in this stage of the code\n     */\n-   if(!dot_file)\n+   if(!dot_file && !s->rail_id)\n      dot_write_open_file(&dot_file);\n    dot_write_term_info(s, dot_file);\n \n    /* ensure the DOT file is out before reading it with external tools */\n-   if(dot_file)\n+   if(dot_file && !s->rail_id)\n      fflush(dot_file);\n \n    return;\n@@ -992,14 +1068,11 @@ void switch_init(switch_state * r, tw_lp * lp)\n {\n \n   char anno[MAX_NAME_LENGTH];\n-  int num_terminals = -1;\n \n   if(def_gname_set == 0) {\n     def_gname_set = 1;\n     codes_mapping_get_lp_info(0, def_group_name, &mapping_grp_id, NULL,\n         &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-    num_terminals = codes_mapping_get_lp_count(def_group_name, 0,\n-      LP_CONFIG_NM, anno, 0);\n   }\n \n   codes_mapping_get_lp_info(lp->gid, lp_group_name, &mapping_grp_id, NULL,\n@@ -1016,29 +1089,28 @@ void switch_init(switch_state * r, tw_lp * lp)\n \n   // shorthand\n   fattree_param *p = r->params;\n-  if(mapping_offset == p->num_levels - 1) {\n-    if(mapping_rep_id >= p->num_switches[mapping_offset]) {\n-      r->unused = 1;\n-      return;\n-    }\n+  if(mapping_rep_id >= p->num_switches[mapping_offset % p->num_levels]) {\n+    r->unused = 1;\n+    return;\n   }\n \n   r->unused = 0;\n \n-  r->switch_id = mapping_rep_id + mapping_offset * p->num_switches[0];\n-\n-  if(num_terminals != -1) {\n-    p->num_terminals = num_terminals;\n+  if((mapping_offset % p->num_levels) == 0) {\n+    r->switch_id = mapping_rep_id;\n+  } else if((mapping_offset % p->num_levels) ==  1) {\n+    r->switch_id = mapping_rep_id + p->num_switches[0];\n+  } else {\n+    r->switch_id = mapping_rep_id + p->num_switches[0] + p->num_switches[1];\n   }\n+  r->rail_id = mapping_offset / p->num_levels;\n \n-  r->switch_level = mapping_offset;\n+  r->switch_level = mapping_offset % p->num_levels;\n \n   r->radix = p->switch_radix[r->switch_level];\n \n   r->next_output_available_time = (tw_stime*) malloc (r->radix *\n       sizeof(tw_stime));\n-  r->next_credit_available_time = (tw_stime*) malloc (r->radix *\n-      sizeof(tw_stime));\n   r->vc_occupancy = (int*) malloc (r->radix * sizeof(int));\n   r->in_send_loop = (int*) malloc (r->radix * sizeof(int));\n   r->link_traffic = (int64_t*) malloc (r->radix * sizeof(int64_t));\n@@ -1067,7 +1139,6 @@ void switch_init(switch_state * r, tw_lp * lp)\n     r->busy_time[i] = 0.0;\n     r->busy_time_sample[i] = 0.0;\n     r->next_output_available_time[i] = 0;\n-    r->next_credit_available_time[i] = 0;\n     r->vc_occupancy[i] = 0;\n     r->in_send_loop[i] = 0;\n     r->link_traffic[i] = 0;\n@@ -1079,9 +1150,9 @@ void switch_init(switch_state * r, tw_lp * lp)\n   }\n \n   /* dump partial topology info into DOT format (switch radix, guid, ...) */\n-  if(!dot_file)\n+  if(!dot_file && !r->rail_id)\n     dot_write_open_file(&dot_file);\n-  dot_write_switch_info(r, lp->gid, dot_file);\n+  dot_write_switch_info(r, dot_file);\n \n #if FATTREE_CONNECTIONS || FATTREE_DEBUG\n     tw_lpid next_switch_lid;\n@@ -1092,228 +1163,184 @@ void switch_init(switch_state * r, tw_lp * lp)\n   //set lps connected to each port\n   r->num_cons = 0;\n   r->num_lcons = 0;\n-#if FATTREE_HELLO\n-  printf(\"I am switch %d (%llu), level %d, radix %d\\n\", r->switch_id,\n-    LLU(lp->gid), r->switch_level, r->radix);\n+#if FATTREE_DEBUG\n+  printf(\"I am switch %d (%llu), level %d, radix %d, rail id %d\\n\", r->switch_id,\n+    LLU(lp->gid), r->switch_level, r->radix, r->rail_id);\n #endif\n   //if at level 0, first half ports go to terminals\n   if(r->switch_level == 0) {\n-    int start_terminal = r->switch_id * (p->switch_radix[0] / 2);\n-    int end_terminal = start_terminal + (p->switch_radix[0] / 2);\n+    int term_rails, term_railid;\n+    if(p->ft_type != 2) {\n+      term_rails = p->num_rails;\n+      term_railid = r->rail_id;\n+    } else {\n+      term_rails = 1;\n+      term_railid = 0;\n+    }\n+    int start_terminal = r->switch_id * p->l0_term_size;\n+    int end_terminal = start_terminal + p->l0_term_size;\n     for(int term = start_terminal; term < end_terminal; term++) {\n       tw_lpid nextTerm;\n-      int rep = term / (p->switch_radix[0] / 2);\n-      int off = term % (p->switch_radix[0] / 2);\n+      int rep = term / p->l0_term_size;\n+      int off = (term % p->l0_term_size) * term_rails + term_railid;\n       codes_mapping_get_lp_id(def_group_name, LP_CONFIG_NM, NULL, 1,\n           rep, off, &nextTerm);\n       r->port_connections[r->num_cons++] = nextTerm;\n #if FATTREE_CONNECTIONS\n-\t  written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(codes_mapping_get_lp_relative_id(nextTerm,0,0)));\n+\t    written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(codes_mapping_get_lp_relative_id(nextTerm,0,0)/term_rails));\n #endif\n       r->num_lcons++;\n #if FATTREE_DEBUG\n-      printf(\"L0->term I am switch %d, connect to terminal %d (%llu) at port %d yes collecting\\n\",\n-          r->switch_id, term, LLU(nextTerm), r->num_cons - 1);\n+      printf(\"L0->term I am switch %d, connect to terminal %d (%llu) at port %d, rail id %d yes collecting\\n\",\n+          r->switch_id, term, LLU(nextTerm), r->num_cons - 1, r->rail_id);\n #endif\n       /* write sw2term links and (reverse link, too) into DOT file */\n-      dot_write_sw2term_link(r->switch_level, lp->gid, r->num_cons - 1, term, 1, dot_file);\n+      if(!r->rail_id) {\n+        dot_write_sw2term_link(r->switch_level, r->switch_id, r->num_cons - 1, term, 1, dot_file);\n+      }\n     }\n     r->start_lneigh = start_terminal;\n     r->end_lneigh = end_terminal;\n     r->con_per_lneigh = 1;\n-    assert(r->num_lcons == (r->radix / 2));\n+    assert(r->num_lcons == p->l0_term_size);\n     int l1_set;\n     if(p->num_levels == 2) {\n       l1_set = 0;\n       r->con_per_uneigh = 2;\n     } else {\n-      l1_set = r->switch_id / p->l1_set_size;\n+      l1_set = r->switch_id / p->l0_set_size;\n       r->con_per_uneigh = 1;\n     }\n     int l1_base = l1_set * p->l1_set_size;\n     r->start_uneigh = p->num_switches[0] + l1_base;\n     for(int l1 = 0; l1 < p->l1_set_size; l1++) {\n       tw_lpid nextTerm;\n+      assert(l1_base < p->num_switches[1]);\n       codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-          l1_base, 1, &nextTerm);\n+          l1_base, 1 + r->rail_id * p->num_levels, &nextTerm);\n       for(int con = 0; con < r->con_per_uneigh; con++) {\n         r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n+#if FATTREE_CONNECTIONS\n         codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n             &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-        next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n-\t    written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n+        next_switch_lid = mapping_rep_id +  p->num_switches[0];\n+\t      written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n #endif\n #if FATTREE_DEBUG\n-    printf(\"L0->L1 I am switch %d, connect to upper switch %d L1 (%llu) rel_id:%llu at port %d yes collecting\\n\",\n-          r->switch_id, l1_base, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n+    printf(\"L0->L1 I am switch %d, connect to upper switch %d L1 (%llu) rel_id:%llu at port %d, rail id %d yes collecting\\n\",\n+          r->switch_id, l1_base, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1, r->rail_id);\n #endif\n         /* write all inter switch links to DOT file (initialized before) */\n-        dot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-              r->switch_level + 1, nextTerm, -1, dot_file);\n+        if(!r->rail_id) {\n+          dot_write_sw2sw_link(r->switch_level, r->switch_id, r->num_cons - 1,\n+              r->switch_level + 1, p->num_switches[0] + l1_base, -1, dot_file);\n+        }\n       }\n       l1_base++;\n     }\n   } else if (r->switch_level == 1) {\n-    int l0_set_size, l0_base;\n+    int l0_base;\n     if(p->num_levels == 2) {\n-      l0_set_size = p->num_switches[0];\n       l0_base = 0;\n       r->start_lneigh = 0;\n       r->end_lneigh = p->num_switches[0];\n       r->con_per_lneigh = 2;\n     } else {\n-      l0_set_size = p->l1_set_size;\n       l0_base = ((r->switch_id - p->num_switches[0]) / p->l1_set_size) *\n-        l0_set_size;\n+        p->l0_set_size;\n       r->start_lneigh = l0_base;\n-      r->end_lneigh = l0_base + l0_set_size;\n+      r->end_lneigh = l0_base + p->l0_set_size;\n       r->con_per_lneigh = 1;\n     }\n-    for(int l0 = 0; l0 < l0_set_size; l0++) {\n+    for(int l0 = 0; l0 < p->l0_set_size; l0++) {\n       tw_lpid nextTerm;\n       codes_mapping_get_lp_id(def_group_name, \"fattree_switch\", NULL, 1,\n-          l0_base, 0, &nextTerm);\n+          l0_base, 0 + r->rail_id * p->num_levels, &nextTerm);\n       for(int con = 0; con < r->con_per_lneigh; con++) {\n         r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n+#if FATTREE_CONNECTIONS\n         codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n             &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-        next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n+        next_switch_lid = mapping_rep_id;\n         written_2 += sprintf(r->output_buf2 + written_2, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n #endif\n         r->num_lcons++;\n #if FATTREE_DEBUG\n-        printf(\"L1->L0 I am switch %d, connect to switch %d L0 (%llu) rel_id:%llu at port %d not collecting\\n\",\n-            r->switch_id, l0_base, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n+        printf(\"L1->L0 I am switch %d, connect to switch %d L0 (%llu) rel_id:%llu at port %d, rail id %d not collecting\\n\",\n+            r->switch_id, l0_base, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1, r->rail_id);\n #endif\n         /* write all inter switch links to DOT file (initialized before) */\n-        dot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-              r->switch_level - 1, nextTerm, -1, dot_file);\n+        if(!r->rail_id) {\n+          dot_write_sw2sw_link(r->switch_level, r->switch_id, r->num_cons - 1,\n+              r->switch_level - 1, l0_base, -1, dot_file);\n+        }\n       }\n       l0_base++;\n     }\n     if(p->num_levels == 3) {\n-      if(p->ft_type == 0) {\n-        /*for(int rep=0;rep<p->link_repetitions;rep++)*/{\n-            int rep = 0;\n-            int l2 = ((r->switch_id - p->num_switches[0]) % p->l1_set_size + rep*p->l1_set_size);\n-            /* not true anymore */\n-            r->start_uneigh = p->num_switches[0] + l2;\n-            r->con_per_uneigh = p->link_repetitions;\n-            printf(\"link_repetitions:%d rep:%d l2:%d\\n\",p->link_repetitions,rep,l2);\n-            for(; l2 < p->num_switches[2]; l2 += p->l1_set_size) {\n-              tw_lpid nextTerm;\n-              codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-                      l2, 2, &nextTerm);\n-              for(int con = 0; con < r->con_per_uneigh; con++) {\n-                r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n-                codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n-                    &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-                next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n-                written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n-#endif\n-#if FATTREE_DEBUG\n-                printf(\"L1->L2:t=0 I am switch %d, connect to upper switch %d L2 (%llu) rel_id:%llu at port %d yes collecting\\n\",\n-                    r->switch_id, l2+rep*p->l1_set_size, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n-#endif\n-\t\t\t\t/* write all inter switch links to DOT file (initialized before) */\n-            \tdot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-                  r->switch_level + 1, nextTerm, -1, dot_file);\n-              }\n-            }\n-        }\n-      } else {\n-        int l2 = ((r->switch_id - p->num_switches[0]) % p->l1_set_size);\n-        /* not true anymore */\n-        r->start_uneigh = p->num_switches[0] + l2;\n-        r->con_per_uneigh = 2;\n-        for(; l2 < p->num_switches[2]; l2 += p->l1_set_size) {\n-          tw_lpid nextTerm;\n-          codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-              l2, 2, &nextTerm);\n-          for(int con = 0; con < r->con_per_uneigh; con++) {\n-            r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n-            codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n-                &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-            next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n-            written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n-#endif\n-#if FATTREE_DEBUG\n-            printf(\"L1->L2:t!=0 I am switch %d, connect to upper switch %d L2 (%llu) rel_id:%llu at port %d yes collecting\\n\",\n-                r->switch_id, l2, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n-#endif\n-            /* write all inter switch links to DOT file (initialized before) */\n-            dot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-                  r->switch_level + 1, nextTerm, -1, dot_file);\n-          }\n-        }\n-      }\n-    }\n-  } else {\n-    if(p->ft_type == 0) {\n-      r->con_per_lneigh = p->link_repetitions;\n-      /* not true anymore */\n-      r->start_lneigh = p->num_switches[0];\n-      r->end_lneigh = r->start_lneigh + p->num_switches[1];\n-      int l1 = (r->switch_id - p->num_switches[0] - p->num_switches[1]) % p->l1_set_size;\n-      for(; l1 < p->num_switches[1]; l1 += p->l1_set_size) {\n+      int rep = p->link_repetitions;\n+      int l2 = ((r->switch_id - p->num_switches[0]) % p->l1_set_size)/rep * p->Ns;\n+      r->con_per_uneigh = 1;\n+      for(int off = 0; off < p->Ns; off++) {\n         tw_lpid nextTerm;\n+        assert(l2 + off < p->num_switches[2]);\n         codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-            l1, 1, &nextTerm);\n-        for(int con = 0; con < r->con_per_lneigh; con++) {\n+            l2 + off, 2 + r->rail_id * p->num_levels, &nextTerm);\n+        for(int con = 0; con < r->con_per_uneigh; con++) {\n           r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n+#if FATTREE_CONNECTIONS\n           codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n               &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-          next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n-\t      written_2 += sprintf(r->output_buf2 + written_2, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n+          next_switch_lid = mapping_rep_id +  p->num_switches[0] + p->num_switches[1];\n+          written += sprintf(r->output_buf + written, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n #endif\n-          r->num_lcons++;\n #if FATTREE_DEBUG\n-          printf(\"L2->L1:t=0 I am switch %d, connect to  switch %d L1 (%llu) rel_id:%llu at port %d not collecting\\n\",\n-                  r->switch_id, l1, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n+          printf(\"L1->L2:t=0 I am switch %d, connect to upper switch %d L2 (%llu) rel_id:%llu at port %d, rail id %d yes collecting\\n\",\n+              r->switch_id, l2+off, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1, r->rail_id);\n #endif\n           /* write all inter switch links to DOT file (initialized before) */\n-          dot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-                r->switch_level - 1, nextTerm, -1, dot_file);\n+          if(!r->rail_id) {\n+            dot_write_sw2sw_link(r->switch_level, r->switch_id, r->num_cons - 1,\n+                r->switch_level + 1, p->num_switches[0] + p->num_switches[1] + l2 + off, -1, dot_file);\n+          }\n         }\n       }\n-    } else {\n-      r->con_per_lneigh = 2;\n-      /* not true anymore */\n-      r->start_lneigh = p->num_switches[0];\n-      r->end_lneigh = r->start_lneigh + p->num_switches[1];\n-      int l1 = (r->switch_id - p->num_switches[0] - p->num_switches[1]) % p->l1_set_size;\n-      for(; l1 < p->num_switches[1]; l1 += p->l1_set_size) {\n+    }\n+  } else {\n+    int rep = p->link_repetitions;\n+    r->con_per_lneigh = 1;\n+    int l1 = (r->switch_id - p->num_switches[0] - p->num_switches[1])/p->Ns * rep;\n+    for(; l1 < p->num_switches[1]; l1 += p->l1_set_size) {\n+      for(int off = 0; off < rep; off++) {\n         tw_lpid nextTerm;\n+        assert(l1 + off < p->num_switches[1]);\n         codes_mapping_get_lp_id(lp_group_name, \"fattree_switch\", NULL, 1,\n-            l1, 1, &nextTerm);\n+            l1 + off, 1 + r->rail_id * p->num_levels, &nextTerm);\n         for(int con = 0; con < r->con_per_lneigh; con++) {\n           r->port_connections[r->num_cons++] = nextTerm;\n-#if FATTREE_CONNECTIONS || FATTREE_DEBUG\n+#if FATTREE_CONNECTIONS\n           codes_mapping_get_lp_info(nextTerm, lp_group_name, &mapping_grp_id, NULL,\n               &mapping_type_id, anno, &mapping_rep_id, &mapping_offset);\n-          next_switch_lid = mapping_rep_id + mapping_offset * p->num_switches[0];\n-\t      written_2 += sprintf(r->output_buf2 + written_2, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n+          next_switch_lid = mapping_rep_id + p->num_switches[0];\n+          written_2 += sprintf(r->output_buf2 + written_2, \"%u, %llu, \", r->switch_id+p->num_terminals,LLU(next_switch_lid)+p->num_terminals);\n #endif\n           r->num_lcons++;\n #if FATTREE_DEBUG\n-          printf(\"L2->L1:t!=0 I am switch %d, connect to  switch %d L1 (%llu) rel_id:%llu at port %d not collecting\\n\",\n-              r->switch_id, l1, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1);\n+          printf(\"L2->L1:t=0 I am switch %d, connect to  switch %d L1 (%llu) rel_id:%llu at port %d, rail id %d not collecting\\n\",\n+              r->switch_id, l1 + rep, LLU(nextTerm), LLU(next_switch_lid), r->num_cons - 1, r->rail_id);\n #endif\n           /* write all inter switch links to DOT file (initialized before) */\n-          dot_write_sw2sw_link(r->switch_level, lp->gid, r->num_cons - 1,\n-                r->switch_level - 1, nextTerm, -1, dot_file);\n+          if(!r->rail_id) {\n+            dot_write_sw2sw_link(r->switch_level, r->switch_id, r->num_cons - 1,\n+                r->switch_level - 1, p->num_switches[0] + l1 + off, -1, dot_file);\n+          }\n         }\n       }\n     }\n   }\n \n   /* ensure the DOT file is out before reading it with external tools */\n-  if(dot_file)\n+  if(dot_file && !r->rail_id)\n     fflush(dot_file);\n \n #if FATTREE_CONNECTIONS\n@@ -1480,6 +1507,7 @@ static tw_stime fattree_packet_event(\n   msg->local_event_size_bytes = 0;\n   msg->type = T_GENERATE;\n   msg->dest_terminal_id = req->dest_mn_lp;\n+  msg->rail_id = req->queue_offset;\n   msg->message_id = req->msg_id;\n   msg->is_pull = req->is_pull;\n   msg->pull_size = req->pull_size;\n@@ -1537,23 +1565,23 @@ void ft_packet_generate_rc(ft_terminal_state * s, tw_bf * bf, fattree_message * \n     int i;\n     for(i = 0; i < num_chunks; i++) {\n \tdelete_fattree_message_list(return_tail(s->terminal_msgs,\n-\t    s->terminal_msgs_tail, 0));\n-\ts->terminal_length -= s->params->chunk_size;\n+\t    s->terminal_msgs_tail, msg->saved_vc));\n+\ts->terminal_length[msg->saved_vc] -= s->params->chunk_size;\n     }\n     if(bf->c11) {\n-\ts->issueIdle = 0;\n-\ts->last_buf_full = msg->saved_busy_time;\n+\ts->issueIdle[msg->rail_id] = 0;\n+\ts->last_buf_full[msg->rail_id] = msg->saved_busy_time;\n     }\n     if(bf->c5) {\n \tcodes_local_latency_reverse(lp);\n-\ts->in_send_loop = 0;\n+\ts->in_send_loop[msg->saved_vc] = 0;\n     }\n \n     struct mn_stats* stat;\n     stat = model_net_find_stats(msg->category, s->fattree_stats_array);\n     stat->send_count--;\n     stat->send_bytes -= msg->packet_size;\n-    stat->send_time -= (1/s->params->cn_bandwidth) * msg->packet_size;\n+    stat->send_time -= (1/s->params->link_bandwidth) * msg->packet_size;\n }\n \n /* generates packet at the current fattree compute node */\n@@ -1581,6 +1609,21 @@ void ft_packet_generate(ft_terminal_state * s, tw_bf * bf, fattree_message * msg\n \n   msg->packet_ID = lp->gid + g_tw_nlp * s->packet_counter;\n \n+  int target_queue = msg->rail_id;\n+  if(s->params->rail_select == RAIL_ADAPTIVE && \n+     (int)msg->total_size > s->params->rail_size_limit) {\n+    int curr_buffer = s->terminal_length[target_queue];\n+    for(int i = 1; i < s->params->ports_per_nic; i++) {\n+      int next = (msg->rail_id + i) % s->params->ports_per_nic;\n+      if(s->terminal_length[next] < curr_buffer) {\n+        curr_buffer =  s->terminal_length[next];\n+        target_queue = next;\n+      }\n+    }\n+  }\n+\n+  msg->saved_vc = target_queue;\n+\n   for(uint64_t i = 0; i < num_chunks; i++)\n   {\n     fattree_message_list * cur_chunk = (fattree_message_list *)malloc(\n@@ -1606,28 +1649,29 @@ void ft_packet_generate(ft_terminal_state * s, tw_bf * bf, fattree_message * msg\n     cur_chunk->msg.chunk_id = i;\n     cur_chunk->msg.origin_switch_id = s->switch_id;\n     append_to_fattree_message_list(s->terminal_msgs, s->terminal_msgs_tail,\n-      0, cur_chunk);\n-    s->terminal_length += s->params->chunk_size;\n+      target_queue, cur_chunk);\n+    s->terminal_length[target_queue] += s->params->chunk_size;\n   }\n \n-  if(s->terminal_length < 2 * s->params->cn_vc_size) {\n-    model_net_method_idle_event(nic_ts, 0, lp);\n+  if(s->terminal_length[target_queue] < s->params->cn_vc_size) {\n+    model_net_method_idle_event2(nic_ts, 0, msg->rail_id, lp);\n   } else {\n     bf->c11 = 1;\n-    s->issueIdle = 1;\n-    msg->saved_busy_time = s->last_buf_full;\n-    s->last_buf_full = tw_now(lp);\n+    s->issueIdle[msg->rail_id] = 1;\n+    msg->saved_busy_time = s->last_buf_full[msg->rail_id];\n+    s->last_buf_full[msg->rail_id] = tw_now(lp);\n   }\n \n-  if(s->in_send_loop == 0) {\n+  if(s->in_send_loop[target_queue] == 0) {\n     fattree_message *m;\n     bf->c5 = 1;\n     ts = codes_local_latency(lp);\n     tw_event* e = model_net_method_event_new(lp->gid, ts, lp, FATTREE,\n       (void**)&m, NULL);\n     m->type = T_SEND;\n+    m->vc_index = target_queue;\n     m->magic = fattree_terminal_magic_num;\n-    s->in_send_loop = 1;\n+    s->in_send_loop[target_queue] = 1;\n     tw_event_send(e);\n   }\n \n@@ -1637,7 +1681,7 @@ void ft_packet_generate(ft_terminal_state * s, tw_bf * bf, fattree_message * msg\n   stat = model_net_find_stats(msg->category, s->fattree_stats_array);\n   stat->send_count++;\n   stat->send_bytes += msg->packet_size;\n-  stat->send_time += (1/p->cn_bandwidth) * msg->packet_size;\n+  stat->send_time += (1/p->link_bandwidth) * msg->packet_size;\n   if(stat->max_event_size < total_event_size)\n     stat->max_event_size = total_event_size;\n \n@@ -1650,24 +1694,24 @@ void ft_packet_send_rc(ft_terminal_state * s, tw_bf *bf, fattree_message * msg, \n     t_send_r++;\n #endif\n     if(bf->c1) {\n-      s->in_send_loop = 1;\n-      s->last_buf_full = msg->saved_busy_time;\n+      s->in_send_loop[msg->vc_index] = 1;\n+      s->last_buf_full[msg->vc_index] = msg->saved_busy_time;\n       return;\n     }\n \n     tw_rand_reverse_unif(lp->rng);\n-    s->terminal_available_time = msg->saved_available_time;\n+    s->terminal_available_time[msg->vc_index] = msg->saved_available_time;\n     if(bf->c2) {\n       codes_local_latency_reverse(lp);\n     }\n     s->packet_counter--;\n-    s->vc_occupancy -= s->params->chunk_size;\n+    s->vc_occupancy[msg->vc_index] -= s->params->chunk_size;\n \n     fattree_message_list* cur_entry = rc_stack_pop(s->st);\n \n     prepend_to_fattree_message_list(s->terminal_msgs,\n-        s->terminal_msgs_tail, 0, cur_entry);\n-    s->terminal_length += s->params->chunk_size;\n+        s->terminal_msgs_tail, msg->vc_index, cur_entry);\n+    s->terminal_length[msg->vc_index] += s->params->chunk_size;\n #if DEBUG_RC\n     if(s->terminal_id == 0)\n        printf(\"time:%lf terminal_length:%d \\n\",tw_now(lp),s->terminal_length);\n@@ -1677,11 +1721,11 @@ void ft_packet_send_rc(ft_terminal_state * s, tw_bf *bf, fattree_message * msg, \n       tw_rand_reverse_unif(lp->rng);\n     }\n     if(bf->c4) {\n-      s->in_send_loop = 1;\n+      s->in_send_loop[msg->vc_index] = 1;\n     }\n     if(bf->c5) {\n       codes_local_latency_reverse(lp);\n-      s->issueIdle = 1;\n+      s->issueIdle[msg->vc_index] = 1;\n     }\n }\n /* sends the packet from the compute node to the attached switch */\n@@ -1698,15 +1742,14 @@ void ft_packet_send(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   tw_event *e;\n   fattree_message *m;\n \n-  fattree_message_list* cur_entry = s->terminal_msgs[0];\n+  fattree_message_list* cur_entry = s->terminal_msgs[msg->vc_index];\n \n-  if(s->vc_occupancy + s->params->chunk_size > s->params->cn_vc_size ||\n+  if(s->vc_occupancy[msg->vc_index] + s->params->chunk_size > s->params->cn_vc_size ||\n     cur_entry == NULL) {\n     bf->c1 = 1;\n-    s->in_send_loop = 0;\n-\n-    msg->saved_busy_time = s->last_buf_full;\n-    s->last_buf_full = tw_now(lp);\n+    s->in_send_loop[msg->vc_index] = 0;\n+    msg->saved_busy_time = s->last_buf_full[msg->vc_index];\n+    s->last_buf_full[msg->vc_index] = tw_now(lp);\n     return;\n   }\n   \n@@ -1719,20 +1762,20 @@ void ft_packet_send(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n \n   ts = g_tw_lookahead + + g_tw_lookahead * tw_rand_unif(lp->rng);\n   if((cur_entry->msg.packet_size % s->params->chunk_size) && (cur_entry->msg.chunk_id == num_chunks - 1)) {\n-    ts += s->params->cn_delay * (cur_entry->msg.packet_size % s->params->chunk_size);\n+    ts += s->params->head_delay * (cur_entry->msg.packet_size % s->params->chunk_size);\n   } else {\n     bf->c12 = 1;\n-    ts += s->params->cn_delay * s->params->chunk_size;\n+    ts += s->params->head_delay * s->params->chunk_size;\n   }\n \n-  msg->saved_available_time = s->terminal_available_time;\n-  s->terminal_available_time = maxd(s->terminal_available_time, tw_now(lp));\n-  s->terminal_available_time += ts;\n+  msg->saved_available_time = s->terminal_available_time[msg->vc_index];\n+  s->terminal_available_time[msg->vc_index] = maxd(s->terminal_available_time[msg->vc_index], tw_now(lp));\n+  s->terminal_available_time[msg->vc_index] += ts;\n \n   // we are sending an event to the switch, so no method_event here\n-  ts = s->terminal_available_time - tw_now(lp);\n+  ts = s->terminal_available_time[msg->vc_index] - tw_now(lp);\n \n-  e = tw_event_new(s->switch_lp, ts, lp);\n+  e = tw_event_new(s->switch_lp[msg->vc_index], ts, lp);\n   m = tw_event_data(e);\n   memcpy(m, &cur_entry->msg, sizeof(fattree_message));\n   if (m->remote_event_size_bytes){\n@@ -1743,7 +1786,8 @@ void ft_packet_send(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   m->type = S_ARRIVE;\n   m->src_terminal_id = lp->gid;\n   m->intm_id = s->terminal_id;\n-  m->vc_index = 0;\n+  m->rail_id = msg->vc_index;\n+  m->vc_index = msg->vc_index;\n   m->vc_off = 0; //we only have one connection to the terminal NIC\n   m->local_event_size_bytes = 0;\n   m->last_hop = TERMINAL;\n@@ -1765,35 +1809,36 @@ void ft_packet_send(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   }\n \n   s->packet_counter++;\n-  s->vc_occupancy += s->params->chunk_size;\n-  cur_entry = return_head(s->terminal_msgs, s->terminal_msgs_tail, 0);\n-  rc_stack_push(lp, cur_entry, free, s->st);\n-  s->terminal_length -= s->params->chunk_size;\n+  s->vc_occupancy[msg->vc_index] += s->params->chunk_size;\n+  cur_entry = return_head(s->terminal_msgs, s->terminal_msgs_tail, msg->vc_index);\n+  rc_stack_push(lp, cur_entry, (void*)delete_fattree_message_list, s->st);\n+  s->terminal_length[msg->vc_index] -= s->params->chunk_size;\n \n //  if(s->terminal_id == 1)\n //    printf(\"send time:%5.6lf lp_id:%3llu terminal_length:%5d \\n\",tw_now(lp),LLU(lp->gid),s->terminal_length);\n \n-  cur_entry = s->terminal_msgs[0];\n+  cur_entry = s->terminal_msgs[msg->vc_index];\n \n   if(cur_entry != NULL &&\n-    s->vc_occupancy + s->params->chunk_size <= s->params->cn_vc_size) {\n+    s->vc_occupancy[msg->vc_index] + s->params->chunk_size <= s->params->cn_vc_size) {\n     bf->c3 = 1;\n     fattree_message *m_new;\n     ts = ts + g_tw_lookahead * tw_rand_unif(lp->rng);\n     e = model_net_method_event_new(lp->gid, ts, lp, FATTREE,\n       (void**)&m_new, NULL);\n     m_new->type = T_SEND;\n+    m_new->vc_index = msg->vc_index;\n     m_new->magic = fattree_terminal_magic_num;\n     tw_event_send(e);\n   } else {\n     bf->c4 = 1;\n-    s->in_send_loop = 0;\n+    s->in_send_loop[msg->vc_index] = 0;\n   }\n \n-  if(s->issueIdle) {\n+  if(s->issueIdle[msg->vc_index]) {\n     bf->c5 = 1;\n-    s->issueIdle = 0;\n-    model_net_method_idle_event(codes_local_latency(lp), 0, lp);\n+    s->issueIdle[msg->vc_index] = 0;\n+    model_net_method_idle_event2(codes_local_latency(lp), 0, msg->vc_index, lp);\n   }\n \n   return;\n@@ -1808,7 +1853,9 @@ void switch_packet_receive_rc(switch_state * s,\n \ts_arrive_r++;\n #endif\n     int output_port = msg->saved_vc;\n-    tw_rand_reverse_unif(lp->rng);\n+    if(s->params->routing != STATIC) {\n+      tw_rand_reverse_unif(lp->rng);\n+    }\n     if(bf->c1)\n     {\n         tw_rand_reverse_unif(lp->rng);\n@@ -1856,13 +1903,6 @@ void switch_packet_receive( switch_state * s, tw_bf * bf,\n     to_terminal = 1;\n   }\n \n-  int dest_term_local_id = codes_mapping_get_lp_relative_id(msg->dest_terminal_id, 0, 0);\n-\n-  if(msg->packet_ID == LLU(TRACK_PKT))\n-    printf(\"\\n Packet %llu chunk %llu arrived at switch %d switch_gid %llu dest_terminal_id %llu dest_term_local_id %llu final_dest_gid %llu output_port %d to_terminal %d\\n\",\n-        msg->packet_ID, LLU(msg->chunk_id), s->switch_id, LLU(lp->gid), LLU(msg->dest_terminal_id), LLU(dest_term_local_id), LLU(msg->final_dest_gid),\n-        output_port, to_terminal);\n-\n   fattree_message_list * cur_chunk = (fattree_message_list *)malloc(\n       sizeof(fattree_message_list));\n   init_fattree_message_list(cur_chunk, msg);\n@@ -1983,7 +2023,7 @@ void switch_packet_send( switch_state * s, tw_bf * bf, fattree_message * msg,\n   // dest can be a switch or a terminal, so we must check\n   if(s->switch_level == 0 && output_port < s->num_lcons) {\n     to_terminal = 1;\n-    delay = s->params->cn_delay;\n+    delay = s->params->head_delay;\n   }\n \n   uint64_t num_chunks = cur_entry->msg.packet_size / s->params->chunk_size;\n@@ -2049,7 +2089,7 @@ void switch_packet_send( switch_state * s, tw_bf * bf, fattree_message * msg,\n \n   cur_entry = return_head(s->pending_msgs, s->pending_msgs_tail,\n     output_port);\n-  rc_stack_push(lp, cur_entry, free, s->st);\n+  rc_stack_push(lp, cur_entry, (void*)delete_fattree_message_list, s->st);\n \n   s->next_output_available_time[output_port] -= s->params->router_delay;\n   ts -= s->params->router_delay;\n@@ -2134,16 +2174,16 @@ void ft_terminal_buf_update_rc(ft_terminal_state * s, tw_bf * bf, fattree_messag\n #if DEBUG_RC\n     t_buffer_r++;\n #endif\n-    s->vc_occupancy += s->params->chunk_size;\n+    s->vc_occupancy[msg->vc_index] += s->params->chunk_size;\n     codes_local_latency_reverse(lp);\n     if(bf->c3)\n     {\n-      s->busy_time = msg->saved_total_time;\n-      s->last_buf_full = msg->saved_busy_time;\n+      s->busy_time[msg->vc_index] = msg->saved_total_time;\n+      s->last_buf_full[msg->vc_index] = msg->saved_busy_time;\n       s->busy_time_sample = msg->saved_sample_time;\n     }\n     if(bf->c1) {\n-      s->in_send_loop = 0;\n+      s->in_send_loop[msg->vc_index] = 0;\n     }\n }\n /* update the compute node-switch channel buffer */\n@@ -2153,29 +2193,30 @@ void ft_terminal_buf_update(ft_terminal_state * s, tw_bf * bf,\n   bf->c1 = 0;\n \n   tw_stime ts = codes_local_latency(lp);\n-  s->vc_occupancy -= s->params->chunk_size;\n+  s->vc_occupancy[msg->vc_index] -= s->params->chunk_size;\n \n   /* Update the terminal buffer time */\n-  if(s->last_buf_full > 0)\n+  if(s->last_buf_full[msg->vc_index] > 0)\n   {\n     bf->c3 = 1;\n-    msg->saved_total_time = s->busy_time;\n-    msg->saved_busy_time = s->last_buf_full;\n+    msg->saved_total_time = s->busy_time[msg->vc_index];\n+    msg->saved_busy_time = s->last_buf_full[msg->vc_index];\n     msg->saved_sample_time = s->busy_time_sample;\n \n-    s->busy_time += (tw_now(lp) - s->last_buf_full);\n-    s->busy_time_sample += (tw_now(lp) - s->last_buf_full);\n-    s->last_buf_full = 0.0;\n+    s->busy_time[msg->vc_index] += (tw_now(lp) - s->last_buf_full[msg->vc_index]);\n+    s->busy_time_sample += (tw_now(lp) - s->last_buf_full[msg->vc_index]);\n+    s->last_buf_full[msg->vc_index] = 0.0;\n   }\n \n-  if(s->in_send_loop == 0 && s->terminal_msgs[0] != NULL) {\n+  if(s->in_send_loop[msg->vc_index] == 0 && s->terminal_msgs[msg->vc_index] != NULL) {\n     fattree_message *m;\n     bf->c1 = 1;\n     tw_event* e = model_net_method_event_new(lp->gid, ts, lp, FATTREE,\n         (void**)&m, NULL);\n     m->type = T_SEND;\n+    m->vc_index = msg->vc_index;\n     m->magic = fattree_terminal_magic_num;\n-    s->in_send_loop = 1;\n+    s->in_send_loop[msg->vc_index] = 1;\n     //printf(\"[%d] term buf Send to %d\\n\", lp->gid, lp->gid);\n     tw_event_send(e);\n   }\n@@ -2270,7 +2311,6 @@ void ft_send_remote_event(ft_terminal_state * s, fattree_message * msg, tw_lp * \n \n         void * tmp_ptr = model_net_method_get_edata(FATTREE, msg);\n \n-        //tw_stime ts = g_tw_lookahead + bytes_to_ns(msg->remote_event_size_bytes, (1/s->params->cn_bandwidth));\n         tw_stime ts = g_tw_lookahead + tw_rand_unif(lp->rng);\n \n         if (msg->is_pull){\n@@ -2398,7 +2438,6 @@ void ft_packet_arrive(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   //If no chunks (sending msgs as whole) then set to 1\n   if(!total_chunks)\n           total_chunks = 1;\n-  assert(lp->gid == msg->dest_terminal_id);\n \n #if DEBUG_RC\n   if(msg->packet_ID == LLU(TRACK_PKT))\n@@ -2414,7 +2453,7 @@ void ft_packet_arrive(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   ts = g_tw_lookahead + s->params->credit_delay + g_tw_lookahead * tw_rand_unif(lp->rng);\n \n   // no method_event here - message going to switch\n-  buf_e = tw_event_new(s->switch_lp, ts, lp);\n+  buf_e = tw_event_new(s->switch_lp[msg->rail_id], ts, lp);\n   buf_msg = tw_event_data(buf_e);\n   buf_msg->magic = switch_magic_num;\n   buf_msg->vc_index = msg->vc_index;\n@@ -2437,8 +2476,6 @@ void ft_packet_arrive(ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n   s->fin_chunks_sample++;\n \n    s->data_size_sample += msg->total_size;\n-  /* WE do not allow self messages through fattree */\n-  assert(lp->gid != msg->src_terminal_id);\n \n   uint64_t num_chunks = msg->packet_size / s->params->chunk_size;\n   if (msg->packet_size % s->params->chunk_size)\n@@ -2590,6 +2627,9 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n   fattree_param *p = s->params;\n \n   int dest_term_local_id = codes_mapping_get_lp_relative_id(msg->dest_terminal_id, 0, 0);\n+  if(s->params->ft_type != 2) {\n+    dest_term_local_id /= s->params->num_rails;\n+  }\n   /* either do static oblivious routing, if set up properly via LFTs */\n   if(s->params->routing == STATIC) {\n     assert(dest_term_local_id >= 0 && dest_term_local_id < p->num_terminals);\n@@ -2613,7 +2653,7 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n       end_port = s->num_cons;\n     }\n   } else if(s->switch_level == 1) {\n-    int dest_switch_id = dest_term_local_id / (p->switch_radix[0] / 2);\n+    int dest_switch_id = dest_term_local_id / p->l0_term_size;\n     //if only two level or packet going down, send to the right switch\n     if(p->num_levels == 2 || (dest_switch_id >= s->start_lneigh &&\n       dest_switch_id < s->end_lneigh)) {\n@@ -2625,13 +2665,8 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n     }\n   } else { //switch level 2\n     int dest_l1_group = dest_term_local_id / p->l1_term_size;\n-    if(s->params->ft_type == 0) {\n-      start_port = dest_l1_group * /* (p->l1_set_size/2) **/ s->con_per_lneigh;\n-      end_port = start_port +(/*(p->l1_set_size/2) **/ s->con_per_lneigh);\n-    } else {\n-      start_port = dest_l1_group * s->con_per_lneigh;\n-      end_port = start_port + s->con_per_lneigh;\n-    }\n+    start_port = dest_l1_group * s->params->link_repetitions * s->con_per_lneigh;\n+    end_port = start_port + (s->params->link_repetitions * s->con_per_lneigh);\n   }\n \n   assert(end_port > start_port);\n@@ -2659,19 +2694,6 @@ int ft_get_output_port( switch_state * s, tw_bf * bf, fattree_message * msg,\n   return outport;\n }\n \n-/* Currently incomplete. */\n-/*int get_base_port(switch_state *s, int from_term, int index) {\n-  int return_port;\n-  if(s->switch_level == 2) {\n-  } else if(from_term || index < (int)s->switch_id) {\n-    return_port = ((index - s->start_lneigh) * s->con_per_lneigh);\n-  } else {\n-    return_port = s->num_lcons;\n-    return_port += ((index - s->start_uneigh) * s->con_per_uneigh);\n-  }\n-  return return_port;\n-}*/\n-\n void ft_terminal_event( ft_terminal_state * s, tw_bf * bf, fattree_message * msg,\n \t\ttw_lp * lp ) {\n \n@@ -2721,13 +2743,13 @@ void fattree_terminal_final( ft_terminal_state * s, tw_lp * lp )\n     model_net_print_stats(lp->gid, s->fattree_stats_array);\n \n     int written = 0;\n-    if(!s->terminal_id)\n-        written = sprintf(s->output_buf, \"# Format <LP id> <Terminal ID> <Total Data Size> <Aggregate packet latency> <# Flits/Packets finished> <Avg hops> <Busy Time>\\n\");\n+    if(!s->terminal_id && !s->rail_id)\n+        written = sprintf(s->output_buf, \"# Format <LP id> <Terminal ID> <Rail ID> <Total Data Size> <Avg packet latency> <# Flits/Packets finished> <Avg hops> <Busy Time>\\n\");\n \n-    written += sprintf(s->output_buf + written, \"%llu %u %lld %lf %ld %lf %lf\\n\",\n-            LLU(lp->gid), s->terminal_id, s->total_msg_size, s->total_time,\n+    written += sprintf(s->output_buf + written, \"%llu %u %u %llu %lf %ld %lf %lf\\n\",\n+            LLU(lp->gid), s->terminal_id, s->rail_id, s->total_msg_size, s->total_time,\n             s->finished_packets, (double)s->total_hops/s->finished_chunks,\n-            s->busy_time);\n+            s->busy_time[0]);\n \n     lp_io_write(lp->gid, \"fattree-msg-stats\", written, s->output_buf);\n \n@@ -2806,53 +2828,34 @@ void fattree_switch_final(switch_state * s, tw_lp * lp)\n \n //    const fattree_param *p = s->params;\n     int written = 0;\n-    if(!s->switch_id)\n+    if(!s->switch_id && !s->rail_id)\n     {\n-        written = sprintf(s->output_buf, \"# Format <LP ID> <Level ID> <Switch ID> <Busy time per switch port(s)>\");\n+        written = sprintf(s->output_buf, \"# Format <LP ID> <Rail ID> <Level ID> <Switch ID> <Busy time per switch port(s)>\");\n         written += sprintf(s->output_buf + written, \"# Switch ports: %d\\n\",\n                 s->radix);\n     }\n-    written += sprintf(s->output_buf + written, \"\\n %llu %d %d\",\n-            LLU(lp->gid),s->switch_level,s->switch_id);\n+    written += sprintf(s->output_buf + written, \"\\n %llu %d %d %d\",\n+            LLU(lp->gid),s->rail_id,s->switch_level,s->switch_id);\n     for(int d = 0; d < s->radix; d++)\n         written += sprintf(s->output_buf + written, \" %lf\", s->busy_time[d]);\n \n     lp_io_write(lp->gid, \"fattree-switch-stats\", written, s->output_buf);\n \n     written = 0;\n-    if(!s->switch_id)\n+    if(!s->switch_id && !s->rail_id)\n     {\n-        written = sprintf(s->output_buf2, \"# Format <LP ID> <Level ID> <Switch ID> <Link traffic per switch port(s)>\");\n+        written = sprintf(s->output_buf2, \"# Format <LP ID> <Rail ID> <Level ID> <Switch ID> <Link traffic per switch port(s)>\");\n         written += sprintf(s->output_buf2 + written, \"# Switch ports: %d\",\n             s->radix);\n     }\n-    written += sprintf(s->output_buf2 + written, \"\\n %llu %d %d\",\n-        LLU(lp->gid),s->switch_level,s->switch_id);\n+    written += sprintf(s->output_buf2 + written, \"\\n %llu %d %d %d\",\n+        LLU(lp->gid),s->rail_id,s->switch_level,s->switch_id);\n \n     for(int d = 0; d < s->radix; d++)\n         written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n \n     assert(written < 4096);\n     lp_io_write(lp->gid, \"fattree-switch-traffic\", written, s->output_buf2);\n-\n-    //Original Output with Tracer\n-//    char *stats_file = getenv(\"TRACER_LINK_FILE\");\n-//  if(stats_file != NULL) {\n-    int rank;\n-    MPI_Comm_rank(MPI_COMM_CODES, &rank);\n-    char file_name[512];\n-    sprintf(file_name, \"%s.%d\", \"tracer_stats_file\", rank);\n-    FILE *fout = fopen(file_name, \"a\");\n-//    fattree_param *p = s->params;\n-    //int result = flock(fileno(fout), LOCK_EX);\n-    fprintf(fout, \"%d %d \", s->switch_id, s->switch_level);\n-    for(int d = 0; d < s->num_cons; d++) {\n-      fprintf(fout, \"%llu \", LLU(s->link_traffic[d]));\n-    }\n-    fprintf(fout, \"\\n\");\n-    //result = flock(fileno(fout), LOCK_UN);\n-    fclose(fout);\n-//  }\n }\n \n /* Update the buffer space associated with this switch LP */\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 13,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/model-net-lp.c",
                        "old_path": "src/networks/model-net/model-net-lp.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/model-net-lp.c\n+++ b/src/networks/model-net/model-net-lp.c\n@@ -27,7 +27,10 @@ static int msg_offsets[MAX_NETS];\n typedef struct model_net_base_params_s {\n     model_net_sched_cfg_params sched_params;\n     uint64_t packet_size;\n+    int num_queues;\n     int use_recv_queue;\n+    tw_stime nic_seq_delay;\n+    int node_copy_queues;\n } model_net_base_params;\n \n /* annotation-specific parameters (unannotated entry occurs at the\n@@ -38,16 +41,18 @@ static model_net_base_params     all_params[CONFIGURATION_MAX_ANNOS];\n \n static tw_stime mn_sample_interval = 0.0;\n static tw_stime mn_sample_end = 0.0;\n+static int servers_per_node_queue = -1;\n+extern tw_stime codes_cn_delay;\n \n typedef struct model_net_base_state {\n-    int net_id;\n+    int net_id, nics_per_router;\n     // whether scheduler loop is running\n-    int in_sched_send_loop, in_sched_recv_loop;\n+    int *in_sched_send_loop, in_sched_recv_loop;\n     // unique message id counter. This doesn't get decremented on RC to prevent\n     // optimistic orderings using \"stale\" ids\n     uint64_t msg_id;\n     // model-net schedulers\n-    model_net_sched *sched_send, *sched_recv;\n+    model_net_sched **sched_send, *sched_recv;\n     // parameters\n     const model_net_base_params * params;\n     // lp type and state of underlying model net method - cache here so we\n@@ -55,6 +60,8 @@ typedef struct model_net_base_state {\n     const tw_lptype *sub_type;\n     const st_model_types *sub_model_type;\n     void *sub_state;\n+    tw_stime next_available_time;\n+    tw_stime *node_copy_next_available_time;\n } model_net_base_state;\n \n \n@@ -231,6 +238,30 @@ static void base_read_config(const char * anno, model_net_base_params *p){\n             &packet_size_l);\n     packet_size = packet_size_l;\n \n+    p->num_queues = 1;\n+    ret = configuration_get_value_int(&config, \"PARAMS\", \"num_injection_queues\", anno,\n+            &p->num_queues);\n+    if(ret && !g_tw_mynode) {\n+        fprintf(stdout, \"NIC num injection port not specified, \"\n+                \"setting to %d\\n\", p->num_queues);\n+    }\n+\n+    p->nic_seq_delay = 10;\n+    ret = configuration_get_value_double(&config, \"PARAMS\", \"nic_seq_delay\", anno,\n+            &p->nic_seq_delay);\n+    if(ret && !g_tw_mynode) {\n+        fprintf(stdout, \"NIC seq delay not specified, \"\n+                \"setting to %lf\\n\", p->nic_seq_delay);\n+    }\n+\n+    p->node_copy_queues = 1;\n+    ret = configuration_get_value_int(&config, \"PARAMS\", \"node_copy_queues\", anno,\n+            &p->node_copy_queues);\n+    if(ret && !g_tw_mynode) {\n+        fprintf(stdout, \"NIC num copy queues not specified, \"\n+                \"setting to %d\\n\", p->node_copy_queues);\n+    }\n+\n     if (ret > 0){\n         int i;\n         for (i = 0; i < MAX_SCHEDS; i++){\n@@ -332,6 +363,10 @@ void model_net_base_configure(){\n \toffsetof(model_net_wrap_msg, msg.m_fat);\n     msg_offsets[LOGGP] =\n         offsetof(model_net_wrap_msg, msg.m_loggp);\n+    msg_offsets[EXPRESS_MESH] =\n+        offsetof(model_net_wrap_msg, msg.m_em);\n+    msg_offsets[EXPRESS_MESH_ROUTER] =\n+        offsetof(model_net_wrap_msg, msg.m_em);\n \n     // perform the configuration(s)\n     // This part is tricky, as we basically have to look up all annotations that\n@@ -382,14 +417,12 @@ void model_net_base_lp_init(\n         model_net_base_state * ns,\n         tw_lp * lp){\n     // obtain the underlying lp type through codes-mapping\n-    char lp_type_name[MAX_NAME_LENGTH], anno[MAX_NAME_LENGTH];\n+    char lp_type_name[MAX_NAME_LENGTH], anno[MAX_NAME_LENGTH], group[MAX_NAME_LENGTH];\n     int dummy;\n \n-    codes_mapping_get_lp_info(lp->gid, NULL, &dummy,\n+    codes_mapping_get_lp_info(lp->gid, group, &dummy,\n             lp_type_name, &dummy, anno, &dummy, &dummy);\n \n-    ns->msg_id = 0;\n-\n     // get annotation-specific parameters\n     for (int i = 0; i < num_params; i++){\n         if ((anno[0]=='\\0' && annos[i] == NULL) ||\n@@ -406,12 +439,26 @@ void model_net_base_lp_init(\n             break;\n         }\n     }\n+    \n+    ns->nics_per_router = codes_mapping_get_lp_count(group, 1,\n+            lp_type_name, NULL, 1);\n+    \n+    ns->msg_id = 0;\n+    ns->next_available_time = 0;\n+    ns->node_copy_next_available_time = (tw_stime*)malloc(ns->params->node_copy_queues * sizeof(tw_stime));\n+    for(int i = 0; i < ns->params->node_copy_queues; i++) {\n+        ns->node_copy_next_available_time[i] = 0;\n+    }\n \n-    ns->sched_send = malloc(sizeof(model_net_sched));\n+    ns->in_sched_send_loop = (int *)malloc(ns->params->num_queues * sizeof(int));\n+    ns->sched_send = (model_net_sched**)malloc(ns->params->num_queues * sizeof(model_net_sched*));\n+    for(int i = 0; i < ns->params->num_queues; i++) {\n+        ns->sched_send[i] = (model_net_sched*)malloc(sizeof(model_net_sched));\n+        model_net_sched_init(&ns->params->sched_params, 0, method_array[ns->net_id],\n+                ns->sched_send[i]);\n+        ns->in_sched_send_loop[i] = 0;\n+    }\n     ns->sched_recv = malloc(sizeof(model_net_sched));\n-    // init both the sender queue and the 'receiver' queue\n-    model_net_sched_init(&ns->params->sched_params, 0, method_array[ns->net_id],\n-            ns->sched_send);\n     model_net_sched_init(&ns->params->sched_params, 1, method_array[ns->net_id],\n             ns->sched_recv);\n \n@@ -542,6 +589,83 @@ void handle_new_msg(\n         tw_bf *b,\n         model_net_wrap_msg * m,\n         tw_lp * lp){\n+    static int num_servers = -1;\n+    static int servers_per_node = -1;\n+    if(num_servers == -1) {\n+        char const *sender_group;\n+        char const *sender_lpname;\n+        int rep_id, offset;\n+        model_net_request *r = &m->msg.m_base.req;\n+        codes_mapping_get_lp_info2(r->src_lp, &sender_group, &sender_lpname, \n+                NULL, &rep_id, &offset);\n+        num_servers = codes_mapping_get_lp_count(sender_group, 1,\n+                sender_lpname, NULL, 1);\n+        servers_per_node = num_servers/ns->params->num_queues; //this is for entire switch\n+        servers_per_node_queue = num_servers/ns->nics_per_router/ns->params->node_copy_queues;\n+        if(!g_tw_mynode) {\n+            fprintf(stdout, \"Set num_servers per router %d, servers per \"\n+                \"injection queue per router %d, servers per node copy queue \"\n+                \"per node %d\\n\", num_servers, servers_per_node, \n+                servers_per_node_queue);\n+        }\n+    } \n+\n+    if(lp->gid == m->msg.m_base.req.dest_mn_lp) {\n+        model_net_request *r = &m->msg.m_base.req;\n+        int rep_id, offset;\n+        codes_mapping_get_lp_info2(r->src_lp, NULL, NULL, NULL, &rep_id, &offset);\n+        int queue = offset/ns->nics_per_router/servers_per_node_queue;\n+        m->msg.m_base.save_ts = ns->node_copy_next_available_time[queue];\n+        tw_stime exp_time = ((ns->node_copy_next_available_time[queue] \n+                            > tw_now(lp)) ? ns->node_copy_next_available_time[queue] : tw_now(lp));\n+        exp_time += r->msg_size * codes_cn_delay;\n+        exp_time -= tw_now(lp);\n+        tw_stime delay = codes_local_latency(lp);\n+        ns->node_copy_next_available_time[queue] = exp_time;\n+        int remote_event_size = r->remote_event_size;\n+        int self_event_size = r->self_event_size;\n+        void *e_msg = (m+1);\n+        if (remote_event_size > 0) {\n+            exp_time += delay;\n+            tw_event *e = tw_event_new(r->final_dest_lp, exp_time, lp);\n+            memcpy(tw_event_data(e), e_msg, remote_event_size);\n+            tw_event_send(e);\n+            e_msg = (char*)e_msg + remote_event_size; \n+        }\n+        if (self_event_size > 0) {\n+            exp_time += delay;\n+            tw_event *e = tw_event_new(r->src_lp, exp_time, lp);\n+            memcpy(tw_event_data(e), e_msg, self_event_size);\n+            tw_event_send(e);\n+        }\n+        return;\n+    }\n+\n+    if(m->msg.m_base.isQueueReq) {\n+        m->msg.m_base.save_ts = ns->next_available_time;\n+        tw_stime exp_time = ((ns->next_available_time > tw_now(lp)) ? ns->next_available_time : tw_now(lp));\n+        exp_time += ns->params->nic_seq_delay + codes_local_latency(lp);\n+        ns->next_available_time = exp_time;\n+        tw_event *e = tw_event_new(lp->gid, exp_time - tw_now(lp), lp);\n+        model_net_wrap_msg *m_new = tw_event_data(e);\n+        memcpy(m_new, m, sizeof(model_net_wrap_msg));\n+        void *e_msg = (m+1);\n+        void *e_new_msg = (m_new+1);\n+        model_net_request *r = &m->msg.m_base.req;\n+        int remote_event_size = r->remote_event_size;\n+        int self_event_size = r->self_event_size;\n+        if (remote_event_size > 0){\n+            memcpy(e_new_msg, e_msg, remote_event_size);\n+            e_msg = (char*)e_msg + remote_event_size; \n+            e_new_msg = (char*)e_new_msg + remote_event_size; \n+        }\n+        if (self_event_size > 0){\n+            memcpy(e_new_msg, e_msg, self_event_size);\n+        }\n+        m_new->msg.m_base.isQueueReq = 0;\n+        tw_event_send(e);\n+        return;\n+    } \n     // simply pass down to the scheduler\n     model_net_request *r = &m->msg.m_base.req;\n     // don't forget to set packet size, now that we're responsible for it!\n@@ -557,11 +681,29 @@ void handle_new_msg(\n         local = m_data;\n     }\n \n+    int queue_offset = 0;\n+    if(!m->msg.m_base.is_from_remote && ns->params->num_queues != 1) {\n+        int rep_id, offset;\n+        if(num_servers == -1) {\n+            char const *sender_group;\n+            char const *sender_lpname;\n+            codes_mapping_get_lp_info2(r->src_lp, &sender_group, &sender_lpname, \n+                    NULL, &rep_id, &offset);\n+            num_servers = codes_mapping_get_lp_count(sender_group, 1,\n+                    sender_lpname, NULL, 1);\n+            servers_per_node = num_servers/ns->params->num_queues;\n+        } else {\n+            codes_mapping_get_lp_info2(r->src_lp, NULL, NULL, NULL, &rep_id, &offset);\n+        }\n+        queue_offset = offset/servers_per_node;\n+    }\n+    r->queue_offset = queue_offset;\n+\n     // set message-specific params\n     int is_from_remote = m->msg.m_base.is_from_remote;\n-    model_net_sched *ss = is_from_remote ? ns->sched_recv : ns->sched_send;\n+    model_net_sched *ss = is_from_remote ? ns->sched_recv : ns->sched_send[queue_offset];\n     int *in_sched_loop = is_from_remote  ?\n-        &ns->in_sched_recv_loop : &ns->in_sched_send_loop;\n+        &ns->in_sched_recv_loop : &ns->in_sched_send_loop[queue_offset];\n     model_net_sched_add(r, &m->msg.m_base.sched_params, r->remote_event_size,\n             remote, r->self_event_size, local, ss, &m->msg.m_base.rc, lp);\n \n@@ -582,10 +724,25 @@ void handle_new_msg_rc(\n         tw_bf *b,\n         model_net_wrap_msg *m,\n         tw_lp *lp){\n+    if(lp->gid == m->msg.m_base.req.dest_mn_lp) {\n+        codes_local_latency_reverse(lp);\n+        model_net_request *r = &m->msg.m_base.req;\n+        int rep_id, offset;\n+        codes_mapping_get_lp_info2(r->src_lp, NULL, NULL, NULL, &rep_id, &offset);\n+        int queue = offset/ns->nics_per_router/servers_per_node_queue;\n+        ns->node_copy_next_available_time[queue] = m->msg.m_base.save_ts;\n+        return;\n+    }\n+    if(m->msg.m_base.isQueueReq) {\n+        codes_local_latency_reverse(lp);\n+        ns->next_available_time = m->msg.m_base.save_ts;\n+        return;\n+    }\n+    model_net_request *r = &m->msg.m_base.req;\n     int is_from_remote = m->msg.m_base.is_from_remote;\n-    model_net_sched *ss = is_from_remote ? ns->sched_recv : ns->sched_send;\n+    model_net_sched *ss = is_from_remote ? ns->sched_recv : ns->sched_send[r->queue_offset];\n     int *in_sched_loop = is_from_remote  ?\n-        &ns->in_sched_recv_loop : &ns->in_sched_send_loop;\n+        &ns->in_sched_recv_loop : &ns->in_sched_send_loop[r->queue_offset];\n \n     if (b->c31) {\n         handle_sched_next_rc(ns, b, m, lp);\n@@ -602,10 +759,11 @@ void handle_sched_next(\n         model_net_wrap_msg * m,\n         tw_lp * lp){\n     tw_stime poffset;\n+    model_net_request *r = &m->msg.m_base.req;\n     int is_from_remote = m->msg.m_base.is_from_remote;\n-    model_net_sched * ss = is_from_remote ? ns->sched_recv : ns->sched_send;\n+    model_net_sched * ss = is_from_remote ? ns->sched_recv : ns->sched_send[r->queue_offset];\n     int *in_sched_loop = is_from_remote ?\n-        &ns->in_sched_recv_loop : &ns->in_sched_send_loop;\n+        &ns->in_sched_recv_loop : &ns->in_sched_send_loop[r->queue_offset];\n     int ret = model_net_sched_next(&poffset, ss, m+1, &m->msg.m_base.rc, lp);\n     // we only need to know whether scheduling is finished or not - if not,\n     // go to the 'next iteration' of the loop\n@@ -621,9 +779,11 @@ void handle_sched_next(\n         tw_event *e = tw_event_new(lp->gid,\n                 poffset+codes_local_latency(lp), lp);\n         model_net_wrap_msg *m_wrap = tw_event_data(e);\n+        model_net_request *r_wrap = &m_wrap->msg.m_base.req;\n         msg_set_header(model_net_base_magic, MN_BASE_SCHED_NEXT, lp->gid,\n                 &m_wrap->h);\n         m_wrap->msg.m_base.is_from_remote = is_from_remote;\n+        r_wrap->queue_offset = r->queue_offset;\n         // no need to set m_base here\n         tw_event_send(e);\n     }\n@@ -634,10 +794,11 @@ void handle_sched_next_rc(\n         tw_bf *b,\n         model_net_wrap_msg * m,\n         tw_lp * lp){\n+    model_net_request *r = &m->msg.m_base.req;\n     int is_from_remote = m->msg.m_base.is_from_remote;\n-    model_net_sched * ss = is_from_remote ? ns->sched_recv : ns->sched_send;\n+    model_net_sched * ss = is_from_remote ? ns->sched_recv : ns->sched_send[r->queue_offset];\n     int *in_sched_loop = is_from_remote ?\n-        &ns->in_sched_recv_loop : &ns->in_sched_send_loop;\n+        &ns->in_sched_recv_loop : &ns->in_sched_send_loop[r->queue_offset];\n \n     model_net_sched_next_rc(ss, m+1, &m->msg.m_base.rc, lp);\n     if (b->c0){\n@@ -726,11 +887,18 @@ void model_net_method_send_msg_recv_event_rc(tw_lp *sender){\n \n void model_net_method_idle_event(tw_stime offset_ts, int is_recv_queue,\n         tw_lp * lp){\n+    model_net_method_idle_event2(offset_ts, is_recv_queue, 0, lp);\n+}\n+\n+void model_net_method_idle_event2(tw_stime offset_ts, int is_recv_queue, \n+        int queue_offset, tw_lp * lp){\n     tw_event *e = tw_event_new(lp->gid, offset_ts, lp);\n     model_net_wrap_msg *m_wrap = tw_event_data(e);\n+    model_net_request *r_wrap = &m_wrap->msg.m_base.req;\n     msg_set_header(model_net_base_magic, MN_BASE_SCHED_NEXT, lp->gid,\n             &m_wrap->h);\n     m_wrap->msg.m_base.is_from_remote = is_recv_queue;\n+    r_wrap->queue_offset = queue_offset;\n     tw_event_send(e);\n }\n \n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 14,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/model-net.c",
                        "old_path": "src/networks/model-net/model-net.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/model-net.c\n+++ b/src/networks/model-net/model-net.c\n@@ -28,6 +28,8 @@ extern struct model_net_method fattree_method;\n extern struct model_net_method dragonfly_router_method;\n extern struct model_net_method dragonfly_custom_router_method;\n extern struct model_net_method loggp_method;\n+extern struct model_net_method express_mesh_method;\n+extern struct model_net_method express_mesh_router_method;\n \n #define X(a,b,c,d) b,\n char * model_net_lp_config_names[] = {\n@@ -56,6 +58,9 @@ tw_stime mn_msg_offset = 0.0;\n static int is_msg_params_set[MAX_MN_MSG_PARAM_TYPES];\n static mn_sched_params sched_params; // MN_MSG_PARAM_SCHED\n static tw_stime start_time_param; // MN_MSG_PARAM_START_TIME\n+static double cn_bandwidth = 20;\n+tw_stime codes_cn_delay;\n+static int codes_node_eager_limit = 16000;\n \n // global listing of lp types found by model_net_register\n // - needs to be held between the register and configure calls\n@@ -135,6 +140,25 @@ int* model_net_configure(int *id_count){\n     // init the per-msg params here\n     memset(is_msg_params_set, 0,\n             MAX_MN_MSG_PARAM_TYPES*sizeof(*is_msg_params_set));\n+  \n+    ret = configuration_get_value_double(&config, \"PARAMS\", \"intra_bandwidth\", NULL,\n+            &cn_bandwidth);\n+    if(ret && !g_tw_mynode) {\n+        fprintf(stderr, \"Bandwidth of compute node channels not specified, \"\n+                \"setting to %lf\\n\", cn_bandwidth);\n+    }\n+\n+    codes_cn_delay = 1/cn_bandwidth;\n+    if(!g_tw_mynode) {\n+        printf(\"within node transfer per byte delay is %f\\n\", codes_cn_delay);\n+    }\n+    \n+    ret = configuration_get_value_int(&config, \"PARAMS\", \"node_eager_limit\", NULL,\n+            &codes_node_eager_limit);\n+    if(ret && !g_tw_mynode) {\n+        fprintf(stderr, \"Within-node eager limit (node_eager_limit) not specified, \"\n+                \"setting to %d\\n\", codes_node_eager_limit);\n+    }\n \n     return ids;\n }\n@@ -235,6 +259,7 @@ static model_net_event_return model_net_noop_event(\n         tw_lpid final_dest_lp,\n         int is_pull,\n         tw_stime offset,\n+        uint64_t message_size,\n         int remote_event_size,\n         void const * remote_event,\n         int self_event_size,\n@@ -243,22 +268,25 @@ static model_net_event_return model_net_noop_event(\n {\n     model_net_event_return num_rng_calls = 0;\n     tw_stime poffset = mn_in_sequence ? mn_msg_offset : 0.0;\n+    tw_stime delay = codes_local_latency(sender);\n+\n+    tw_stime sendTime = message_size * codes_cn_delay;\n \n     if (self_event_size && self_event != NULL) {\n-        poffset += codes_local_latency(sender);\n+        poffset += delay;\n         num_rng_calls++;\n-        tw_event *e = tw_event_new(sender->gid, poffset+offset, sender);\n+        tw_event *e = tw_event_new(sender->gid, poffset+offset+sendTime, sender);\n         memcpy(tw_event_data(e), self_event, self_event_size);\n         tw_event_send(e);\n     }\n \n     if (remote_event_size && remote_event != NULL) {\n-        poffset += codes_local_latency(sender);\n+        poffset += delay;\n         num_rng_calls++;\n         /* special case - in a \"pull\" event, the \"remote\" message is actually\n          * to self */\n         tw_event *e = tw_event_new(is_pull ? sender->gid : final_dest_lp,\n-                poffset+offset, sender);\n+                poffset+offset+sendTime, sender);\n         memcpy(tw_event_data(e), remote_event, remote_event_size);\n         tw_event_send(e);\n     }\n@@ -298,8 +326,8 @@ static model_net_event_return model_net_event_impl_base(\n     tw_lpid dest_mn_lp = model_net_find_local_device_mctx(net_id, recv_map_ctx,\n             final_dest_lp);\n \n-    if (src_mn_lp == dest_mn_lp)\n-        return model_net_noop_event(final_dest_lp, is_pull, offset,\n+    if (src_mn_lp == dest_mn_lp && message_size < (uint64_t)codes_node_eager_limit)\n+        return model_net_noop_event(final_dest_lp, is_pull, offset, message_size,\n                 remote_event_size, remote_event, self_event_size, self_event,\n                 sender);\n \n@@ -342,6 +370,7 @@ static model_net_event_return model_net_event_impl_base(\n \n     // this is an outgoing message\n     m->msg.m_base.is_from_remote = 0;\n+    m->msg.m_base.isQueueReq = 1;\n \n     // set the msg-specific params\n     if (is_msg_params_set[MN_SCHED_PARAM_PRIO])\n"
                    },
                    {
                        "merge_request_diff_id": 272,
                        "relative_order": 15,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/slimfly.c",
                        "old_path": "src/networks/model-net/slimfly.c",
                        "binary": false,
                        "utf8_diff": "--- a/src/networks/model-net/slimfly.c\n+++ b/src/networks/model-net/slimfly.c\n@@ -25,7 +25,7 @@\n #define MEAN_PROCESS 1.0\n \n /* collective specific parameters */\n-#define DFLY_HASH_TABLE_SIZE 65536\n+#define SLIMFLY_HASH_TABLE_SIZE 65536\n \n // debugging parameters\n #define TRACK 4\n@@ -34,7 +34,6 @@\n #define TRACK_OUTPUT 1\n #define DEBUG 0\n #define DEBUG_ROUTING 0\n-#define USE_DIRECT_SCHEME 1\n #define LOAD_FROM_FILE 0\n \n #define LP_CONFIG_NM (model_net_lp_config_names[SLIMFLY])\n@@ -45,7 +44,7 @@\n #define ROUTER_SENDS_RECVS_LOG 0\n #define TERMINAL_OCCUPANCY_LOG 0\n #define ROUTER_OCCUPANCY_LOG 0\n-#define PARAMS_LOG 1\n+#define PARAMS_LOG 0\n #define N_COLLECT_POINTS 100\n \n /*unsigned long terminal_sends[TEMP_NUM_TERMINALS][N_COLLECT_POINTS];\n@@ -54,7 +53,8 @@\n   unsigned long router_recvs[TEMP_NUM_ROUTERS][N_COLLECT_POINTS];\n   int vc_occupancy_storage_router[TEMP_NUM_ROUTERS][TEMP_RADIX][TEMP_NUM_VC][N_COLLECT_POINTS];\n   int vc_occupancy_storage_terminal[TEMP_NUM_TERMINALS][TEMP_NUM_VC][N_COLLECT_POINTS];\n-  */FILE * slimfly_terminal_sends_recvs_log = NULL;\n+  */\n+FILE * slimfly_terminal_sends_recvs_log = NULL;\n FILE * slimfly_router_sends_recvs_log = NULL;\n FILE * slimfly_router_occupancy_log=NULL;\n FILE * slimfly_terminal_occupancy_log=NULL;\n@@ -175,7 +175,6 @@ struct terminal_state\n {\n     uint64_t packet_counter;\n \n-    // Dragonfly specific parameters\n     int router_id;\n     int terminal_id;\n \n@@ -276,7 +275,7 @@ struct router_state\n     char output_buf2[4096];\n \n     int** vc_occupancy;\n-    int* link_traffic;\t//Aren't used\n+    int64_t* link_traffic;\t//Aren't used\n \n     const char * anno;\n     const slimfly_param *params;\n@@ -597,7 +596,6 @@ static void slimfly_report_stats()\n     int total_minimal_packets, total_nonmin_packets;\n     float throughput_avg = 0.0;\n     float throughput_avg2 = 0.0;\n-    char log[300];\n \n     MPI_Reduce( &total_hops, &avg_hops, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n     MPI_Reduce( &N_finished_packets, &total_finished_packets, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);\n@@ -775,7 +773,7 @@ void slim_terminal_init( terminal_state * s,\n     int num_lps = codes_mapping_get_lp_count(lp_group_name, 1, LP_CONFIG_NM,\n             s->anno, 0);\n \n-    s->terminal_id = (mapping_rep_id * num_lps) + mapping_offset;\n+    s->terminal_id = codes_mapping_get_lp_relative_id(lp->gid, 0, 0);  \n     s->router_id=(int)s->terminal_id / (num_lps);\n     s->terminal_available_time = 0.0;\n     s->packet_counter = 0;\n@@ -798,7 +796,7 @@ void slim_terminal_init( terminal_state * s,\n         s->vc_occupancy[i]=0;\n     }\n \n-    s->rank_tbl = qhash_init(slimfly_rank_hash_compare, slimfly_hash_func, DFLY_HASH_TABLE_SIZE);\n+    s->rank_tbl = qhash_init(slimfly_rank_hash_compare, slimfly_hash_func, SLIMFLY_HASH_TABLE_SIZE);\n \n     if(!s->rank_tbl)\n         tw_error(TW_LOC, \"\\n Hash table not initialized! \");\n@@ -843,7 +841,7 @@ void slim_router_setup(router_state * r, tw_lp * lp)\n     r->global_channel = (int*)malloc(p->num_global_channels * sizeof(int));\n     r->local_channel = (int*)malloc(p->num_local_channels * sizeof(int));\n     r->next_output_available_time = (tw_stime*)malloc(p->radix * sizeof(tw_stime));\n-    r->link_traffic = (int*)malloc(p->radix * sizeof(int));\n+    r->link_traffic = (int64_t*)malloc(p->radix * sizeof(int64_t));\n     r->cur_hist_num = (int*)malloc(p->radix * sizeof(int));\n     r->prev_hist_num = (int*)malloc(p->radix * sizeof(int));\n \n@@ -1049,6 +1047,8 @@ void slim_router_setup(router_state * r, tw_lp * lp)\n         }\n     }\n #endif\n+    assert(local_idx == r->params->num_local_channels);\n+    assert(global_idx == r->params->num_global_channels);\n \n     return;\n }\n@@ -1223,6 +1223,7 @@ void slim_packet_generate(terminal_state * s, tw_bf * bf, slim_terminal_message \n     assert(lp->gid != msg->dest_terminal_id);\n     const slimfly_param *p = s->params;\n \n+    uint64_t i;\n     int total_event_size;\n     uint64_t num_chunks = msg->packet_size / p->chunk_size;\n     if (msg->packet_size % s->params->chunk_size)\n@@ -1243,7 +1244,7 @@ void slim_packet_generate(terminal_state * s, tw_bf * bf, slim_terminal_message \n     if(msg->packet_ID == TRACK)\n         printf(\"\\x1B[34m-->Packet generated at terminal %d sending to router %d \\x1b[0m\\n\", (int)lp->gid, s->router_id);\n \n-    for(uint64_t i = 0; i < num_chunks; i++)\n+    for(i = 0; i < num_chunks; i++)\n     {\n         slim_terminal_message_list *cur_chunk = (slim_terminal_message_list*)malloc(\n                 sizeof(slim_terminal_message_list));\n@@ -1341,7 +1342,7 @@ void slim_packet_send_rc(terminal_state * s, tw_bf * bf, slim_terminal_message *\n     }\n     if(bf->c5)\n     {\n-        tw_rand_reverse_unif(lp->rng);\n+        codes_local_latency_reverse(lp);\n         s->issueIdle = 1;\n         if(bf->c6)\n         {\n@@ -1396,7 +1397,7 @@ void slim_packet_send(terminal_state * s, tw_bf * bf, slim_terminal_message * ms\n     codes_mapping_get_lp_id(lp_group_name, \"slimfly_router\", NULL, 1,\n             s->router_id, 0, &router_id);\n     // we are sending an event to the router, so no method_event here\n-    e = tw_event_new(router_id, s->terminal_available_time - tw_now(lp), lp);\n+    e = tw_event_new(router_id, ts, lp);\n     m = tw_event_data(e);\n     memcpy(m, &cur_entry->msg, sizeof(slim_terminal_message));\n     if (m->remote_event_size_bytes)\n@@ -1557,6 +1558,12 @@ void slim_packet_arrive_rc(terminal_state * s, tw_bf * bf, slim_terminal_message\n \n     assert(tmp);\n     tmp->num_chunks--;\n+    if(bf->c5)\n+    {\n+      qhash_del(hash_link);\n+      free_tmp(tmp);\t\n+      s->rank_tbl_pop--;\n+    }\n \n     return;\n }\n@@ -1595,28 +1602,8 @@ void slim_packet_arrive(terminal_state * s, tw_bf * bf, slim_terminal_message * \n     // NIC aggregation - should this be a separate function?\n     // Trigger an event on receiving server\n \n-    struct sfly_hash_key key;\n-    key.message_id = msg->message_id;\n-    key.sender_id = msg->sender_lp;\n-\n-    struct qhash_head *hash_link = NULL;\n-    struct sfly_qhash_entry * tmp = NULL;\n-\n-    hash_link = qhash_search(s->rank_tbl, &key);\n-\n-    if(hash_link)\n-        tmp = qhash_entry(hash_link, struct sfly_qhash_entry, hash_link);\n-\n-    uint64_t total_chunks = msg->total_size / s->params->chunk_size;\n-\n-    if(msg->total_size % s->params->chunk_size)\n-        total_chunks++;\n-\n-    if(!total_chunks)\n-        total_chunks = 1;\n-\n     tw_stime ts = g_tw_lookahead + s->params->credit_delay + tw_rand_unif(lp->rng);\n-\n+    \n     // no method_event here - message going to router\n     tw_event * buf_e;\n     slim_terminal_message * buf_msg;\n@@ -1640,6 +1627,14 @@ void slim_packet_arrive(terminal_state * s, tw_bf * bf, slim_terminal_message * \n     assert(lp->gid != msg->src_terminal_id);\n \n     uint64_t num_chunks = msg->packet_size / s->params->chunk_size;\n+    uint64_t total_chunks = msg->total_size / s->params->chunk_size;\n+\n+    if(msg->total_size % s->params->chunk_size)\n+        total_chunks++;\n+\n+    if(!total_chunks)\n+        total_chunks = 1;\n+\n     if (msg->packet_size % s->params->chunk_size)\n         num_chunks++;\n \n@@ -1651,7 +1646,7 @@ void slim_packet_arrive(terminal_state * s, tw_bf * bf, slim_terminal_message * \n \n     if(msg->path_type == NON_MINIMAL)\n         nonmin_count++;\n-\n+    \n     if(msg->path_type != MINIMAL && msg->path_type != NON_MINIMAL)\n         printf(\"\\n Wrong message path type %d \", msg->path_type);\n \n@@ -1679,10 +1674,19 @@ void slim_packet_arrive(terminal_state * s, tw_bf * bf, slim_terminal_message * \n     /* Now retreieve the number of chunks completed from the hash and update\n      * them */\n     void *m_data_src = model_net_method_get_edata(SLIMFLY, msg);\n+    struct qhash_head *hash_link = NULL;\n+    struct sfly_qhash_entry * tmp = NULL;\n+    struct sfly_hash_key key;\n+    key.message_id = msg->message_id;\n+    key.sender_id = msg->sender_lp;\n \n+    hash_link = qhash_search(s->rank_tbl, &key);\n+\n+    if(hash_link)\n+        tmp = qhash_entry(hash_link, struct sfly_qhash_entry, hash_link);\n \n     /* If an entry does not exist then create one */\n-    if(!tmp)\n+    if(!hash_link)\n     {\n         bf->c5 = 1;\n         struct sfly_qhash_entry * d_entry = malloc(sizeof (struct sfly_qhash_entry));\n@@ -1872,7 +1876,7 @@ void slimfly_terminal_final( terminal_state * s,\n     lp_io_write(lp->gid, \"slimfly-msg-stats\", written, s->output_buf);\n \n     if(s->terminal_msgs[0] != NULL)\n-        //      printf(\"[%lu] leftover terminal messages \\n\", lp->gid);\n+      printf(\"[%llu] leftover terminal messages \\n\", lp->gid);\n \n         if(!s->terminal_id)\n         {\n@@ -1903,33 +1907,19 @@ void slimfly_router_final(router_state * s,\n     (void)lp;\n \n     free(s->global_channel);\n-    /*char *stats_file = getenv(\"TRACER_LINK_FILE\");\n-      if(stats_file != NULL) {\n-      FILE *fout = fopen(stats_file, \"a\");\n-      const slimfly_param *p = s->params;\n-      int result = flock(fileno(fout), LOCK_EX);\n-      assert(result);\n-      fprintf(fout, \"%d %d \", s->router_id / p->num_routers,\n-      s->router_id % p->num_routers);\n-      for(int d = 0; d < p->num_routers + p->num_global_channels; d++) {\n-      fprintf(fout, \"%d \", s->link_traffic[d]);\n-      }\n-      fprintf(fout, \"\\n\");\n-      result = flock(fileno(fout), LOCK_UN);\n-      fclose(fout);\n-      }*/\n     int i, j;\n     for(i = 0; i < s->params->radix; i++) {\n         for(j = 0; j < s->params->num_vcs; j++) {\n             if(s->queued_msgs[i][j] != NULL) {\n-                //          printf(\"[%lu] leftover queued messages %d %d %d\\n\", lp->gid, i, j,\n-                //          s->vc_occupancy[i][j]);\n+              printf(\"[%llu] leftover queued messages %d %d %d\\n\", lp->gid, i, j,\n+                     s->vc_occupancy[i][j]);\n             }\n             if(s->pending_msgs[i][j] != NULL) {\n-                //          printf(\"[%lu] lefover pending messages %d %d\\n\", lp->gid, i, j);\n+              printf(\"[%llu] lefover pending messages %d %d\\n\", lp->gid, i, j);\n             }\n         }\n     }\n+    rc_stack_destroy(s->st);\n     int written = 0;\n     if(s->router_id == 0)\n     {\n@@ -1962,8 +1952,8 @@ void slimfly_router_final(router_state * s,\n     }\n     written += sprintf(s->output_buf2 + written, \"\\n %llu %d %d\",\n             LLU(lp->gid),\n-            s->group_id,\n-            s->router_id);\n+            s->router_id /s-> params->num_routers,\n+            s->router_id % s->params->num_routers);\n \n     for(int d = 0; d < s->params->num_local_channels + s->params->num_global_channels; d++) \n         written += sprintf(s->output_buf2 + written, \" %lld\", LLD(s->link_traffic[d]));\n@@ -2807,6 +2797,11 @@ slim_router_packet_receive( router_state * s,\n     int intm_id = -1;\n     int *intm_router;\t\t//Array version of intm_id for use in Adaptive routing\n     int local_grp_id = s->router_id / s->params->num_routers;\n+    \n+    slim_terminal_message_list * cur_chunk = (slim_terminal_message_list *)malloc(\n+            sizeof(slim_terminal_message_list));\n+    slim_init_terminal_message_list(cur_chunk, msg);\n+\n \n     if(routing == NON_MINIMAL)\n     {\n@@ -2818,7 +2813,7 @@ slim_router_packet_receive( router_state * s,\n             intm_id = (local_grp_id + 1) % (s->params->slim_total_routers - 1);\n         }\n     }\n-    if(routing == ADAPTIVE)\n+    if(msg->last_hop == TERMINAL && routing == ADAPTIVE)\n     {\n         intm_router = (int *)malloc(num_indirect_routes * sizeof(int)); \t//indirect == nonMinimal == valiant\n         //Generate n_I many indirect routes through intermediate random routers\n@@ -2835,15 +2830,8 @@ slim_router_packet_receive( router_state * s,\n                 intm_router[i] = (intm_router[i]+1) % (s->params->slim_total_routers-1);\n             }\n         }\n-    }\n-\n-    slim_terminal_message_list * cur_chunk = (slim_terminal_message_list *)malloc(\n-            sizeof(slim_terminal_message_list));\n-    slim_init_terminal_message_list(cur_chunk, msg);\n-\n-    if(msg->last_hop == TERMINAL && routing == ADAPTIVE)\n-    {\n         next_stop = do_adaptive_routing(s, &(cur_chunk->msg), lp, dest_router_id, intm_router);\n+        free(intm_router);\n     }\n     else\n     {\n@@ -3197,7 +3185,7 @@ void slim_router_buf_update_rc(router_state * s,\n         tw_rand_reverse_unif(lp->rng);\n         prepend_to_terminal_message_list(s->queued_msgs[indx],\n                 s->queued_msgs_tail[indx], output_chan, head);\n-        s->vc_occupancy[indx][output_chan] += s->params->chunk_size;\n+        s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n     }\n     if(bf->c2) {\n         codes_local_latency_reverse(lp);\n@@ -3231,7 +3219,7 @@ void slim_router_buf_update(router_state * s, tw_bf * bf, slim_terminal_message \n         slim_router_credit_send(s, &head->msg, lp, 1);\n         append_to_terminal_message_list(s->pending_msgs[indx],\n                 s->pending_msgs_tail[indx], output_chan, head);\n-        s->vc_occupancy[indx][output_chan] -= s->params->chunk_size;\n+        s->vc_occupancy[indx][output_chan] += s->params->chunk_size;\n #if ROUTER_OCCUPANCY_LOG\n         vc_occupancy_storage_router[s->router_id][indx][output_chan][index] = s->vc_occupancy[indx][output_chan]/s->params->chunk_size;\n #endif\n@@ -3255,6 +3243,7 @@ void slim_router_buf_update(router_state * s, tw_bf * bf, slim_terminal_message \n void slim_router_event(router_state * s, tw_bf * bf, slim_terminal_message * msg,\n         tw_lp * lp) {\n     assert(msg->magic == slim_router_magic_num);\n+    rc_stack_gc(lp, s->st);\n     switch(msg->type)\n     {\n         case R_SEND: // Router has sent a packet to an intra-group router (local channel)\n"
                    }
                ]
            },
            "events": [],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        },
        {
            "id": 1489,
            "target_branch": "master",
            "source_branch": "workloads",
            "source_project_id": 68,
            "author_id": 443,
            "assignee_id": null,
            "title": "Workloads",
            "created_at": "2019-01-22T23:55:06.590Z",
            "updated_at": "2019-01-22T23:55:06.590Z",
            "state": "opened",
            "merge_status": "can_be_merged",
            "target_project_id": 68,
            "iid": 79,
            "description": "",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": "0"
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": null,
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": "6630aaa73413788579c005717807d0ce6906abf9",
            "source_branch_sha": "6630aaa73413788579c005717807d0ce6906abf9",
            "target_branch_sha": "fb41c9c0b553f6a042834de25dec05fc8c5f70ba",
            "metrics": {
                "id": 1489,
                "merge_request_id": 1489,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2019-01-22T23:55:07.232Z",
                "updated_at": "2019-01-22T23:55:07.232Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": null,
                "latest_closed_at": null
            },
            "notes": [],
            "merge_request_diff": {
                "id": 3178,
                "state": "collected",
                "merge_request_id": 1489,
                "created_at": "2019-01-22T23:55:06.693Z",
                "updated_at": "2019-01-22T23:55:06.693Z",
                "base_commit_sha": "aab92d456ac894821554c06455eaa7771eb7f7b9",
                "real_size": "13",
                "head_commit_sha": "6630aaa73413788579c005717807d0ce6906abf9",
                "start_commit_sha": "aab92d456ac894821554c06455eaa7771eb7f7b9",
                "commits_count": 16,
                "merge_request_diff_commits": [
                    {
                        "authored_date": "2019-01-22T23:50:04.000Z",
                        "committed_date": "2019-01-22T23:50:04.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 0,
                        "sha": "6630aaa73413788579c005717807d0ce6906abf9",
                        "author_name": "Xin Wang",
                        "author_email": "xwang925@gmail.com",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang925@gmail.com",
                        "message": "pull master\n"
                    },
                    {
                        "authored_date": "2019-01-22T21:19:25.000Z",
                        "committed_date": "2019-01-22T21:19:25.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 1,
                        "sha": "1d34e479806ceef47086fe0ebdbb19ff7d9f78c8",
                        "author_name": "Xin Wang",
                        "author_email": "xwang925@gmail.com",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang925@gmail.com",
                        "message": "remove conceptual benchmark examples\n"
                    },
                    {
                        "authored_date": "2019-01-22T21:15:08.000Z",
                        "committed_date": "2019-01-22T21:15:08.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 2,
                        "sha": "3219d20008b515e964fd31154d498d3eecf8d29f",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete conc-latencyall.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:14:51.000Z",
                        "committed_date": "2019-01-22T21:14:51.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 3,
                        "sha": "807f83eece9627bc20d5c1cb7ba4385570c8f4c7",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete conc-latency.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:14:33.000Z",
                        "committed_date": "2019-01-22T21:14:33.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 4,
                        "sha": "c1b294d44a0fa523c8960efe3c18dedc157fcddb",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete conc-hotpotato.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:14:12.000Z",
                        "committed_date": "2019-01-22T21:14:12.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 5,
                        "sha": "8ac60867f1819e08de505a6d51ef1d606e5a7c56",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete conc-cosmoflow.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:13:56.000Z",
                        "committed_date": "2019-01-22T21:13:56.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 6,
                        "sha": "f11bf89f1267cdea1e9dbc7f82da2eb952f801c5",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete conc-bisect.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:13:08.000Z",
                        "committed_date": "2019-01-22T21:13:08.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 7,
                        "sha": "f8cff566981cc01a02330063705a271e220805a2",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete latency-all.ncptl"
                    },
                    {
                        "authored_date": "2019-01-22T21:12:42.000Z",
                        "committed_date": "2019-01-22T21:12:42.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 8,
                        "sha": "a5be58053b36d55be21f79d8fbdead2c07750f56",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete hotpotato.ncptl"
                    },
                    {
                        "authored_date": "2019-01-22T21:12:24.000Z",
                        "committed_date": "2019-01-22T21:12:24.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 9,
                        "sha": "b6942329d1f831f915525438e587af89d999dd83",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete hotpotato.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:12:10.000Z",
                        "committed_date": "2019-01-22T21:12:10.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 10,
                        "sha": "7c7b993d170eaf4064ee5c8693f868af3b19de49",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete cosmoflow.ncptl"
                    },
                    {
                        "authored_date": "2019-01-22T21:10:22.000Z",
                        "committed_date": "2019-01-22T21:10:22.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 11,
                        "sha": "64b3e69ca6f95c7bcaaf240f3fc449ce2e07d1bb",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete cosmoflow.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:10:05.000Z",
                        "committed_date": "2019-01-22T21:10:05.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 12,
                        "sha": "15f3c1b66d5bce319eea463c4c291a824cde848b",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete latency.ncptl"
                    },
                    {
                        "authored_date": "2019-01-22T21:09:46.000Z",
                        "committed_date": "2019-01-22T21:09:46.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 13,
                        "sha": "7c4cae0a9ce406b397ca0da8d3814cc4335b75fe",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete bisect.ncptl"
                    },
                    {
                        "authored_date": "2019-01-22T21:09:29.000Z",
                        "committed_date": "2019-01-22T21:09:29.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 14,
                        "sha": "2bafea6dddf8b7d14c21d13c4f28224ac0131919",
                        "author_name": "Xin Wang",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "Xin Wang",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "Delete bisect.c"
                    },
                    {
                        "authored_date": "2019-01-22T21:02:53.000Z",
                        "committed_date": "2019-01-22T21:02:53.000Z",
                        "merge_request_diff_id": 3178,
                        "relative_order": 15,
                        "sha": "1b0bc8c6ce08eb934d05f068db0ee02a1a3497dd",
                        "author_name": "xin",
                        "author_email": "xwang149@hawk.iit.edu",
                        "committer_name": "xin",
                        "committer_email": "xwang149@hawk.iit.edu",
                        "message": "fix make error for buiding without conceputual\n"
                    }
                ],
                "merge_request_diff_files": [
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 0,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "Makefile.am",
                        "old_path": "Makefile.am",
                        "binary": false,
                        "utf8_diff": "@@ -61,9 +61,18 @@ endif\n \n if USE_ONLINE\n AM_CPPFLAGS += ${ARGOBOTS_CFLAGS} ${SWM_CFLAGS} -DUSE_ONLINE=1\n-LDADD += ${SWM_LIBS} ${ARGOBOTS_LIBS}\n+LDADD += ${ARGOBOTS_LIBS}\n+if USE_SWM\n+AM_CPPFLAGS += -DUSE_SWM=1\n+LDADD += ${SWM_LIBS}\n src_libcodes_la_SOURCES += src/workload/methods/codes-online-comm-wrkld.C\n endif\n+if USE_CONC\n+src_libcodes_la_SOURCES += src/workload/methods/codes-conc-online-comm-wrkld.C\n+AM_CPPFLAGS += ${CONCEPTUAL_CFLAGS} -DUSE_CONC=1\n+LDADD += ${CONCEPTUAL_LIBS}\n+endif\n+endif\n \n if USE_DUMPI\n AM_CPPFLAGS += ${DUMPI_CFLAGS} -DUSE_DUMPI=1\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 1,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "codes/codes-conc-addon.h",
                        "old_path": "codes/codes-conc-addon.h",
                        "binary": false,
                        "utf8_diff": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (C) 2017 University of Chicago.\n+ * See COPYRIGHT notice in top-level directory.\n+ *\n+ */\n+\n+#ifndef CODES_CONC_ADDON_H\n+#define CODES_CONC_ADDON_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifdef USE_CONC\n+#include <ncptl/ncptl.h> \n+#endif\n+#include <mpi.h>\n+\n+#define MAX_CONC_ARGV 128\n+\n+typedef struct conc_bench_param conc_bench_param;\n+\n+\n+struct conc_bench_param {\n+    char conc_program[MAX_CONC_ARGV];\n+    int conc_argc;\n+    char config_in[MAX_CONC_ARGV][MAX_CONC_ARGV];\n+    char *conc_argv[MAX_CONC_ARGV];\n+};\n+\n+\n+int codes_conc_bench_load(\n+        const char* program,\n+        int argc, \n+        char *argv[]);\n+\n+void CODES_MPI_Comm_size (MPI_Comm comm, int *size);\n+void CODES_MPI_Comm_rank( MPI_Comm comm, int *rank );\n+void CODES_MPI_Finalize();\n+void CODES_MPI_Send(const void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int dest, \n+            int tag,\n+            MPI_Comm comm);\n+void CODES_MPI_Recv(void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int source, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Status *status);\n+void CODES_MPI_Sendrecv(const void *sendbuf, \n+            int sendcount, \n+            MPI_Datatype sendtype,\n+            int dest, \n+            int sendtag,\n+            void *recvbuf, \n+            int recvcount, \n+            MPI_Datatype recvtype,\n+            int source, \n+            int recvtag,\n+            MPI_Comm comm, \n+            MPI_Status *status);\n+void CODES_MPI_Barrier(MPI_Comm comm);\n+void CODES_MPI_Isend(const void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int dest, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Request *request);\n+void CODES_MPI_Irecv(void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int source, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Request *request);\n+void CODES_MPI_Waitall(int count, \n+            MPI_Request array_of_requests[], \n+            MPI_Status array_of_statuses[]);\n+void CODES_MPI_Reduce(const void *sendbuf, \n+            void *recvbuf, \n+            int count, \n+            MPI_Datatype datatype,\n+            MPI_Op op, \n+            int root, \n+            MPI_Comm comm);\n+void CODES_MPI_Allreduce(const void *sendbuf, \n+            void *recvbuf, \n+            int count, \n+            MPI_Datatype datatype,\n+            MPI_Op op, \n+            MPI_Comm comm);\n+void CODES_MPI_Bcast(void *buffer, \n+            int count, \n+            MPI_Datatype datatype, \n+            int root, \n+            MPI_Comm comm);\n+void CODES_MPI_Alltoall(const void *sendbuf, \n+            int sendcount, \n+            MPI_Datatype sendtype, \n+            void *recvbuf,\n+            int recvcount, \n+            MPI_Datatype recvtype, \n+            MPI_Comm comm);\n+void CODES_MPI_Alltoallv(const void *sendbuf, \n+            const int *sendcounts, \n+            const int *sdispls,\n+            MPI_Datatype sendtype, \n+            void *recvbuf, \n+            const int *recvcounts,\n+            const int *rdispls, \n+            MPI_Datatype recvtype, \n+            MPI_Comm comm);\n+\n+/* implementation structure */\n+struct codes_conceptual_bench {\n+    char *program_name; /* name of the conceptual program */\n+    int (*conceptual_main)(int argc, char *argv[]);\n+};\n+\n+\n+void codes_conceptual_add_bench(struct codes_conceptual_bench const * method);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* CODES_CONC_ADDON_H */\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 2,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100755",
                        "b_mode": "100755",
                        "new_path": "configure.ac",
                        "old_path": "configure.ac",
                        "binary": false,
                        "utf8_diff": "@@ -121,22 +121,48 @@ AM_CONDITIONAL(USE_DARSHAN, [test \"x${use_darshan}\" = xyes])\n \n # check for Argobots\n AC_ARG_WITH([online],[AS_HELP_STRING([--with-online@<:@=DIR@:>@],\n-                        [Build with the online workloads and argobots support])],\n-                      [use_online=yes],[use_online=no])\n-if test \"x${use_online}\" != \"xno\" ; then\n+                        [Build with the online workloads and argobots support])])\n+if test \"x${with_online}\" != \"x\" ; then\n     AM_CONDITIONAL(USE_ONLINE, true)\n     PKG_CHECK_MODULES_STATIC([ARGOBOTS], [argobots], [],\n                       [AC_MSG_ERROR([Could not find working argobots installation via pkg-config])])\n+    AC_DEFINE_UNQUOTED([ONLINE_CONFIGDIR], [\"$with_online\"], [if using json data files, \n+                    specify config directory])\n+else\n+    AM_CONDITIONAL(USE_ONLINE, false)\n+fi\n+\n+#check for SWM\n+AC_ARG_WITH([swm],[AS_HELP_STRING([--with-swm@<:@=DIR@:>@],\n+                        [location of SWM installation])])\n+if test \"x${with_swm}\" != \"x\" ; then\n+    AM_CONDITIONAL(USE_SWM, true)\n     PKG_CHECK_MODULES_STATIC([SWM], [swm], [],\n                       [AC_MSG_ERROR([Could not find working swm installation via pkg-config])])\n     PKG_CHECK_VAR([SWM_DATAROOTDIR], [swm], [datarootdir], [],\n               [AC_MSG_ERROR[Could not find shared directory in SWM]])\n     AC_DEFINE_UNQUOTED([SWM_DATAROOTDIR], [\"$SWM_DATAROOTDIR\"], [if using json\n-                        data files])\n+                    data files])\n else\n-    AM_CONDITIONAL(USE_ONLINE, false)\n+  AM_CONDITIONAL(USE_SWM, false)\n fi\n \n+#check for Conceptual\n+AC_ARG_WITH([conceptual],[AS_HELP_STRING([--with-conceptual@<:@=DIR@:>@],\n+                        [location of Conceptual installation])])\n+if test \"x${with_conceptual}\" != \"x\" ; then\n+  AC_CHECK_FILES([${with_conceptual}/lib/libncptl.a],\n+    AM_CONDITIONAL(USE_CONC, true),\n+    AC_MSG_ERROR(Could not find Conceptual libraries libncptl.a))\n+  CONCEPTUAL_CFLAGS=\"-I${with_conceptual}/include\"\n+  CONCEPTUAL_LIBS=\"-L${with_conceptual}/lib/ -lncptl\"\n+  AC_SUBST(CONCEPTUAL_LIBS)\n+  AC_SUBST(CONCEPTUAL_CFLAGS)\n+else\n+  AM_CONDITIONAL(USE_CONC, false)\n+fi\n+\n+\n # check for Recorder\n AM_CONDITIONAL(USE_RECORDER, true)\n RECORDER_CPPFLAGS=\"-DUSE_RECORDER=1\"\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 3,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "maint/codes.pc.in",
                        "old_path": "maint/codes.pc.in",
                        "binary": false,
                        "utf8_diff": "@@ -19,6 +19,8 @@ argobots_cflags=@ARGOBOTS_CFLAGS@\n swm_libs=@SWM_LIBS@\n swm_cflags=@SWM_CFLAGS@\n swm_datarootdir=@SWM_DATAROOTDIR@\n+conceptual_libs=@CONCEPTUAL_LIBS@\n+conceptual_cflags=@CONCEPTUAL_CFLAGS@\n \n Name: codes-base\n Description: Base functionality for CODES storage simulation\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 4,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "scripts/conceptual_benchmarks/translate_conc_src.py",
                        "old_path": "scripts/conceptual_benchmarks/translate_conc_src.py",
                        "binary": false,
                        "utf8_diff": "@@ -0,0 +1,181 @@\n+import string\n+import sys\n+import os\n+\n+MPI_OPS = [ 'MPI_Send', 'MPI_Recv', 'MPI_Barrier', 'MPI_Isend', 'MPI_Irecv', 'MPI_Waitall', \n+            'MPI_Reduce', 'MPI_Allreduce', 'MPI_Bcast', 'MPI_Alltoall', 'MPI_Alltoallv',\n+            'MPI_Comm_size', 'MPI_Comm_rank']\n+\n+LOG = [ 'logfiletmpl_default', 'ncptl_log_write', 'ncptl_log_compute_aggregates', 'ncptl_log_commit_data']\n+\n+def eliminate_logging(inLines):\n+    for idx, line in enumerate(inLines):\n+        if 'Generate and broadcast a UUID' in line:\n+            for i in range(1, 3):\n+                inLines[idx+i] = \"//\"+inLines[idx+i]  \n+        elif 'ncptl_free (logfile_uuid)' in line:\n+            for i in range(0, 12):\n+                inLines[idx-i] = \"//\"+inLines[idx-i]    \n+        elif 'int mpiresult' in line:\n+            for i in range(0,30):\n+                inLines[idx+i] = \"//\"+inLines[idx+i] \n+        else:\n+            for elem in LOG:\n+                if elem in line:\n+                    inLines[idx] = \"//\"+line\n+\n+def eliminate_conc_init(inLines):\n+    for idx, line in enumerate(inLines):\n+        if 'NCPTL_RUN_TIME_VERSION' in line:\n+            inLines[idx] = \"//\"+line\n+        if 'atexit (conc_exit_handler)' in line:\n+            inLines[idx] = \"//\"+line\n+        if 'Inform the run-time library' in line:\n+            for i in range(1, 4):\n+                inLines[idx+i] = \"//\"+inLines[idx+i]\n+\n+def make_static_var(inLines):\n+    for idx, line in enumerate(inLines):\n+        if 'Dummy variable to help mark other variables as used' in line:\n+            inLines[idx+1]=\"static \" + inLines[idx+1]\n+        if 'void conc_mark_variables_used' in line:\n+            inLines[idx]=\"static \" + line\n+        if '/* Program-specific variables */' in line:\n+            start = idx+1\n+        if '* Function declarations *' in line:\n+            end = idx-2\n+\n+    for i in range(start, end):\n+        inLines[i]=\"static \"+inLines[i]\n+\n+\n+def manipulate_mpi_ops(inLines, program_name):\n+    for idx, line in enumerate(inLines):\n+        # subcomm\n+        if 'MPI_' not in line:  # not MPI\n+            if \"int main\" in line:\n+                # inLines[idx] = \"static int \"+program_name+\"_main(int* argc, char *argv[])\"\n+                inLines[idx] = line.replace(\"int main\", \"static int \"+program_name+\"_main\")\n+            else:\n+                continue\n+        else:   # MPI \n+            if 'MPI_Init' in line:\n+                inLines[idx] = \"//\"+line\n+            elif 'MPI_Errhandler_' in line:     # error handling ignored\n+                inLines[idx] = \"//\"+line\n+            elif 'mpiresult = MPI_Finalize();' in line:\n+                inLines[idx] = \"CODES_MPI_Finalize();\"\n+                inLines[idx+2] = \"exitcode = 0;\"\n+            elif 'MPI_Comm_get_attr' in line:\n+                inLines[idx] = \"//\"+line\n+            else:\n+                for ops in MPI_OPS:\n+                    if ops in line:\n+                        inLines[idx] = line.replace(ops,\"CODES_\"+ops)\n+\n+def adding_struct(inLines, program_name):\n+    new_struct = [ '/* fill in function pointers for this method */' ,\n+                   'struct codes_conceptual_bench '+program_name+'_bench = ' , \n+                   '{' ,\n+                   '.program_name = \"'+program_name+'\",' ,\n+                   '.conceptual_main = '+program_name+'_main,' ,\n+                   '};' ]\n+\n+    codes_include = '#include \"codes/codes-conc-addon.h\"'\n+    for idx, line in enumerate(inLines):\n+        if \"* Include files *\" in line:\n+            inLines.insert(idx-1, codes_include)\n+            break\n+\n+    # adding struct at the end\n+    for i in range(0, len(new_struct)):\n+        inLines.append(new_struct[i])\n+\n+\n+def insert_if_not_exist(content, idx, hls):\n+    exist = False\n+    for i in range(idx[0], idx[1]):\n+        if hls[i] in content:\n+            exist = True\n+            break\n+\n+    if not exist:\n+        hls.insert(idx[0], content)\n+\n+def translate_conc_to_codes(filepath, codespath):\n+    # get program name\n+    program_name = filepath.split(\"/\")[-1].replace(\".c\",\"\")\n+\n+    with open(filepath, 'r') as infile:\n+        content = infile.read()\n+    inLines = content.split('\\n')\n+\n+    eliminate_logging(inLines)\n+    eliminate_conc_init(inLines)\n+    make_static_var(inLines)\n+    manipulate_mpi_ops(inLines, program_name)\n+    adding_struct(inLines, program_name)\n+\n+    # output program file\n+    with open(codespath+\"src/workload/conceputal-skeleton-apps/conc-\"+program_name+\".c\",\"w+\") as outFile:\n+        outFile.writelines([\"%s\\n\" % item for item in inLines])\n+\n+    # modify interface file\n+    program_struct = \"extern struct codes_conceptual_bench \"+program_name+\"_bench;\\n\"\n+    program_struct_idx=[]\n+    program_definition = \"    &\"+program_name+\"_bench,\\n\"\n+    program_definition_idx=[]\n+    with open(codespath+\"src/workload/codes-conc-addon.c\",\"r+\") as header:\n+        hls = header.readlines()\n+        for idx, line in enumerate(hls):\n+            if '/* list of available benchmarks begin */' in line:\n+                program_struct_idx.append(idx+1)\n+            elif '/* list of available benchmarks end */' in line:\n+                program_struct_idx.append(idx)\n+        insert_if_not_exist(program_struct, program_struct_idx, hls)\n+\n+        for idx, line in enumerate(hls):\n+            if '/* default benchmarks begin */' in line:\n+                program_definition_idx.append(idx+1)\n+            elif '/* default benchmarks end */' in line:\n+                program_definition_idx.append(idx)\n+        insert_if_not_exist(program_definition, program_definition_idx, hls)\n+\n+        header.seek(0)\n+        header.writelines(hls)\n+\n+    # modify makefile\n+    program_compile = \"src_libcodes_la_SOURCES += src/workload/conceputal-skeleton-apps/conc-\"+program_name+\".c\\n\"\n+    program_compile_idx = []\n+    with open(codespath+\"Makefile.am\",\"r+\") as makefile:\n+        mfls = makefile.readlines()\n+        for idx, line in enumerate(mfls):\n+            if \"CONCEPTUAL_LIBS\" in line:\n+                program_compile_idx.append(idx+1)\n+                break\n+        for i in range(program_compile_idx[0], len(mfls)):\n+            if 'endif' in mfls[i]:\n+                program_compile_idx.append(i)\n+                break\n+        insert_if_not_exist(program_compile, program_compile_idx, mfls)        \n+        makefile.seek(0)\n+        makefile.writelines(mfls)        \n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) != 4:\n+        print 'Need 2 arguments: 1. path to files to be converted \\t2. path to CODES directory\\t3. path to ncptl executable'\n+        sys.exit(1)\n+    \n+    os.chdir(sys.argv[1])\n+    for benchfile in next(os.walk(sys.argv[1]))[2]:    # for all files\n+        if benchfile.lower().endswith('.ncptl'):\n+            cfile = benchfile.replace('.ncptl','.c')\n+            cfile = cfile.replace(\"-\",\"\")\n+            os.system(sys.argv[3]+' --backend=c_mpi --no-compile '+benchfile+' --output '+cfile)\n+            print \"adding bench file: %s\" % cfile\n+            translate_conc_to_codes(sys.argv[1]+cfile, sys.argv[2])\n+\n+\n+\n+\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 5,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/Makefile.subdir",
                        "old_path": "src/Makefile.subdir",
                        "binary": false,
                        "utf8_diff": "@@ -105,7 +105,8 @@ nobase_include_HEADERS = \\\n \tcodes/net/express-mesh.h \\\n \tcodes/net/torus.h \\\n     codes/codes-mpi-replay.h \\\n-\tcodes/configfile.h\n+\tcodes/configfile.h \\\n+    codes/codes-conc-addon.h\n \n \n #codes/codes-nw-workload.h\n@@ -151,6 +152,7 @@ src_libcodes_la_SOURCES =  \\\n \tsrc/util/codes-mapping-context.c \\\n   \tsrc/util/codes-comm.c \\\n     src/workload/codes-workload.c \\\n+    src/workload/codes-conc-addon.c \\\n     src/workload/methods/codes-iolang-wrkld.c \\\n     src/workload/methods/codes-checkpoint-wrkld.c \\\n     src/workload/methods/test-workload-method.c \\\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 6,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/network-workloads/model-net-mpi-replay.c",
                        "old_path": "src/network-workloads/model-net-mpi-replay.c",
                        "binary": false,
                        "utf8_diff": "@@ -106,6 +106,7 @@ static float noise = 1.0;\n static int num_nw_lps = 0, num_mpi_lps = 0;\n \n static int num_syn_clients;\n+static int finished_syn_clients;\n static int syn_type = 0;\n \n FILE * workload_log = NULL;\n@@ -522,8 +523,11 @@ static void notify_background_traffic(\n         \n         int num_jobs = codes_jobmap_get_num_jobs(jobmap_ctx); \n         \n-        for(int other_id = 0; other_id < num_jobs; other_id++)\n+        //Assumption: synthetic job are at the bottom of workload configure file\n+        for(int other_id = num_jobs - 1; other_id >= 0; other_id--)\n         {\n+            if(finished_syn_clients == num_syn_clients)\n+                break;\n             if(other_id == jid.job)\n                 continue;\n \n@@ -548,6 +552,7 @@ static void notify_background_traffic(\n                 m_new = (struct nw_message*)tw_event_data(e);\n                 m_new->msg_type = CLI_BCKGND_FIN;\n                 tw_event_send(e);   \n+                finished_syn_clients += 1;\n             }\n         }\n         return;\n@@ -575,15 +580,25 @@ static void notify_neighbor(\n         tw_bf * bf,\n         struct nw_message * m)\n {\n-    if(ns->local_rank == num_dumpi_traces - 1 \n+    int num_ranks = codes_jobmap_get_num_ranks(ns->app_id, jobmap_ctx);\n+\n+    //if all application workloads finishes, notify background traffic to stop\n+    if(ns->local_rank == num_ranks - 1 \n             && ns->is_finished == 1\n             && ns->neighbor_completed == 1)\n     {\n-//        printf(\"\\n All workloads completed, notifying background traffic \");\n-        bf->c0 = 1;\n-        notify_background_traffic(ns, lp, bf, m);\n+        // printf(\"\\n All ranks completed\");\n+        num_dumpi_traces -= num_ranks;\n+\n+        if(num_dumpi_traces == 0) {     \n+            // printf(\"\\n All workloads completed, notifying background traffic \");          \n+            bf->c0 = 1;\n+            notify_background_traffic(ns, lp, bf, m);\n+        }\n         return;\n     }\n+\n+\n     \n     struct codes_jobmap_id nbr_jid;\n     nbr_jid.job = ns->app_id;\n@@ -2132,7 +2147,7 @@ void nw_test_init(nw_state* s, tw_lp* lp)\n \tstrcpy(params_d.cortex_gen, cortex_gen);\n #endif\n    }\n-   else if(strcmp(workload_type, \"online\") == 0){\n+   else if(strcmp(workload_type, \"swm-online\") == 0){\n            \n        online_comm_params oc_params;\n        \n@@ -2151,7 +2166,25 @@ void nw_test_init(nw_state* s, tw_lp* lp)\n         * online, it is the number of ranks to be simulated. */\n        oc_params.nprocs = num_traces_of_job[lid.job]; \n        params = (char*)&oc_params;\n-       strcpy(type_name, \"online_comm_workload\");\n+       strcpy(type_name, \"swm_online_comm_workload\");\n+   }\n+   else if(strcmp(workload_type, \"conc-online\") == 0){\n+           \n+       online_comm_params oc_params;\n+       \n+       if(strlen(workload_name) > 0)\n+       {\n+           strcpy(oc_params.workload_name, workload_name); \n+       }\n+       else if(strlen(workloads_conf_file) > 0)\n+       {\n+            strcpy(oc_params.workload_name, file_name_of_job[lid.job]);      \n+       }\n+       /*TODO: nprocs is different for dumpi and online workload. for\n+        * online, it is the number of ranks to be simulated. */\n+       oc_params.nprocs = num_traces_of_job[lid.job]; \n+       params = (char*)&oc_params;\n+       strcpy(type_name, \"conc_online_comm_workload\");\n    }\n \n    int rc = configuration_get_value_int(&config, \"PARAMS\", \"num_qos_levels\", NULL, &num_qos_levels);\n@@ -2622,16 +2655,20 @@ void nw_test_finalize(nw_state* s, tw_lp* lp)\n             return;\n         if(strncmp(file_name_of_job[lid.job], \"synthetic\", 9) == 0)\n             avg_msg_time = (s->send_time / s->num_recvs);\n-        else if(strcmp(workload_type, \"online\") == 0) \n-        codes_workload_finalize(\"online_comm_workload\", params, s->app_id, s->local_rank);\n+        else if(strcmp(workload_type, \"swm-online\") == 0) \n+            codes_workload_finalize(\"swm_online_comm_workload\", params, s->app_id, s->local_rank);\n+        else if(strcmp(workload_type, \"conc-online\") == 0)\n+            codes_workload_finalize(\"conc_online_comm_workload\", params, s->app_id, s->local_rank);\n     }\n     else\n     {\n         if(s->nw_id >= (tw_lpid)num_net_traces)\n             return;\n         \n-        if(strcmp(workload_type, \"online\") == 0) \n-            codes_workload_finalize(\"online_comm_workload\", params, s->app_id, s->local_rank);\n+        if(strcmp(workload_type, \"swm-online\") == 0) \n+            codes_workload_finalize(\"swm_online_comm_workload\", params, s->app_id, s->local_rank);\n+        if(strcmp(workload_type, \"conc-online\") == 0)\n+            codes_workload_finalize(\"conc_online_comm_workload\", params, s->app_id, s->local_rank);  \n     }\n \n         struct msg_size_info * tmp_msg = NULL; \n@@ -2942,7 +2979,7 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n #endif\n   codes_comm_update();\n \n-  if(strcmp(workload_type, \"dumpi\") != 0 && strcmp(workload_type, \"online\") != 0)\n+  if(strcmp(workload_type, \"dumpi\") != 0 && strcmp(workload_type, \"swm-online\") != 0 && strcmp(workload_type, \"conc-online\") != 0)\n     {\n \tif(tw_ismaster())\n \t\tprintf(\"Usage: mpirun -np n ./modelnet-mpi-replay --sync=1/3\"\n@@ -2960,6 +2997,10 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n \ttw_end();\n \treturn -1;\n     }\n+    /* Currently rendezvous protocol cannot work with Conceptual */\n+    if(strcmp(workload_type, \"conc-online\") == 0) {\n+        EAGER_THRESHOLD = INT64_MAX;\n+    }\n \n \tjobmap_ctx = NULL; // make sure it's NULL if it's not used\n \n@@ -2982,7 +3023,7 @@ int modelnet_mpi_replay(MPI_Comm comm, int* argc, char*** argv )\n             \n             if(ref != EOF && strncmp(file_name_of_job[i], \"synthetic\", 9) == 0)\n             {\n-              num_syn_clients = num_traces_of_job[i];\n+              num_syn_clients += num_traces_of_job[i];\n               num_net_traces += num_traces_of_job[i];\n             }\n             else if(ref!=EOF)\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 7,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/networks/model-net/dragonfly-custom.C",
                        "old_path": "src/networks/model-net/dragonfly-custom.C",
                        "binary": false,
                        "utf8_diff": "@@ -2402,8 +2402,8 @@ void dragonfly_custom_router_final(router_state * s,\n     written = 0;\n     if(!s->router_id)\n     {\n-        written = sprintf(s->output_buf, \"# Format <LP ID> <Group ID> <Router ID> <Link Traffic per router port(s)>\");\n-        written += sprintf(s->output_buf + written, \"# Router ports in the order: %d green links, %d black links %d global channels \\n\", \n+        written = sprintf(s->output_buf2, \"# Format <LP ID> <Group ID> <Router ID> <Link Traffic per router port(s)>\");\n+        written += sprintf(s->output_buf2 + written, \"# Router ports in the order: %d green links, %d black links %d global channels \\n\", \n                 p->num_router_cols * p->num_row_chans, p->num_router_rows * p->num_col_chans, p->num_global_channels);\n     }\n     written += sprintf(s->output_buf2 + written, \"\\n %llu %d %d\",\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 8,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "src/workload/codes-conc-addon.c",
                        "old_path": "src/workload/codes-conc-addon.c",
                        "binary": false,
                        "utf8_diff": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright (C) 2013 University of Chicago.\n+ * See COPYRIGHT notice in top-level directory.\n+ *\n+ */\n+#include <assert.h>\n+#include <ross.h>\n+#include <codes/codes.h>\n+#include <codes/codes-conc-addon.h>\n+\n+#ifdef USE_CONC\n+/* list of available benchmarks begin */\n+/* list of available benchmarks end */\n+#endif\n+\n+static struct codes_conceptual_bench const * bench_array_default[] =\n+{\n+#ifdef USE_CONC\n+    /* default benchmarks begin */\n+    /* default benchmarks end */\n+#endif\n+    NULL\n+};\n+\n+// once initialized, adding a bench generator is an error\n+static int is_bench_init = 0;\n+static int num_user_benchs = 0;\n+static struct codes_conceptual_bench const ** bench_array = NULL;\n+\n+\n+\n+// only call this once\n+static void init_bench_methods(void)\n+{\n+    if (is_bench_init)\n+        return;\n+    if (bench_array == NULL)\n+        bench_array = bench_array_default;\n+    else {\n+        // note - includes null char\n+        int num_default_benchs =\n+            (sizeof(bench_array_default) / sizeof(bench_array_default[0]));\n+        printf(\"\\n Num default methods %d \", num_default_benchs);\n+        bench_array = realloc(bench_array,\n+                (num_default_benchs + num_user_benchs + 1) *\n+                sizeof(*bench_array));\n+        memcpy(bench_array+num_user_benchs, bench_array_default,\n+                num_default_benchs * sizeof(*bench_array_default));\n+    }\n+    is_bench_init = 1;\n+}\n+\n+\n+int codes_conc_bench_load(\n+        const char *program,\n+        int argc, \n+        char *argv[])\n+{\n+    init_bench_methods();\n+\n+    int i;\n+    int ret;\n+\n+    for(i=0; bench_array[i] != NULL; i++)\n+    {\n+        if(strcmp(bench_array[i]->program_name, program) == 0)\n+        {\n+            /* load appropriate workload generator */\n+            ret = bench_array[i]->conceptual_main(argc, argv);\n+            if(ret < 0)\n+            {\n+                return(-1);\n+            }\n+            return(i);\n+        }\n+    }\n+    fprintf(stderr, \"Error: failed to find benchmark program %s\\n\", program);\n+    return(-1);\n+}\n+\n+void codes_conceptual_add_bench(struct codes_conceptual_bench const * bench)\n+{\n+    static int bench_array_cap = 10;\n+    if (is_bench_init)\n+        tw_error(TW_LOC,\n+                \"adding a conceptual benchmark method after initialization is forbidden\");\n+    else if (bench_array == NULL){\n+        bench_array = malloc(bench_array_cap * sizeof(*bench_array));\n+        assert(bench_array);\n+    }\n+\n+    if (num_user_benchs == bench_array_cap) {\n+        bench_array_cap *= 2;\n+        bench_array = realloc(bench_array,\n+                bench_array_cap * sizeof(*bench_array));\n+        assert(bench_array);\n+    }\n+    bench_array[num_user_benchs++] = bench;\n+}\n+\n+\n+\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 9,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/workload/codes-workload-dump.c",
                        "old_path": "src/workload/codes-workload-dump.c",
                        "binary": false,
                        "utf8_diff": "@@ -215,7 +215,7 @@ int main(int argc, char *argv[])\n             wparams = (char*)&d_params;\n         }\n     }\n-    else if(strcmp(type, \"online_comm_workload\") == 0){\n+    else if(strcmp(type, \"swm_online_comm_workload\") == 0 || strcmp(type, \"conc_online_comm_workload\") == 0){\n         if (n == -1){\n             fprintf(stderr,\n                     \"Expected \\\"--num-ranks\\\" argument for online workload\\n\");\n@@ -448,7 +448,7 @@ int main(int argc, char *argv[])\n             }\n         } while (op.op_type != CODES_WK_END);\n \n-    if(strcmp(type, \"online_comm_workload\") == 0)\n+    if(strcmp(type, \"swm_online_comm_workload\") == 0 || strcmp(type, \"conc_online_comm_workload\") == 0)\n     {\n         codes_workload_finalize(type, wparams, 0, i);\n     }\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 10,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/workload/codes-workload.c",
                        "old_path": "src/workload/codes-workload.c",
                        "binary": false,
                        "utf8_diff": "@@ -34,9 +34,14 @@ extern struct codes_workload_method darshan_mpi_io_workload_method;\n #ifdef USE_RECORDER\n extern struct codes_workload_method recorder_io_workload_method;\n #endif\n-#ifdef USE_ONLINE\n-extern struct codes_workload_method online_comm_workload_method;\n+\n+#ifdef USE_SWM\n+extern struct codes_workload_method swm_online_comm_workload_method;\n+#endif\n+#ifdef USE_CONC\n+extern struct codes_workload_method conc_online_comm_workload_method;\n #endif\n+\n extern struct codes_workload_method checkpoint_workload_method;\n extern struct codes_workload_method iomock_workload_method;\n \n@@ -58,8 +63,11 @@ static struct codes_workload_method const * method_array_default[] =\n #endif\n \n #endif\n-#ifdef USE_ONLINE\n-    &online_comm_workload_method,\n+#ifdef USE_SWM\n+    &swm_online_comm_workload_method,\n+#endif\n+#ifdef USE_CONC\n+    &conc_online_comm_workload_method,\n #endif\n #ifdef USE_RECORDER\n     &recorder_io_workload_method,\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 11,
                        "new_file": true,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "0",
                        "b_mode": "100644",
                        "new_path": "src/workload/methods/codes-conc-online-comm-wrkld.C",
                        "old_path": "src/workload/methods/codes-conc-online-comm-wrkld.C",
                        "binary": false,
                        "utf8_diff": "@@ -0,0 +1,845 @@\n+/*\n+ * Copyright (C) 2014 University of Chicago\n+ * See COPYRIGHT notice in top-level directory.\n+ *\n+ */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <mpi.h>\n+#include <ross.h>\n+#include <assert.h>\n+#include <deque>\n+#include <iostream>\n+#include <inttypes.h>\n+#include <fstream>\n+#include <boost/property_tree/json_parser.hpp>\n+#include <boost/property_tree/ptree.hpp>\n+#include <boost/foreach.hpp>\n+#include \"codes/codes-workload.h\"\n+#include \"codes/quickhash.h\"\n+#include \"codes/codes-jobmap.h\"\n+#include \"codes_config.h\"\n+#include \"codes/codes-conc-addon.h\"\n+\n+#define ALLREDUCE_SHORT_MSG_SIZE 2048\n+\n+//#define DBG_COMM 0\n+\n+using namespace std;\n+\n+static struct qhash_table *rank_tbl = NULL;\n+static int rank_tbl_pop = 0;\n+static int total_rank_cnt = 0;\n+ABT_thread global_prod_thread = NULL;\n+ABT_xstream self_es;\n+long cpu_freq = 1.0;\n+long num_allreduce = 0;\n+long num_isends = 0;\n+long num_irecvs = 0;\n+long num_barriers = 0;\n+long num_sends = 0;\n+long num_recvs = 0;\n+long num_sendrecv = 0;\n+long num_waitalls = 0;\n+\n+//std::map<int64_t, int> send_count;\n+//std::map<int64_t, int> isend_count;\n+//std::map<int64_t, int> allreduce_count;\n+\n+struct shared_context {\n+    int my_rank;\n+    uint32_t wait_id;\n+    int num_ranks;\n+    char workload_name[MAX_NAME_LENGTH_WKLD];\n+    void * swm_obj;\n+    void * conc_params;\n+    ABT_thread      producer;\n+    std::deque<struct codes_workload_op*> fifo;\n+};\n+\n+struct rank_mpi_context {\n+    struct qhash_head hash_link;\n+    int app_id;\n+    struct shared_context sctx;\n+};\n+\n+typedef struct rank_mpi_compare {\n+    int app_id;\n+    int rank;\n+} rank_mpi_compare;\n+\n+\n+\n+/* Conceptual online workload implementations */\n+void CODES_MPI_Comm_size (MPI_Comm comm, int *size) \n+{\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err;\n+\n+    err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+\n+    *size = sctx->num_ranks;\n+}\n+\n+void CODES_MPI_Comm_rank( MPI_Comm comm, int *rank ) \n+{\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err;\n+\n+    err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+\n+    *rank = sctx->my_rank;\n+}\n+\n+void CODES_MPI_Finalize()\n+{\n+    /* Add an event in the shared queue and then yield */\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    wrkld_per_rank.op_type = CODES_WK_END;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+\n+    // printf(\"\\n rank %d finalize workload: num_sends %ld num_recvs %ld num_isends %ld num_irecvs %ld num_allreduce %ld num_barrier %ld num_waitalls %ld\\n\", \n+    //         sctx->my_rank, num_sends, num_recvs, num_isends, num_irecvs, num_allreduce, num_barriers, num_waitalls);\n+    // printf(\"Rank %d yield to CODES thread: %p\\n\", sctx->my_rank, global_prod_thread);\n+    ABT_thread_yield_to(global_prod_thread);\n+}\n+\n+void CODES_MPI_Send(const void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int dest, \n+            int tag,\n+            MPI_Comm comm)\n+{\n+    /* add an event in the shared queue and then yield */\n+    //    printf(\"\\n Sending to rank %d \", comm_id);\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    int datatypesize;\n+    MPI_Type_size(datatype, &datatypesize);\n+\n+    wrkld_per_rank.op_type = CODES_WK_SEND;\n+    wrkld_per_rank.u.send.tag = tag;\n+    wrkld_per_rank.u.send.count = count;\n+    wrkld_per_rank.u.send.data_type = datatype;\n+    wrkld_per_rank.u.send.num_bytes = count * datatypesize;\n+    wrkld_per_rank.u.send.dest_rank = dest;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    wrkld_per_rank.u.send.source_rank = sctx->my_rank;\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+    // printf(\"Rank %d Send Event to dest %d: %lld, fifo size: %lu\\n\", sctx->my_rank, dest,\n+    //         wrkld_per_rank.u.send.num_bytes, sctx->fifo.size());\n+\n+    // printf(\"Rank %d yield to CODES thread: %p\\n\", sctx->my_rank, global_prod_thread);\n+    int rc = ABT_thread_yield_to(global_prod_thread);\n+    num_sends++;    \n+}\n+\n+void CODES_MPI_Recv(void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int source, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Status *status)\n+{\n+    /* Add an event in the shared queue and then yield */\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    int datatypesize;\n+    MPI_Type_size(datatype, &datatypesize);\n+\n+    wrkld_per_rank.op_type = CODES_WK_RECV;\n+    wrkld_per_rank.u.recv.tag = tag;\n+    wrkld_per_rank.u.recv.source_rank = source;\n+    wrkld_per_rank.u.recv.data_type = datatype;\n+    wrkld_per_rank.u.recv.count = count;\n+    wrkld_per_rank.u.recv.num_bytes = count * datatypesize;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    wrkld_per_rank.u.recv.dest_rank = sctx->my_rank;\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+    // printf(\"Rank %d Recv event from %d bytes %d fifo size %lu\\n\",  sctx->my_rank, source, wrkld_per_rank.u.recv.num_bytes, sctx->fifo.size());\n+\n+    // printf(\"Rank %d yield to CODES thread: %p\\n\", sctx->my_rank, global_prod_thread);\n+    ABT_thread_yield_to(global_prod_thread);\n+    num_recvs++;    \n+}\n+\n+void CODES_MPI_Sendrecv(const void *sendbuf, \n+            int sendcount, \n+            MPI_Datatype sendtype,\n+            int dest, \n+            int sendtag,\n+            void *recvbuf, \n+            int recvcount, \n+            MPI_Datatype recvtype,\n+            int source, \n+            int recvtag,\n+            MPI_Comm comm, \n+            MPI_Status *status)\n+{\n+    /* sendrecv events */\n+    struct codes_workload_op send_op;\n+\n+    int datatypesize1, datatypesize2;\n+    MPI_Type_size(sendtype, &datatypesize1);\n+    MPI_Type_size(recvtype, &datatypesize2);\n+\n+    send_op.op_type = CODES_WK_SEND;\n+    send_op.u.send.tag = sendtag;\n+    send_op.u.send.count = sendcount;\n+    send_op.u.send.data_type = sendtype;\n+    send_op.u.send.num_bytes = sendcount * datatypesize1;\n+    send_op.u.send.dest_rank = dest;\n+\n+    struct codes_workload_op recv_op;\n+\n+    recv_op.op_type = CODES_WK_RECV;\n+    recv_op.u.recv.tag = recvtag;\n+    recv_op.u.recv.source_rank = source;\n+    recv_op.u.recv.count = recvcount;\n+    recv_op.u.recv.data_type = recvtype;\n+    recv_op.u.recv.num_bytes = recvcount * datatypesize2;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+\n+    /* Add an event in the shared queue and then yield */\n+    recv_op.u.recv.dest_rank = sctx->my_rank;\n+    send_op.u.send.source_rank = sctx->my_rank;\n+    sctx->fifo.push_back(&send_op);\n+    sctx->fifo.push_back(&recv_op);\n+\n+    ABT_thread_yield_to(global_prod_thread);\n+    num_sendrecv++;\n+}\n+\n+\n+void CODES_MPI_Barrier(MPI_Comm comm)\n+{\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err;\n+    int rank, size, src, dest, mask;\n+\n+    err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+\n+    rank = sctx->my_rank;\n+    size = sctx->num_ranks;\n+    mask = 0x1;\n+\n+    while(mask < size) {\n+        dest = (rank + mask) % size;\n+        src = (rank - mask + size) % size;\n+\n+        CODES_MPI_Sendrecv(NULL, 0, MPI_INT, dest, 1234, NULL, 0, MPI_INT, src, 1234,\n+                comm, NULL);\n+\n+        mask <<= 1;\n+    }\n+    num_barriers++; \n+}\n+\n+void CODES_MPI_Isend(const void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int dest, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Request *request)\n+{\n+    /* add an event in the shared queue and then yield */\n+    //    printf(\"\\n Sending to rank %d \", comm_id);\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    int datatypesize;\n+    MPI_Type_size(datatype, &datatypesize);\n+\n+    wrkld_per_rank.op_type = CODES_WK_ISEND;\n+    wrkld_per_rank.u.send.tag = tag;    \n+    wrkld_per_rank.u.send.count = count;\n+    wrkld_per_rank.u.send.data_type = datatype;\n+    wrkld_per_rank.u.send.num_bytes = count * datatypesize;\n+    wrkld_per_rank.u.send.dest_rank = dest;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    wrkld_per_rank.u.send.source_rank = sctx->my_rank;\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+\n+    *request = sctx->wait_id;\n+    wrkld_per_rank.u.send.req_id = *request;\n+    sctx->wait_id++;\n+\n+    ABT_thread_yield_to(global_prod_thread);\n+    num_isends++;\n+}\n+\n+void CODES_MPI_Irecv(void *buf, \n+            int count, \n+            MPI_Datatype datatype, \n+            int source, \n+            int tag,\n+            MPI_Comm comm, \n+            MPI_Request *request)\n+{\n+    /* Add an event in the shared queue and then yield */\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    int datatypesize;\n+    MPI_Type_size(datatype, &datatypesize);\n+\n+    wrkld_per_rank.op_type = CODES_WK_IRECV;\n+    wrkld_per_rank.u.recv.tag = tag;\n+    wrkld_per_rank.u.recv.source_rank = source;\n+    wrkld_per_rank.u.recv.count = count;\n+    wrkld_per_rank.u.recv.data_type = datatype;\n+    wrkld_per_rank.u.recv.num_bytes = count * datatypesize;\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    wrkld_per_rank.u.recv.dest_rank = sctx->my_rank;\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+    \n+    *request = sctx->wait_id;\n+    wrkld_per_rank.u.recv.req_id = *request;\n+    sctx->wait_id++;\n+\n+    ABT_thread_yield_to(global_prod_thread);\n+    num_irecvs++;    \n+}\n+\n+void CODES_MPI_Waitall(int count, \n+            MPI_Request array_of_requests[], \n+            MPI_Status array_of_statuses[])\n+{\n+    num_waitalls++;\n+    /* Add an event in the shared queue and then yield */\n+    struct codes_workload_op wrkld_per_rank;\n+\n+    wrkld_per_rank.op_type = CODES_WK_WAITALL;\n+    /* TODO: Check how to convert cycle count into delay? */\n+    wrkld_per_rank.u.waits.count = count;\n+    wrkld_per_rank.u.waits.req_ids = (unsigned int*)calloc(count, sizeof(int));    \n+\n+    for(int i = 0; i < count; i++)\n+        wrkld_per_rank.u.waits.req_ids[i] = array_of_requests[i];\n+\n+    /* Retreive the shared context state */\n+    ABT_thread prod;\n+    void * arg;\n+    int err = ABT_thread_self(&prod);\n+    assert(err == ABT_SUCCESS);\n+    err =  ABT_thread_get_arg(prod, &arg);\n+    assert(err == ABT_SUCCESS);\n+    struct shared_context * sctx = static_cast<shared_context*>(arg);\n+    sctx->fifo.push_back(&wrkld_per_rank);\n+\n+    ABT_thread_yield_to(global_prod_thread);   \n+}\n+\n+void CODES_MPI_Reduce(const void *sendbuf, \n+            void *recvbuf, \n+            int count, \n+            MPI_Datatype datatype,\n+            MPI_Op op, \n+            int root, \n+            MPI_Comm comm)\n+{\n+    //todo\n+}\n+\n+void CODES_MPI_Allreduce(const void *sendbuf, \n+            void *recvbuf, \n+            int count, \n+            MPI_Datatype datatype,\n+            MPI_Op op, \n+            MPI_Comm comm)\n+{\n+    int comm_size, rank, type_size, i, send_idx, recv_idx, last_idx, send_cnt, recv_cnt;\n+    int pof2, mask, rem, newrank, newdst, dst, *cnts, *disps;\n+\n+    CODES_MPI_Comm_size(comm, &comm_size);\n+    CODES_MPI_Comm_rank(comm, &rank);\n+    MPI_Type_size(datatype, &type_size);\n+\n+    cnts = disps = NULL;\n+    \n+    pof2 = 1;\n+    while (pof2 <= comm_size) pof2 <<= 1;\n+    pof2 >>=1;\n+\n+    rem = comm_size - pof2;\n+\n+    /* In the non-power-of-two case, all even-numbered\n+       processes of rank < 2*rem send their data to\n+       (rank+1). These even-numbered processes no longer\n+       participate in the algorithm until the very end. The\n+       remaining processes form a nice power-of-two. */\n+    if (rank < 2*rem) {\n+        if (rank % 2 == 0) { /* even */\n+            CODES_MPI_Send(NULL, count, datatype, rank+1, -1002, comm);\n+            newrank = -1;\n+        } else { /* odd */\n+            CODES_MPI_Recv(NULL, count, datatype, rank-1, -1002, comm, NULL);\n+            newrank = rank / 2;\n+        }\n+    } else {\n+        newrank = rank - rem;\n+    }\n+\n+    /* If op is user-defined or count is less than pof2, use\n+       recursive doubling algorithm. Otherwise do a reduce-scatter\n+       followed by allgather. (If op is user-defined,\n+       derived datatypes are allowed and the user could pass basic\n+       datatypes on one process and derived on another as long as\n+       the type maps are the same. Breaking up derived\n+       datatypes to do the reduce-scatter is tricky, therefore\n+       using recursive doubling in that case.) */\n+    if (newrank != -1) { \n+        if ((count*type_size <= 81920 ) || (count < pof2)) {\n+            mask = 0x1;\n+            while (mask < pof2) {\n+                newdst = newrank ^ mask;\n+                dst = (newdst < rem) ? newdst*2 + 1 : newdst + rem;\n+\n+                CODES_MPI_Sendrecv(NULL, count, datatype, dst, -1002, NULL, count, datatype, dst, -1002, comm, NULL);\n+                mask <<= 1;\n+            }\n+        } else {\n+            /* do a reduce-scatter followed by allgather */\n+            /* for the reduce-scatter, calculate the count that\n+            each process receives and the displacement within\n+            the buffer */\n+\n+            cnts = (int*)malloc(pof2*sizeof(int));\n+            disps = (int*)malloc(pof2*sizeof(int));\n+            \n+            for (i=0; i<(pof2-1); i++)\n+                cnts[i] = count/pof2;\n+            cnts[pof2-1] = count - (count/pof2)*(pof2-1);\n+            \n+            disps[0] = 0;\n+            for (i=1; i<pof2; i++)\n+                disps[i] = disps[i-1] + cnts[i-1];\n+\n+            mask = 0x1;\n+            send_idx = recv_idx = 0;\n+            last_idx = pof2;\n+            while (mask < pof2) {\n+                newdst = newrank ^ mask;\n+                dst = (newdst < rem) ? newdst*2 + 1 : newdst + rem;\n+                send_cnt = recv_cnt = 0;\n+                if (newrank < newdst) {\n+                    send_idx = recv_idx + pof2/(mask*2);\n+                    for (i=send_idx; i<last_idx; i++)\n+                        send_cnt += cnts[i];\n+                    for (i=recv_idx; i<send_idx; i++)\n+                        recv_cnt += cnts[i];\n+                } else {\n+                    recv_idx = send_idx + pof2/(mask*2);\n+                    for (i=send_idx; i<recv_idx; i++)\n+                        send_cnt += cnts[i];\n+                    for (i=recv_idx; i<last_idx; i++)\n+                        recv_cnt += cnts[i];\n+                }\n+\n+                CODES_MPI_Sendrecv(NULL, send_cnt, datatype, dst, -1002, NULL, recv_cnt, datatype, dst, -1002, comm, NULL);\n+\n+                send_idx = recv_idx;\n+                mask <<= 1;\n+    \n+                if(mask < pof2)\n+                    last_idx = recv_idx + pof2/mask;\n+            }\n+        \n+            /* now do the allgather */\n+            mask >>= 1;\n+            while (mask > 0) {\n+                newdst = newrank ^ mask;\n+                /* find real rank of dest */\n+                dst = (newdst < rem) ? newdst*2 + 1 : newdst + rem;\n+\n+                send_cnt = recv_cnt = 0;\n+                if (newrank < newdst) {\n+                    if (mask != pof2/2)\n+                        last_idx = last_idx + pof2/(mask*2);\n+                \n+                    recv_idx = send_idx + pof2/(mask*2);\n+                    for (i=send_idx; i<recv_idx; i++)\n+                        send_cnt += cnts[i];\n+                    for (i=recv_idx; i<last_idx; i++)\n+                        recv_cnt += cnts[i];\n+                } else {\n+                    recv_idx = send_idx - pof2/(mask*2);\n+                    for (i=send_idx; i<last_idx; i++)\n+                        send_cnt += cnts[i];\n+                    for (i=recv_idx; i<send_idx; i++)\n+                        recv_cnt += cnts[i];\n+                }\n+\n+                CODES_MPI_Sendrecv(NULL, send_cnt, datatype, dst, -1002, NULL, recv_cnt, datatype, dst, -1002, comm, NULL);\n+\n+                if (newrank > newdst) send_idx = recv_idx;\n+                mask >>= 1;\n+            }\n+        }\n+    } \n+\n+    if(rank < 2*rem) {\n+        if(rank % 2) {/* odd */\n+            CODES_MPI_Send(NULL, count, datatype, rank-1, -1002, comm);\n+        } else {\n+            CODES_MPI_Recv(NULL, count, datatype, rank+1, -1002, comm, NULL);\n+        }\n+    }\n+\n+    if(cnts) free(cnts);\n+    if(disps) free(disps);    \n+}\n+\n+void CODES_MPI_Bcast(void *buffer, \n+            int count, \n+            MPI_Datatype datatype, \n+            int root, \n+            MPI_Comm comm)\n+{\n+    //todo\n+}\n+\n+void CODES_MPI_Alltoall(const void *sendbuf, \n+            int sendcount, \n+            MPI_Datatype sendtype, \n+            void *recvbuf,\n+            int recvcount, \n+            MPI_Datatype recvtype, \n+            MPI_Comm comm)\n+{\n+    int *sendcounts, *sdispls, *recvcounts, *rdispls;\n+    int i, comm_size;\n+\n+    CODES_MPI_Comm_size(comm, &comm_size);\n+ \n+    for (i=0; i<comm_size; i++) {\n+        sendcounts[i] = sendcount;\n+        recvcounts[i] = recvcount;\n+        rdispls[i] = i * recvcount;\n+        sdispls[i] = i * sendcount;\n+    }\n+    CODES_MPI_Alltoallv(sendbuf, sendcounts, sdispls, sendtype, recvbuf, recvcounts, rdispls, recvtype, comm);\n+}\n+\n+void CODES_MPI_Alltoallv(const void *sendbuf, \n+            const int *sendcounts, \n+            const int *sdispls,\n+            MPI_Datatype sendtype, \n+            void *recvbuf, \n+            const int *recvcounts,\n+            const int *rdispls, \n+            MPI_Datatype recvtype, \n+            MPI_Comm comm)\n+{\n+    int comm_size, i, j;\n+    int dst, rank, req_cnt, req_num = 1;\n+    int ii, ss, bblock;\n+    int type_size;\n+\n+    bblock = 32; //equivalent of MPIR_CVAR_ALLTOALL_THROTTLE in Mpich\n+\n+    MPI_Status starray[2*bblock];\n+    MPI_Request reqarray[2*bblock];\n+\n+    CODES_MPI_Comm_size(comm, &comm_size);\n+    CODES_MPI_Comm_rank(comm, &rank);\n+\n+\n+    for(ii=0; ii<comm_size; ii+=bblock) {\n+\n+        req_cnt = 0;\n+        ss = comm_size-ii < bblock ? comm_size-ii : bblock;\n+\n+        for ( i=0; i<ss; i++ ) {\n+            dst = (rank+i+ii) % comm_size;\n+            if (recvcounts[dst]) {\n+                req_num++; // hopefuly the program is not doing other requests at the same time...\n+                reqarray[req_cnt] = req_num;\n+                CODES_MPI_Irecv(NULL, recvcounts[dst], recvtype, dst, -1003, comm, &req_num);\n+                req_cnt++;\n+            }\n+        }\n+\n+        for ( i=0; i<ss; i++ ) {\n+            dst = (rank-i-ii+comm_size) % comm_size;\n+            if (sendcounts[dst]) {\n+                req_num++;\n+                reqarray[req_cnt] = req_num;\n+                CODES_MPI_Isend(NULL, sendcounts[dst], sendtype, dst, -1003, comm, &req_num);\n+                req_cnt++;\n+            }\n+        }\n+        CODES_MPI_Waitall(req_cnt, reqarray, starray);\n+    } \n+}\n+\n+static int hash_rank_compare(void *key, struct qhash_head *link)\n+{\n+    rank_mpi_compare *in = (rank_mpi_compare*)key;\n+    rank_mpi_context *tmp;\n+\n+    tmp = qhash_entry(link, rank_mpi_context, hash_link);\n+    if (tmp->sctx.my_rank == in->rank && tmp->app_id == in->app_id)\n+        return 1;\n+    return 0;\n+}\n+static void workload_caller(void * arg)\n+{\n+    shared_context* sctx = static_cast<shared_context*>(arg);\n+\n+    //printf(\"\\n workload name %s \", sctx->workload_name);\n+    if(strncmp(sctx->workload_name, \"conceptual\", 10) == 0)\n+    {\n+        conc_bench_param * conc_params = static_cast<conc_bench_param*> (sctx->conc_params);\n+        // printf(\"program: %s\\n\",conc_params->conc_program);\n+        // printf(\"argc: %d\\n\",conc_params->conc_argc);\n+        int i;\n+        for (i=0; i<conc_params->conc_argc; i++){\n+            conc_params->conc_argv[i] = conc_params->config_in[i];\n+        }\n+        // conc_params->argv = &conc_params->conc_argv;\n+        codes_conc_bench_load(conc_params->conc_program, \n+                        conc_params->conc_argc, \n+                        conc_params->conc_argv);\n+    }\n+}\n+\n+static int comm_online_workload_load(const char * params, int app_id, int rank)\n+{\n+    /* LOAD parameters from JSON file*/\n+    online_comm_params * o_params = (online_comm_params*)params;\n+    int nprocs = o_params->nprocs;\n+\n+    rank_mpi_context *my_ctx = new rank_mpi_context;\n+    //my_ctx = (rank_mpi_context*)caloc(1, sizeof(rank_mpi_context));  \n+    assert(my_ctx); \n+    my_ctx->sctx.my_rank = rank; \n+    my_ctx->sctx.num_ranks = nprocs;\n+    my_ctx->sctx.wait_id = 0;\n+    my_ctx->app_id = app_id;\n+\n+    void** generic_ptrs;\n+    int array_len = 1;\n+    generic_ptrs = (void**)calloc(array_len,  sizeof(void*));\n+    generic_ptrs[0] = (void*)&rank;\n+\n+    strcpy(my_ctx->sctx.workload_name, o_params->workload_name);\n+    boost::property_tree::ptree root, child;\n+    string swm_path, conc_path;\n+\n+    if(strncmp(o_params->workload_name, \"conceptual\", 10) == 0)\n+    {\n+        conc_path.append(ONLINE_CONFIGDIR);\n+        conc_path.append(\"/conceptual.json\");\n+    }\n+    else\n+        tw_error(TW_LOC, \"\\n Undefined workload type %s \", o_params->workload_name);\n+\n+    // printf(\"\\npath %s\\n\", conc_path.c_str());\n+    try {\n+        std::ifstream jsonFile(conc_path.c_str());\n+        boost::property_tree::json_parser::read_json(jsonFile, root);\n+\n+        // printf(\"workload_name: %s\\n\", o_params->workload_name);\n+        conc_bench_param *tmp_params = (conc_bench_param *) calloc(1, sizeof(conc_bench_param));\n+        strcpy(tmp_params->conc_program, &o_params->workload_name[11]);\n+        child = root.get_child(tmp_params->conc_program);\n+        tmp_params->conc_argc = child.get<int>(\"argc\");\n+        int i = 0;\n+        BOOST_FOREACH(boost::property_tree::ptree::value_type &v, child.get_child(\"argv\"))\n+        {\n+            assert(v.first.empty()); // array elements have no names\n+            // tmp_params->conc_argv[i] = (char *) v.second.data().c_str();\n+            strcpy(tmp_params->config_in[i], v.second.data().c_str());\n+            i += 1;           \n+        }\n+        my_ctx->sctx.conc_params = (void*) tmp_params;\n+    }\n+    catch(std::exception & e)\n+    {\n+        printf(\"%s \\n\", e.what());\n+        return -1;\n+    }\n+\n+    if(global_prod_thread == NULL)\n+    {\n+        ABT_xstream_self(&self_es);\n+        ABT_thread_self(&global_prod_thread);\n+    }\n+    ABT_thread_create_on_xstream(self_es, \n+            &workload_caller, (void*)&(my_ctx->sctx),\n+            ABT_THREAD_ATTR_NULL, &(my_ctx->sctx.producer));\n+\n+    // printf(\"Rank %d create app thread %p\\n\", rank, my_ctx->sctx.producer);\n+    rank_mpi_compare cmp;\n+    cmp.app_id = app_id;\n+    cmp.rank = rank;\n+\n+    if(!rank_tbl)\n+    {\n+        rank_tbl = qhash_init(hash_rank_compare, quickhash_64bit_hash, nprocs);\n+        if(!rank_tbl)\n+            return -1;\n+    }\n+    qhash_add(rank_tbl, &cmp, &(my_ctx->hash_link));\n+    rank_tbl_pop++;\n+\n+    return 0;\n+}\n+\n+static void comm_online_workload_get_next(int app_id, int rank, struct codes_workload_op * op)\n+{\n+    /* At this point, we will use the \"call\" function. The send/receive/wait\n+     * definitions will be replaced by our own function definitions that will do a\n+     * yield to argobots if an event is not available. */\n+    /* if shared queue is empty then yield */\n+\n+    rank_mpi_context * temp_data;\n+    struct qhash_head * hash_link = NULL;\n+    rank_mpi_compare cmp;\n+    cmp.rank = rank;\n+    cmp.app_id = app_id;\n+    hash_link = qhash_search(rank_tbl, &cmp);\n+    if(!hash_link)\n+    {\n+        printf(\"\\n not found for rank id %d , %d\", rank, app_id);\n+        op->op_type = CODES_WK_END;\n+        return;\n+    }\n+    temp_data = qhash_entry(hash_link, rank_mpi_context, hash_link);\n+    assert(temp_data);\n+    while(temp_data->sctx.fifo.empty())\n+    {\n+        // printf(\"Rank %d fifo empty, yield to app %p\\n\", rank, temp_data->sctx.producer);\n+        int rc = ABT_thread_yield_to(temp_data->sctx.producer); \n+    }\n+    struct codes_workload_op * front_op = temp_data->sctx.fifo.front();\n+    assert(front_op);\n+    // printf(\"Pop op %d to CODES\\n\", front_op->op_type);\n+    *op = *front_op;\n+    temp_data->sctx.fifo.pop_front();\n+    return;\n+}\n+static int comm_online_workload_get_rank_cnt(const char *params, int app_id)\n+{\n+    online_comm_params * o_params = (online_comm_params*)params;\n+    int nprocs = o_params->nprocs;\n+    return nprocs;\n+}\n+\n+static int comm_online_workload_finalize(const char* params, int app_id, int rank)\n+{\n+    rank_mpi_context * temp_data;\n+    struct qhash_head * hash_link = NULL;\n+    rank_mpi_compare cmp;\n+    cmp.rank = rank;\n+    cmp.app_id = app_id;\n+    hash_link = qhash_search(rank_tbl, &cmp);\n+    if(!hash_link)\n+    {\n+        printf(\"\\n not found for rank id %d , %d\", rank, app_id);\n+        return -1;\n+    }\n+    temp_data = qhash_entry(hash_link, rank_mpi_context, hash_link);\n+    assert(temp_data);\n+\n+    int rc;\n+    rc = ABT_thread_join(temp_data->sctx.producer);    \n+    // printf(\"thread terminate rc=%d\\n\", rc);\n+    rc = ABT_thread_free(&(temp_data->sctx.producer));\n+    // printf(\"thread free rc=%d\\n\", rc);\n+    free(temp_data->sctx.conc_params);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n+    return 0;\n+}\n+extern \"C\" {\n+/* workload method name and function pointers for the CODES workload API */\n+struct codes_workload_method conc_online_comm_workload_method =\n+{\n+    //.method_name =\n+    (char*)\"conc_online_comm_workload\",\n+    //.codes_workload_read_config = \n+    NULL,\n+    //.codes_workload_load = \n+    comm_online_workload_load,\n+    //.codes_workload_get_next = \n+    comm_online_workload_get_next,\n+    // .codes_workload_get_next_rc2 = \n+    NULL,\n+    // .codes_workload_get_rank_cnt\n+    comm_online_workload_get_rank_cnt,\n+    // .codes_workload_finalize = \n+    comm_online_workload_finalize\n+};\n+} // closing brace for extern \"C\"\n+\n"
                    },
                    {
                        "merge_request_diff_id": 3178,
                        "relative_order": 12,
                        "new_file": false,
                        "renamed_file": false,
                        "deleted_file": false,
                        "too_large": false,
                        "a_mode": "100644",
                        "b_mode": "100644",
                        "new_path": "src/workload/methods/codes-online-comm-wrkld.C",
                        "old_path": "src/workload/methods/codes-online-comm-wrkld.C",
                        "binary": false,
                        "utf8_diff": "@@ -950,10 +950,10 @@ static int comm_online_workload_finalize(const char* params, int app_id, int ran\n }\n extern \"C\" {\n /* workload method name and function pointers for the CODES workload API */\n-struct codes_workload_method online_comm_workload_method =\n+struct codes_workload_method swm_online_comm_workload_method =\n {\n     //.method_name =\n-    (char*)\"online_comm_workload\",\n+    (char*)\"swm_online_comm_workload\",\n     //.codes_workload_read_config = \n     NULL,\n     //.codes_workload_load = \n"
                    }
                ]
            },
            "events": [
                {
                    "id": 69928,
                    "project_id": 68,
                    "author_id": 443,
                    "target_id": 1489,
                    "created_at": "2019-01-22T23:55:07.244Z",
                    "updated_at": "2019-01-22T23:55:07.244Z",
                    "target_type": "MergeRequest",
                    "action": 1
                }
            ],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        },
        {
            "id": 85,
            "target_branch": "master",
            "source_branch": "fattree-test-conf",
            "source_project_id": 68,
            "author_id": 85,
            "assignee_id": 75,
            "title": "Updated fat tree trace test config file",
            "created_at": "2017-01-19T21:40:41.203Z",
            "updated_at": "2017-07-20T16:14:44.160Z",
            "state": "closed",
            "merge_status": "cannot_be_merged",
            "target_project_id": 68,
            "iid": 20,
            "description": "",
            "updated_by_id": null,
            "merge_error": null,
            "merge_params": {
                "force_remove_source_branch": "1"
            },
            "merge_when_pipeline_succeeds": false,
            "merge_user_id": null,
            "merge_commit_sha": null,
            "in_progress_merge_commit_sha": null,
            "lock_version": null,
            "time_estimate": 0,
            "last_edited_at": null,
            "last_edited_by_id": null,
            "head_pipeline_id": null,
            "discussion_locked": null,
            "rebase_commit_sha": null,
            "allow_maintainer_to_push": null,
            "squash": false,
            "diff_head_sha": null,
            "source_branch_sha": null,
            "target_branch_sha": "fb41c9c0b553f6a042834de25dec05fc8c5f70ba",
            "metrics": {
                "id": 48,
                "merge_request_id": 85,
                "latest_build_started_at": null,
                "latest_build_finished_at": null,
                "first_deployed_to_production_at": null,
                "merged_at": null,
                "created_at": "2017-01-19T21:40:41.554Z",
                "updated_at": "2017-01-19T21:40:41.554Z",
                "pipeline_id": null,
                "merged_by_id": null,
                "latest_closed_by_id": null,
                "latest_closed_at": null
            },
            "notes": [
                {
                    "id": 5541,
                    "note": "deleted source branch `fattree-test-conf`",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2017-07-18T14:41:55.608Z",
                    "updated_at": "2017-07-18T14:41:55.608Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 85,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "dde1a828af16d6c9aa9ac369d276eadab8b2a7d2",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                },
                {
                    "id": 5567,
                    "note": "closed",
                    "noteable_type": "MergeRequest",
                    "author_id": 75,
                    "created_at": "2017-07-20T16:14:44.159Z",
                    "updated_at": "2017-07-20T16:14:44.159Z",
                    "project_id": 68,
                    "attachment": {
                        "url": null
                    },
                    "line_code": null,
                    "commit_id": null,
                    "noteable_id": 85,
                    "system": true,
                    "st_diff": null,
                    "updated_by_id": null,
                    "position": null,
                    "original_position": null,
                    "resolved_at": null,
                    "resolved_by_id": null,
                    "discussion_id": "2acee5e44a6789202445c124fed6079dd70a3548",
                    "change_position": null,
                    "resolved_by_push": null,
                    "author": {
                        "name": "Misbah Mubarak"
                    },
                    "events": []
                }
            ],
            "merge_request_diff": {
                "id": 255,
                "state": "empty",
                "merge_request_id": 85,
                "created_at": "2017-07-18T14:41:55.179Z",
                "updated_at": "2017-07-18T14:41:55.305Z",
                "base_commit_sha": null,
                "real_size": null,
                "head_commit_sha": null,
                "start_commit_sha": "b25e8d109cd0413b10ddcad85ce2154d5a51eead",
                "commits_count": 0,
                "merge_request_diff_commits": [],
                "merge_request_diff_files": []
            },
            "events": [],
            "timelogs": [],
            "label_links": [],
            "resource_label_events": []
        }
    ]
}
